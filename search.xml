<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Effective Java--创建和销毁对象</title>
    <url>/2022/01/13/Effective-Java-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="第一条：用静态工厂方法代替构造器"><a href="#第一条：用静态工厂方法代替构造器" class="headerlink" title="第一条：用静态工厂方法代替构造器"></a>第一条：用静态工厂方法代替构造器</h2><blockquote>
<p>静态工厂方法和构造器方法各有优势，在选择时应根据实际需求选择，而不是盲目采用构造器或者盲目采用静态工厂方法。</p>
</blockquote>
<h3 id="静态工厂方法相比于构造器，优势在于有名称"><a href="#静态工厂方法相比于构造器，优势在于有名称" class="headerlink" title="静态工厂方法相比于构造器，优势在于有名称"></a>静态工厂方法相比于构造器，优势在于有名称</h3><p>这个相对来说比较好理解。假如 <strong>BigInteger（int, int, Random）</strong> 返回素数，这时候它的返回类型只能定义为Int类型，调用者如果使用构造器，代码一般如下：</p>
<p><code>Int getNumber = new BigInteger(3, 9, ...)</code>  </p>
<p>这样再创建对象的时候，无法判断返回的是一个什么数。，但是使用静态工厂方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int <span class="title">probablePrime</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">	/.../</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则可以通过根据调用 <strong>BigInteger.probablePrime</strong> 来判断出这是一个素数。</p>
<h3 id="静态工厂方法相比于构造器，不必每次调用时都创建一个新对象"><a href="#静态工厂方法相比于构造器，不必每次调用时都创建一个新对象" class="headerlink" title="静态工厂方法相比于构造器，不必每次调用时都创建一个新对象"></a>静态工厂方法相比于构造器，不必每次调用时都创建一个新对象</h3><p>这种方法类似于设计模式中的享元模式。比如下方代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用 <strong>valueOf</strong> 方法时，每次不必返回新的对象，都是返回已有对象的地址引用。</p>
<h3 id="静态工厂方法相比于构造器，可以返回原返回类型的任何子类型对象"><a href="#静态工厂方法相比于构造器，可以返回原返回类型的任何子类型对象" class="headerlink" title="静态工厂方法相比于构造器，可以返回原返回类型的任何子类型对象"></a>静态工厂方法相比于构造器，可以返回原返回类型的任何子类型对象</h3><p>这个在理解是可能会出现一些偏差。先看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> People <span class="title">createChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Children childer = <span class="keyword">new</span> Children();</span><br><span class="line">        <span class="keyword">return</span> childer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//People的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果使用构造器来创建对象，那么代码就是<code>People people = new People();</code>,这样返回的类型就只是 <strong>People</strong>类了，但是我们使用静态工厂方法的话，如上面代码所示，在静态工厂方法中可以直接返回Children的实例。</p>
<p>注：当时我的疑惑点主要在于<strong>People类</strong>中的<strong>createChildren()方法</strong>，当时认为<strong>不使用static</strong>也可以返回<strong>Children的实例</strong>。后面想明白，这使用静态工厂来创建对象，如果不使用static，那么该类的实例化会在<strong>createChildren()方法</strong>之前，那么就无法使用该方法来创建对象了。</p>
<h3 id="静态工厂方法相比于构造器，所返回对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值"><a href="#静态工厂方法相比于构造器，所返回对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值" class="headerlink" title="静态工厂方法相比于构造器，所返回对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值"></a>静态工厂方法相比于构造器，所返回对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值</h3><p>这个相对好理解一些。在静态工厂方法中，我们可以根据参数进行判断，根据参数不同返回不同的值，而构造方法则不行。其实从上一条也可以推出这条。</p>
<h3 id="静态工厂方法相比于构造器，方法返回对象所属的类，在编写包含该静态工厂方法的类时可以不存在"><a href="#静态工厂方法相比于构造器，方法返回对象所属的类，在编写包含该静态工厂方法的类时可以不存在" class="headerlink" title="静态工厂方法相比于构造器，方法返回对象所属的类，在编写包含该静态工厂方法的类时可以不存在"></a>静态工厂方法相比于构造器，方法返回对象所属的类，在编写包含该静态工厂方法的类时可以不存在</h3><p>这里引用一些别人的例子加上我自己的一些理解，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//四大组成之一：服务接口</span><br><span class="line">public interface LoginService &#123;//这是一个登录服务</span><br><span class="line">    public void login();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//四大组成之二：服务提供者接口</span><br><span class="line">public interface Provider &#123;//登录服务的提供者。通俗点说就是：通过这个newLoginService()可以获得一个服务。</span><br><span class="line">    public LoginService newLoginService();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 这是一个服务管理器，里面包含了四大组成中的三和四</span><br><span class="line"> * 解释：通过注册将 服务提供者 加入map，然后通过一个静态工厂方法 getService(String name) 返回不同的服务。</span><br><span class="line"> */</span><br><span class="line">public class ServiceManager &#123;</span><br><span class="line">    private static final Map&lt;String, Provider&gt; providers = new HashMap&lt;String, Provider&gt;();//map，保存了注册的服务</span><br><span class="line"> </span><br><span class="line">    private ServiceManager() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //四大组成之三：提供者注册API  (其实很简单，就是注册一下服务提供者)</span><br><span class="line">    public static void registerProvider(String name, Provider provider) &#123;</span><br><span class="line">        providers.put(name, provider);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //四大组成之四：服务访问API   (客户端只需要传递一个name参数，系统会去匹配服务提供者，然后提供服务)  (静态工厂方法)</span><br><span class="line">    public static LoginService getService(String name) &#123;</span><br><span class="line">        Provider provider = providers.get(name);</span><br><span class="line">        if (provider == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;No provider registered with name=&quot; + name);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        return provider.newLoginService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码的 <strong>ServiceManager类</strong> 的 <strong>getService()</strong> 方法返回的是 <strong>LoginService()</strong>, 在编写的时候，<strong>LoginService</strong>方法可以没有被初始化等操作，待运行阶段调用前进行初始化等操作即可。</p>
<h3 id="静态工厂方法相比于构造器的劣势"><a href="#静态工厂方法相比于构造器的劣势" class="headerlink" title="静态工厂方法相比于构造器的劣势"></a>静态工厂方法相比于构造器的劣势</h3><ol>
<li>静态工厂方法的主要缺点在于，类如果不含公有的或者受保护的构造器，就不能被子类化。</li>
<li>静态工厂方法的第二个缺点在于，程序员很难发现他们。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式--单例模式</title>
    <url>/2022/02/23/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>写在前面：<strong>线程安全</strong>就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。      </p>
<p><strong>线程不安全</strong>就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
</blockquote>
<p>单例模式有八种方式，其中完美无缺的有两种。</p>
<p>但是实际工作中不一定用的是完美无缺的。</p>
<h4 id="第一种：饿汉式"><a href="#第一种：饿汉式" class="headerlink" title="第一种：饿汉式"></a>第一种：饿汉式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Mg01 &#123;</span><br><span class="line">    public static final Mg01 INSTANCE = new Mg01();</span><br><span class="line"></span><br><span class="line">    private Mg01() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    public Mg01 getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类加载到内存后,就实例化一个单例,JVM保证线程安全简单实用,推荐实用!</p>
<p>唯一缺点:不管用到与否,类装载时就完成实例化(话说你不用的,你装载它干啥)</p>
<blockquote>
<p>这样写，由于Mgr01被private修饰，故不能够再new一个新的Mgr01，如果要一个新的，只能够调用getInstance方法，注意看getInstance，return的是一个INSTANCE，就是上面被final修饰的实例化的对象名，意思就是无论你调用多少次，返回的都是被final修饰的那个对象</p>
</blockquote>
<h4 id="第二种：懒汉式"><a href="#第二种：懒汉式" class="headerlink" title="第二种：懒汉式"></a>第二种：懒汉式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Mg02 &#123;</span><br><span class="line">    public static Mg02 INSTANCE = new Mg02();</span><br><span class="line"></span><br><span class="line">    private Mg02() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public Mg02 getInstance()&#123;</span><br><span class="line">        if (INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new  Mg02();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先声明但是没有初始化，在getInstance方法里面，先判断是否存在该实例对象，如果不存在，则创建，存在则返回该实例，从而保证单例。</p>
<p>这里定义时不能加final，因为用final修饰就必须初始化</p>
<p>但是会有线程不安全的问题，可能两个线程在没到return前创建了两个实例，此时两个是不同的实例，那么就无法保证是单例的了。</p>
<h4 id="第四种：用锁（效率下降）"><a href="#第四种：用锁（效率下降）" class="headerlink" title="第四种：用锁（效率下降）"></a>第四种：用锁（效率下降）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Mg03 &#123;</span><br><span class="line">    public static Mg03 INSTANCE = new Mg03();</span><br><span class="line"></span><br><span class="line">    private Mg03() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized Mg03 getInstance()&#123;</span><br><span class="line">        if (INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new  Mg02();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="第五种：静态内部类"><a href="#第五种：静态内部类" class="headerlink" title="第五种：静态内部类"></a>第五种：静态内部类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Mg03 &#123;</span><br><span class="line">    private static class Mg03Holder &#123;</span><br><span class="line">        public static final Mg03 INSTANCE = new Mg03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Mg03() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public Mg03 getInstance()&#123;</span><br><span class="line">        return Mg03Holder.INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个线程安全是由<code>jvm</code>保证的，<code>jvm</code>加载类的时候只加载一次，所以<code>Mg03Holder</code>和<code>getInstance</code>也只加载一次，从而保证线程安全。</p>
<h4 id="第六种：枚举（完美写法）"><a href="#第六种：枚举（完美写法）" class="headerlink" title="第六种：枚举（完美写法）"></a>第六种：枚举（完美写法）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Mg04 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法无法被反序列化的原因：java的反射可以通过一个class文件把整个class加载到内存，再通过反序列化new一个新的类。实际中想阻挡这种写法需要设置内部变量，很复杂。</p>
<p>而枚举单例无法被反序列化，因为枚举类没有构造方法，所以拿到class文件也无法构造对象。如上图中反序列化之后返回的值是INSTANCE,如果根据这个值创建对象的话，那么这个对象和我们单例里创建的是同一个对象，所以严格讲这个是最完美的方法。</p>
<p><strong>综合来看，一般都用第一种就行</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL存储引擎</title>
    <url>/2022/03/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h3 id="存储引擎概述"><a href="#存储引擎概述" class="headerlink" title="存储引擎概述"></a>存储引擎概述</h3><p><code>MySQL5.7</code>版本支持的存储引擎有<code>InnoDB</code>、<code>MyISAM</code>、<code>MEMORY</code>、<code>CSV</code>、<code>BLACKHOLE</code>、<code>ARCHIVE</code>、<code>MERGE</code>、<code>FEDERATED</code>、<code>EXAMPLE</code>、<code>NDB</code>等。其中<code>InnoDB</code>和<code>NBDB</code>提供事务安全表，其他都是非事务安全表。</p>
<p>由于常见的存储引擎为<code>InnoDB</code>和<code>MyISAM</code>，所以本篇博客只讨论这两种存储引擎。</p>
<p>其实在此之前，我一直认为存储引擎是基于整个数据库而言的，比如说一个数据库只能设定成一种存储引擎，其实不是的。<strong>存储引擎是基于表级别的。</strong></p>
<p>在创建新表的时候，可以使用关键字<code>ENGINE</code>来设置新建表的存储引擎，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table A(</span><br><span class="line">	...</span><br><span class="line">)ENGINE=MyISAM</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table B(</span><br><span class="line">	...</span><br><span class="line">)ENGINE=InnoDB</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>修改表的存储引擎需要锁表并复制数据，对于线上环境的表进行这个操作非常危险，除非你非常了解可能造成的影响</strong>。</p>
</blockquote>
<h3 id="各类存储引擎的特性"><a href="#各类存储引擎的特性" class="headerlink" title="各类存储引擎的特性"></a>各类存储引擎的特性</h3><table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">MyISAM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B树索引</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">备份/时间点恢复</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持集群</td>
<td align="center">——</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">聚簇索引</td>
<td align="center">——</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">数据压缩</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">数据缓存</td>
<td align="center">——</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">数据加密</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持外键</td>
<td align="center">——</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">地理坐标数据类型</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">地理坐标索引</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">哈希索引</td>
<td align="center">——</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">索引缓存</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">锁粒度</td>
<td align="center">表级</td>
<td align="center">行级</td>
</tr>
<tr>
<td align="center">MVCC多版本控制</td>
<td align="center">——</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持复制</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">存储限制</td>
<td align="center">256TB</td>
<td align="center">64TB</td>
</tr>
<tr>
<td align="center">T树索引</td>
<td align="center">——</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">支持事务</td>
<td align="center">——</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">统计信息</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<blockquote>
<p>聚簇索引：<a href="https://juejin.cn/post/6844903972843552781">https://juejin.cn/post/6844903972843552781</a></p>
</blockquote>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p><code>MyISAM</code>在某些场景中相对<code>InnoDB</code>的访问速度有明显优势，对事务完整性没有要求或以<code>Select</code>、<code>Insert</code>为主的应用可以使用这个引擎来创建表。</p>
<p><code>MyISAM</code>的表支持三种不同的存储格式：静态表、动态表、压缩表。</p>
<h5 id="静态表："><a href="#静态表：" class="headerlink" title="静态表："></a>静态表：</h5><p>静态表是默认存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。</p>
<p>静态表的数据在存储时会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经丢掉。在保存数据的时候，如果某个要保存的内容前后后空格，那么在返回结果的时候会被去掉。</p>
<h5 id="动态表："><a href="#动态表：" class="headerlink" title="动态表："></a>动态表：</h5><p>动态表包含变长字段，记录不固定长度，这样存储的有点是占用空间相对较少，但是频繁地更新和删除记录会产生碎片，需要定期执行<code>OPTIMIZE TABLE</code>或<code>myisamchk-r</code>命令来改善性能，并且在出现故障时恢复相对比较困难。</p>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>该引擎具有提交、回滚和崩溃恢复能力地事务安全保障，同时提供了更小的锁粒度和更强地并发能力，拥有自己独立的缓存和日志，在<code>MySQL5.6</code>和<code>5.7</code>版本中性能有较大的提升。</p>
<p>相对<code>MyISAM</code>而言，<code>InnoDB</code>会占用更多的磁盘空间以保存数据和索引。但是在大多数情况下，<code>InnoDB</code>都是更好的选择。</p>
<h5 id="自动增长列"><a href="#自动增长列" class="headerlink" title="自动增长列"></a>自动增长列</h5><p><code>InnoDB</code>表的自动增长可以手工插入，但是如果插入的值为空，则实际插入的将是自动增长后的值。另外对于自动增长的值可以手动设置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter TABLE *** AUTO_INCREMENT=N</span><br></pre></td></tr></table></figure>

<p>在<code>MySQL8.0</code>之前，对于<code>InnoDB</code>引擎，这个值存在内存中，那么在数据库重启后，这个值便会丢失，数据库会自动将这个值重置为自增列当前存储最大值+1，可能会引起数据冲突。但是在<code>MySQL8.0</code>中这个Bug得到了修复，实现方式是将自增主键的计数器持久化到<code>REDO LOG</code>中，每次计数器发生改变，都会将其写入<code>REDO LOG</code>，重启后则会根据其中的信息来初始化其内存值。</p>
<p>对于<code>InnoDB</code>表，自动增长的列必须被索引。如果是组合索引，也必须是组合索引的第一列。但是对于<code>MyISAM</code>表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。</p>
<h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><p><code>MySQL</code>支持外键的只有<code>InnoDB</code>存储引擎，在创建外键时，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。</p>
<p>当某个表被其他表创建了外键参照，那么该表的对应索引或者主键禁止被删除。</p>
<blockquote>
<p>外键需要注意的细节较多，一旦使用不当，可能会带来性能下降或者数据不一致问题，需要慎用。</p>
</blockquote>
<h5 id="主键和索引"><a href="#主键和索引" class="headerlink" title="主键和索引"></a>主键和索引</h5><p>不同于其他存储引擎，<code>InnoDB</code>存储引擎的数据文件本身就是以聚簇索引的形式保存的，这个聚簇索引也被称为主索引，也是<code>InnoDB</code>的主键，<code>InnoDB</code>表的每行数据都保存在主索引的叶子节点上。因此，所有的<code>InnoDB</code>表都必须包含主键，若创建表的时候没有显示指定主键，那么<code>InnoDB</code>会自动创建一个长度为6个字节的<code>long</code>类型隐藏字段作为主键。</p>
<p>考虑到聚簇索引的特点和对于查询的优化效果，所有的<code>InnoDB</code>表都应该显示指定主键，一般来说，主键应该按照以下原则来选择：</p>
<ul>
<li>满足唯一和非空约束</li>
<li>优先考虑使用最经常被当作查询条件的字段或者自增字段</li>
<li>字段值基本不会被修改</li>
<li>使用尽可能短的字段</li>
</ul>
<p>在<code>InnoDB</code>表上，除了主键之外的其他索引都叫<code>二级索引</code>或<code>辅助索引</code>，二级索引会指向主索引，并通过主索引获取最终数据。因此，主键是否合理的创建，会对所有索引的效率产生影响。</p>
<h4 id="如何选择存储引擎"><a href="#如何选择存储引擎" class="headerlink" title="如何选择存储引擎"></a>如何选择存储引擎</h4><p><code>MyISAM</code>：如果应用是以读操作和插入操作为主，只有极少的更新和删除操作，并且对事务完整性没有要求、没有并发写操作，那么选择这个存储引擎是合适的。</p>
<p><code>InnoDB</code>: 对于大部分应用程序，都是更好的选择。它能有效地降低由于删除和更新导致的锁定，还可以保证事务完整提交和回滚。</p>
<blockquote>
<p><code>MyISAM</code>读和插入更优的原因：</p>
<p><a href="https://blog.csdn.net/weixin_39631572/article/details/110861044">https://blog.csdn.net/weixin_39631572/article/details/110861044</a></p>
<p><a href="https://www.xttblog.com/?p=3859">https://www.xttblog.com/?p=3859</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL如何选择合适的数据类型和索引</title>
    <url>/2022/03/06/MySQL%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h2><h4 id="时间类型选择"><a href="#时间类型选择" class="headerlink" title="时间类型选择"></a>时间类型选择</h4><table>
<thead>
<tr>
<th align="center">日期和时间类型</th>
<th align="center">字节</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATE</td>
<td align="center">4</td>
<td align="center">1000-01-01</td>
<td align="center">9999-12-31</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="center">8</td>
<td align="center">1000-01-01 00:00:00</td>
<td align="center">9999-12-31 23:59:59</td>
</tr>
<tr>
<td align="center">TIMESTAMP</td>
<td align="center">4</td>
<td align="center">19700101080001</td>
<td align="center">2038年某个时刻</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">3</td>
<td align="center">-838：59：59</td>
<td align="center">838：59：59</td>
</tr>
<tr>
<td align="center">YEAR</td>
<td align="center">1</td>
<td align="center">1901</td>
<td align="center">2155</td>
</tr>
</tbody></table>
<p>其中，<code>TimeStamp</code>有一个重要的特点，就是和时区相关。当插入日期时，会先转换为本地时区后存储，后续需要取出时，也需要根据所在地时区进行转换显示。这样，不同时区的用户看到的同一个日期可能是不一样的。</p>
<h4 id="CHAR和VARCHAR"><a href="#CHAR和VARCHAR" class="headerlink" title="CHAR和VARCHAR"></a><code>CHAR</code>和<code>VARCHAR</code></h4><table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">CHAR(4)</th>
<th align="center">存储需求</th>
<th align="center">VARCHAR(4)</th>
<th align="center">存储需求</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“</td>
<td align="center">‘  ‘</td>
<td align="center">4个字节</td>
<td align="center">“</td>
<td align="center">1个字节</td>
</tr>
<tr>
<td align="center">‘ab’</td>
<td align="center">‘ab ‘</td>
<td align="center">4个字节</td>
<td align="center">‘ab ‘</td>
<td align="center">3个字节</td>
</tr>
<tr>
<td align="center">‘abcd’</td>
<td align="center">‘abcd’</td>
<td align="center">4个字节</td>
<td align="center">‘abcd’</td>
<td align="center">5个字节</td>
</tr>
<tr>
<td align="center">‘abcdefgh’</td>
<td align="center">‘abcd’</td>
<td align="center">4个字节</td>
<td align="center">‘abcd’</td>
<td align="center">5个字节</td>
</tr>
</tbody></table>
<blockquote>
<p>注：上图中最后一行只适用于<code>MySQL</code>的非严格模式，如果在严格模式，超过列长度的值将不会保存并出现错误提示。</p>
</blockquote>
<p><code>VARCHAR(4)</code>列显示的存储需求比实际字符长度多1，因为<code>VACHAR</code>要用1~2个字节要记录字节长度，低于255字节时使用一个，高于使用两个。（一个字节存储8位无符号数,储存的数值范围为0-255）</p>
<p>而不同的存储引擎对于两者的使用原则也有所不同：（个人认为造成使用原则不同的原因主要是两个存储方式不同，两种存储引擎都是基于<code>B+树</code>数据结构存储表数据的，但是区别在于<code>InnoDB</code>存储引擎中的<code>B+树</code>即存储了索引又存储了所有数据，而<code>MyISAM</code>中的<code>B+树</code>中只存储了数据的索引的Key值得地址，实际的数据存储在其他地方）</p>
<p><code>MyISAM</code>存储引擎：建议使用固定长度的数据列代替代替可变长度的数据列。</p>
<p><code>InnoDB</code>存储引擎：建议使用<code>VARCHAR</code>类型。对于<code>InnoDB</code>表，内部的行存储格式并没有区分固定长度和可变长度列（所有的数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的<code>CHAR</code>列不一定比使用可变长度的<code>VARCHAR</code>性能要好。因此，主要的性能因素都在行存储的数据量大小。由于<code>VARCHAR</code>的平均占用空间小于<code>CHAR</code>，因此使用<code>VARCHAR</code>来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。</p>
<h4 id="TEXT和BLOB"><a href="#TEXT和BLOB" class="headerlink" title="TEXT和BLOB"></a><code>TEXT</code>和<code>BLOB</code></h4><p><code>BLOB</code>主要用于保存一些二进制数据，比如照片；而<code>TEXT</code>只能保存字符数据。</p>
<p>但是这两种数据类型会引发一些性能问题，特别是执行过大量的删除操作后，会在数据表留下很大的数据“空洞”，以后填入这些空洞的记录在插入的性能上会有影响。可以通过执行<code>OPTIMIZE TABLE</code>对这类表进行碎片整理。</p>
<p>一般来说，不建议使用这两种数据类型，如果确实需要使用，建议将这两种数据类型分在不同的表中。这样会减少主表存储碎片，显著减少主表的数据量从而获得性能优势。</p>
<blockquote>
<p>优先使用<code>VARCHAR</code>类型，<code>VARCHAR</code>最长可以支持65533字节的长度，可以满足绝大多数需求。</p>
</blockquote>
<h4 id="浮点数和定点数"><a href="#浮点数和定点数" class="headerlink" title="浮点数和定点数"></a>浮点数和定点数</h4><p>当一个数据被定义为浮点数时，如果插入的数据精度超过该列定义的实际精度，则插入值会被四舍五入到实际精度。</p>
<p><strong>定点数实际上是以字符串形式存储的。</strong>所以定点数可以更精确地保存数据,因此在一些对数据精度要求比较高的场合（比如货币），一般使用定点数。</p>
<h2 id="索引设计和使用"><a href="#索引设计和使用" class="headerlink" title="索引设计和使用"></a>索引设计和使用</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>正确使用索引，是提高select操作性能的最佳途径。每种存储引擎对每个表至少支持16个索引，总索引的长度至少为256字节。</p>
<h3 id="索引在不同引擎中如何存储"><a href="#索引在不同引擎中如何存储" class="headerlink" title="索引在不同引擎中如何存储"></a>索引在不同引擎中如何存储</h3><p><code>InnoDB</code> 的表是根据主键进行展开的 B+tree 的聚集索引。<code>MyISAM </code>则为非聚集型索引，**<code>MyISAM</code> 存储会有两个文件，一个是索引文件，另外一个是数据文件，**其中索引文件中的索引指向数据文件中的表数据。</p>
<p>聚集型索引并不是一种单独的索引类型，而是一种存储方式，<code>InnoDB </code>聚集型索引实际上是在同一结构中保存了 B+tree 索引和数据行。当有聚簇索引时，<strong>它的索引实际放在叶子页中。</strong></p>
<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p>最适合索引的列是出现在<code>where</code>子句中的列，或连接子句中指定的列，而不是出现在select关键字后的选择列表中的列。</p>
<p>索引列的基数越大，索引的效果越好。比如出生日期具有不同值，很容易区分各行；而对于性别就两种值，不管搜索哪个值，都会得到一半的结果。</p>
<p>使用短索引。假如有一个CHAR(200)，如果前10或20个字符内，多数值都是唯一的，那么索引就只对前面具有唯一值的使用，能够节省大量索引空间。</p>
<p>利用最左前缀。见下一小节。</p>
<p>对于<code>InnoDB</code>的引擎，尽量手工指定主键。记录默认会按照一定的顺序保存，若有明确定义的主键，则按照主键顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个顺序去保存。按照主键或内部列进行访问是最快的，所以<code>InnoDB</code>表尽量指定主键。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>在<code>MySQL</code>建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<p>要想理解联合索引的最左匹配原则，先来理解下索引的底层原理。索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p>
<p>举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子：</p>
<p><img src="https://img2020.cnblogs.com/blog/1804577/202005/1804577-20200521182659976-48843100.png" alt="https://img2020.cnblogs.com/blog/1804577/202005/1804577-20200521182659976-48843100.png"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为<code>MySQL</code>创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引。</p>
<h3 id="不可见索引"><a href="#不可见索引" class="headerlink" title="不可见索引"></a>不可见索引</h3><p><code>MySQL8.0</code>提供的不可见索引，是为了减小对于表上的索引进行调整时可能会带来的潜在风险。当删除一个你认为不再需要的索引时，一旦系统中还存在个别使用该索引的<code>SQL</code>，那么这些<code>SQL</code>的执行可能会转为全表扫描，严重的话可能直接击垮数据库。并且重建索引需要的时间和消耗的系统资源也会很大。</p>
<p>有了不可见索引，当需要删除一个表的冗余索引时，可能先将其设为不可见，一旦发现有负面影响，还可以快速恢复。</p>
<blockquote>
<p>参考引用：</p>
<p>[1] 最左匹配原则：<a href="https://www.cnblogs.com/ljl150/p/12934071.html">https://www.cnblogs.com/ljl150/p/12934071.html</a></p>
<p>[2] 深入浅出MySQL：数据库开发、管理和维护（第三版）</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于NotSingle项目的一些思考</title>
    <url>/2021/12/26/%E5%85%B3%E4%BA%8ENotSingle%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="消息队列的选择"><a href="#消息队列的选择" class="headerlink" title="消息队列的选择"></a>消息队列的选择</h2><p>如今用的相对较多的消息队列有ActiveMQ、RabbitMQ、RocketMQ和Kafka这几种，因此该项目消息队列的选择也将从这几种来挑选。</p>
<p><img src="/2021/12/26/%E5%85%B3%E4%BA%8ENotSingle%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/image-20211226110632594.png" alt="image-20211226110632594"></p>
<p>对于ActiveMQ，由于其生态并不是很好，没经过大规模吞吐量场景的验证，社区也不是很活跃，因此<strong>不考虑采用</strong>；</p>
<p>对于RocketMQ，由于目前该产品主要针对的是在校学生，万人左右，虽然是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq">Apache</a>，但 GitHub 上的活跃度其实不算高），基础架构研发实力较强，用 RocketMQ 是很好的选择。但是目前而言，我并没有足够的技术去研究并应用他的底层，而且目前来看也并不需要这么大的吞吐量支持，<strong>不考虑采用</strong>；</p>
<p>对于KafKa，在大数据领域的实时计算、日志采集等场景使用较多，社区活跃，但是本系统并不涉及这些场景，目前来看也不需要这么大的吞吐量，<strong>不考虑采用</strong>；</p>
<p>对于RabbitMQ，是一款开源产品，拥有比较稳定的支持，活跃度也高，最主要是之前略有涉及，因此我<strong>选择RabbitMQ</strong>作为该项目消息队列。</p>
<blockquote>
<p><strong>本系统中，暂时不使用消息队列</strong>。后期考虑应用在动态发布方面</p>
</blockquote>
<h2 id="分布式还是单机"><a href="#分布式还是单机" class="headerlink" title="分布式还是单机"></a>分布式还是单机</h2><p>对于使用分布式还是单机系统，其实我也考虑了很久。</p>
<p><strong>单机系统</strong>的优点自然不必多少，简单快速开发，而且之前也一直是采用单机系统研发，因此可以快速开始项目的编写。</p>
<p>在考虑是否采用分布式微服务架构前，当然需要先了解为什么要采用微服务以及传统的单机系统的弊端了。</p>
<h4 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h4><p>在以往传统的企业系统架构中,我们针对一个复杂的业务需求通常使用对象或业务类型来构建一个单体项目。在项目中我们通常将需求分为三个主要部分:数据库、服务端处理、前端展现。</p>
<p>在业务发展初期,由于所有的业务逻辑在一个应用中,开发、测试、部署都还比较容易且方便。</p>
<p>但是,随着企业的发展,系统为了应对不同的业务需求会不断为该单体项目增加不同的业务模块;同时随着移动端设备的进步,前端展现模块已经不仅仅局限于Web的形式,这对于系统后端向前端的支持需要更多的接口模块。</p>
<p>单体应用由于面对的业务需求更为宽泛,不断扩大的需求会使得单体应用变得越来越臃肿。</p>
<p>单体应用的问题就逐渐凸显出来,由于单体系统部署在一个进程内,往往我们修改了一个很小的功能,为了部署上线会影响其他功能的运行。</p>
<p>并且,单体应用中的这些功能模块的使用场景、并发量、消耗的资源类型都各有不同,对于资源的利用又互相影响,这样使得我们对各个业务模块的系统容量很难给出较为准确的评估。</p>
<p>所以,单体系统在初期虽然可以非常方便地进行开发和使用,但是随着系统的发展,维护成本会变得越来越大,且难以控制。为了解决单体系统变得庞大臃肿之后产生的难以维护的问题,微服务架构诞生了并被大家所关注。</p>
<p>我们将系统中的不同功能模块拆分成多个不同的服务,这些服务都能够独立部署和扩展。由于每个服务都运行在自己的进程内,在部署上有稳固的边界,这样每个服务的更新都不会影响其他服务的运行。</p>
<p>同时,由于是独立部署的,我们可以更准确地为每个服务评估性能容量,通过配合服务间的协作流程也可以更容易地发现系统的瓶颈位置,以及给出较为准确的系统级性能容量评估。</p>
<blockquote>
<p><strong>但是，由于目前项目并不算太大，因此我将准备先做一版单机的，再在后期学习微服务架构，优化做一版微服务的。</strong></p>
</blockquote>
<blockquote>
<p>总体来说，目前我对该项目的思路如下：</p>
<ol>
<li>先构建用户端前端界面</li>
<li>采用单机系统构建后台，通信使用WebSocket，再搭配一些Redis场景，并逐步优化单机系统</li>
<li>构建管理后台前端界面，完善后端。初步做出一个可用的系统</li>
<li>采用分布式微服务框架构建后端，加入消息队列、netty等相关技术</li>
</ol>
<p>当然，在开发的过程中也可能适时调整，并不一定完全按照这个过程走。</p>
</blockquote>
<p><strong>参考引用：</strong></p>
<p>【1】 《Spring Cloud 微服务实战》翟永超</p>
<p>【2】 <a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/why-mq.md">https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/why-mq.md</a></p>
]]></content>
      <categories>
        <category>NotSingle</category>
      </categories>
      <tags>
        <tag>NotSingle</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇Blog</title>
    <url>/2021/12/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Blog/</url>
    <content><![CDATA[<p>刚刚从剧社排练完已经22：10了，由于今天下午刚刚把博客搭起来，还是回实验室写下了自己的第一篇博客。</p>
<p>写写删删，也不知道从哪开始写起了。说起来最近还是挺忙的，准确说应该是自己给自己制造的忙碌吧。</p>
<p>简单来说，搭建这篇博客的目的，简单来说，就是希望记录自己的学习过程吧。</p>
<p>其实在之前也经常在CSDN写过一些博客了，好吧，最近一年基本没写了，原因也是多种多样的。但是最近看了一些书还是深深感受到拥有一个个人博客并且坚持写下去的重要性，<strong>所以也在这里立下一个小小的flag，每周至少坚持总结输出一篇blog！</strong></p>
<p>之前在CSDN写的文章可能和这个网站本身上面很多的文章一样，东抄一点，西抄一点，质量堪忧，并且并没有很大的价值。</p>
<p>现在回头来看，从前自己在上面写博客，是为了写而写，并不是真正遇到问题，并且做过详细的了解，而自发的想去总结并且记录它。</p>
<p>可能有人也会想，我立下的flag不也是一周输出一篇，同样是为了写去写啊。但是我觉得，在研究生期间自己还是有许多时间去学习很多东西，在这个过程中，必然会遇到许许多多的问题，所以一周至少一篇记录总结还是非常合理的！</p>
<p>在我写博客的过程中，也许会存在许多问题，比如写的不够清楚，或者是我本身技术方面存在不足而导致讲错的地方，这些都是很正常的，我也会坦然接受，毕竟，我现在真的很菜。<strong>但是，也希望你能友善探讨。</strong></p>
<p>总而言之，尽管我写作的过程中会存在许多不足，我还是会坚持把能做到最好的样子呈现在大家面前。</p>
<p><strong>“如果我认为我写的博客不比目前我能发现的大多数文章要好，那我就没有必要去写它！”</strong></p>
<p>这会成为我写作的原则。至于为什么不说是能像很多作者口中的 “比其他所有文章要好”，那是因为我深知自己的水平远远达不到，也正是因为这样，我才决定开始搭建自己的私人博客了，否则，我就直接去出书啦！</p>
<p><strong>希望我的博客，能对你有所帮助！</strong></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>数据库锁的基本原理</title>
    <url>/2022/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="数据库系统的锁的基本原理"><a href="#数据库系统的锁的基本原理" class="headerlink" title="数据库系统的锁的基本原理"></a>数据库系统的锁的基本原理</h3><p>锁的基本原理如下：</p>
<ol>
<li>当一个事务访问某种数据库资源时，如果执行select语句，必须先获得的共享锁；如果执行insert，update或delete语句，必须获得独占锁。这些锁用于锁定被操纵的资源。</li>
<li>当第二个事务也要访问某种相同资源时，如果执行select语句，也必须获得的共享锁；如果执行insert，update或delete语句，必须获得独占锁。此时根据已经放置在资源上的锁的类型，来决定第二个事务到底是应该等待第一个事务解除对资源的锁定，还是可以立刻获得锁。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">资源上已经放置的锁</th>
<th align="center">第二个事务进行读操作</th>
<th align="center">第二个事务进行更新操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无</td>
<td align="center">立即获得共享锁</td>
<td align="center">立即获得独占锁</td>
</tr>
<tr>
<td align="center">共享锁</td>
<td align="center">立即获得共享锁</td>
<td align="center">等待第一个事务解除共享锁</td>
</tr>
<tr>
<td align="center">独占锁</td>
<td align="center">等待第一个事务接触独占锁</td>
<td align="center">等待第一个事务解除独占锁</td>
</tr>
</tbody></table>
<p>许多数据库系统都有自动管理锁的功能，它们能根据事务执行的SQL语句,自动在保证事务间的隔离性与保证事务间的并发性能之间做出权衡，然后自动为数据库资源加上当的锁在运行期间还会自动升级锁的类型,以优化系统的性能。多个事务的并发性能是指数据库系统能够同时执行多个事务的能力，很少出现因为一个事务占用了特定资源，而导到其他事务必须暂停下来长时间等待资源的情况。</p>
<p>对于普通的并发性事务,通过数据库系统的自动锁定管理机制基本可以保证事务之间</p>
<h4 id="锁的多粒度性及自动锁升级"><a href="#锁的多粒度性及自动锁升级" class="headerlink" title="锁的多粒度性及自动锁升级"></a>锁的多粒度性及自动锁升级</h4><p>数据库系统能够锁定的资源包括数据库、表、区域、页面、键值(指带有索引的行数据)和行(即表中的单行数据)。按照锁定资源的粒度,锁可以分为以下类型。</p>
<ol>
<li>数据库级锁:锁定整个数据库。</li>
<li>表级锁:锁定一张数据库表。</li>
<li>区域级锁:锁定数据库的特定区域。</li>
<li>页面级锁:锁定数据库的特定页面。</li>
<li>键值级锁:锁定数据库表中带有索引的一行数据。</li>
<li>行级锁:锁定数据库表中的单行数据(即一条记录)。</li>
</ol>
<p>锁的封锁粒度越大,事务间的隔离性就越高，但是事务间的并发性能就越低。数据库系统根据事务执行的SQL语句，自动对访问的数据资源加上合适的锁。假设某事务只操纵一个表中的部分行数据,系统可能只会添加几个行锁或页面锁，这样可以尽可能多地支持多个事务的并发操作。</p>
<p>但是,如果某个事务频繁地对某个表中的多条记录进行操作，将对该表的许多记录行都加上行级锁,数据库系统中锁的数目会急剧增加，这就加重了系统负荷，影响系统性能。因此,在数据库系统中,一般都支持锁升级。锁升级是指调整锁的粒度，将多个低粒度的锁替换成少数更高粒度的锁,以此来降低系统负荷。例如,当一个事务中的锁较多,达到锁升级门限时,系统自动将行级锁和页面级锁升级为表级锁。</p>
<h4 id="锁的类型和兼容性"><a href="#锁的类型和兼容性" class="headerlink" title="锁的类型和兼容性"></a>锁的类型和兼容性</h4><h5 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a><strong>共享锁</strong></h5><p>共享锁用于读数据操作，它是非独占的，允许其他事务同时读取其锁定的资源，但不允许其他事务更新它。共享锁具有以下特征：</p>
<ul>
<li>加锁的条件：当一个事务执行select语句时，数据库系统会为这个事务分配一把共享锁，来锁定被查询的数据。</li>
<li>解锁的条件：在默认情况下，数据被读取后，数据库系统会立即接触共享锁。例如，当一个事务执行查询语句（select * from account）时，数据库系统会先锁定第一行，读取之后，解除对第一行的锁定，然后锁定第二行。这样，在一个事务读操作过程中，允许其他食物同时更新account表中未被锁定的行。</li>
<li>与其他锁的兼容性：如果数据资源上放置了共享锁，还能再放置共享锁和更新锁。</li>
<li>并发性能：共享锁具有良好的并发性能。当多个事务读相同的数据时，每个事务都会获得一把共享锁，因此可以同时读锁定的数据。</li>
</ul>
<h5 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a><strong>独占锁</strong></h5><p>也称为排他锁，适用于修改数据的场合。它锁定的资源，其他事务不能读取和修改。独占锁具有以下特征：</p>
<ul>
<li>加锁的条件：当一个事务执行insert，update或delete语句时，数据库系统会自动对SQL语句操纵的数据资源使用独占锁。如果该数据资源已经有其他锁存在时，无法对其再放置独占锁。</li>
<li>解锁的条件：独占锁一直到事务结束才能被解除。</li>
<li>兼容性：独占锁不能和其他锁兼容，如果数据资源上已经加了独占锁，就不能再放置其他锁。同样，如果数据资源上已经有了其他锁，也不能再放置独占锁。</li>
<li>并发性能：独占锁的并发性能比较差，只允许有一个事务访问锁定的数据，如果有其他事物也需要访问该数据，就必须等待，直到前一个事务结束，解除了独占锁，其他事务才有机会访问该数据。</li>
</ul>
<h5 id="更新锁"><a href="#更新锁" class="headerlink" title="更新锁"></a><strong>更新锁</strong></h5><p>在更新操作的初始化阶段用来锁定可能要被修改的资源，这可以避免使用共享锁造成的死锁现象。例如对于以下的语句：</p>
<p>update account set balance = 90 where id = 1;</p>
<p>如果使用共享锁，更新操作分为两步：</p>
<ol>
<li>获得一个共享锁，读取 <code>account</code> 表中id为1的记录；</li>
<li>将共享锁升级为独占锁，再执行更新操作。</li>
</ol>
<p><strong>如果同时有两个或多个事务同时更新数据，每个事务都先获得一把共享锁,在更新数据的时候，这些事务都要先将共享锁升级为独占锁。由于独占锁不能与其他锁兼容,因此每事务都进入等待状态,等待其他事务释放共享锁,这就造成了死锁。</strong></p>
<p>如果使用更新锁,更新数据的操作分为以下两步：</p>
<ol>
<li>获得一个更新锁,读取 ACCOUNTS表中ID为1的记录。</li>
<li>将更新锁升级为独占锁,再执行更新操作。</li>
</ol>
<p>更新锁具有以下特征：</p>
<ul>
<li>加锁的条件：当一个事务执行update语句时，数据库系统会先为事务分配一把新锁。</li>
<li>解锁的条件：当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁，</li>
<li><strong>与其他锁的兼容性：更新锁与共享锁是兼容的，也就是说，一个资源可以同时放更新锁和共享锁，但是最多只能放置一把更新锁。这样，当多个事务更新相同的数据时有一个事务能获得更新锁，然后再把更新锁升级为独占锁,其他事务必须等到前一个事务结束后,才能获得更新锁,这就避免了死锁。</strong></li>
<li>并发性能：允许多个事务同时读锁定的资源,但不允许其他事务修改它。</li>
</ul>
<h4 id="死锁及其防治办法"><a href="#死锁及其防治办法" class="headerlink" title="死锁及其防治办法"></a>死锁及其防治办法</h4><p>多数据库系统能够自动定期搜索和处理死锁问题。当检测到锁定请求环时,系统将结束死锁优先级最低的事务,并且撤销该事务。</p>
<p>理解了死锁的概念,在应用程序中可以采用下面的一些方法来尽量避免死锁。</p>
<ol>
<li>合理安排对数据库表的访问顺序。</li>
<li>使用短事务。</li>
<li>如果对数据的一致性要求不是很高，可以允许脏读。脏读不需要对数据资源加锁，可以避免锁冲突。</li>
<li>如果可能的话,错开多个事务访问相同数据资源的时间,以防止锁冲突。</li>
<li>使用尽可能低的事务隔离级别。隔离级别过高，虽然系统可以因此提供更好的隔离性而更大程度上保证数据的完整性和一致性，但各事务间死锁的机会大大增加,反而影响了系统性能。</li>
</ol>
<p>短事务是指在一个数据库事务中包含尽可能少的操作，并且在尽可能短的时间内完成事务不仅能避免死锁，而且能提高事务间的并发性能。因为如果一个事务锁定了某种资源,由于这个事务很快就结束,因此不会长时间锁定资源,其他事务也就不需要长时间等待前一个事务解除对资源的锁定。</p>
<p>为了实现短事务,在应用程序中可以考虑使用以下策略。</p>
<ol>
<li>如果可能的话,尝试把大的事务分解为多个小的事务,然后分别执行。这可以保证每个小事务都很快完成,不会对数据资源锁定很长时间。</li>
<li>应该在处理事务前就准备好用户必须提供的数据,不应该在执行事务过程中,停下来长时间等待用户输入。以取款事务为例,应该在开始取款事务之前,就明确客户的取款数额,这使得取款事务不用中途停下来等待用户输入。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解ORM思想</title>
    <url>/2022/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ORM%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h3 id="ORM简介"><a href="#ORM简介" class="headerlink" title="ORM简介"></a>ORM简介</h3><p><code>ORM</code>即对象-关系映射（Object Relational Mapping），指的是在单个组件中负责所有实体域对象的持久化，封装数据库访问细节。它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的<code>SQL</code>语句打交道，只要像平时操作对象一样操作它就可以了 。</p>
<p><strong>在探究什么是<code>ORM</code>之前，首先需要搞清楚几个概念：持久化和持久层。</strong></p>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、<code>XML</code>中等等。</p>
<p><code>Hibernate ORM</code>关心的是帮助应用程序实现持久性。持久性仅仅意味着我们希望应用程序的数据比应用程序进程的寿命更长。用<code>Java</code>术语来说，我们希望(一些)对象的状态超出<code>JVM</code>所能管控的范围，以便稍后可以使用相同的状态。</p>
<h4 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h4><p>即专注于实现数据持久化应用领域的某个特定系统的一个<strong>逻辑层面</strong>，将数据使用者和数据实体相关联。</p>
<h3 id="ORM是一种思想"><a href="#ORM是一种思想" class="headerlink" title="ORM是一种思想"></a>ORM是一种思想</h3><p>在了解完以上几个概念后，我们有必要深入了解一下到底什么才是<code>ORM</code>。正如标题所说，<code>ORM</code>我认为其实是一种面向对象编程演变过程中，形成的一种编程思想。</p>
<h4 id="究竟什么是面向对象"><a href="#究竟什么是面向对象" class="headerlink" title="究竟什么是面向对象"></a>究竟什么是面向对象</h4><p>一个优秀的软件架构，是要基于面向对象设计的深入理解与运用的，那么，究竟什么才是面向对象呢？很多人碰到这个问题，通常会甩出三个词——继承、封装、多态，我碰到许多人都会这么回答，当然这没有错，但总让我感觉这个回答有点生疏。另一种常见的回答则是“面向对象是一种对真实世界进行建模的方式”，似乎好像比上一种更容易理解一点，但是也只能算是避重就轻，“对真实世界的建模”到底要如何进行？我们为什么要这么做？这么做有什么好处？许多人问到这便会陷入困境，不知如何回答。</p>
<p>好吧，那让我们先详细了解一下生疏而又神秘的三个特性——继承、封装、多态。这十分有利于我们去理解<code>ORM</code>思想。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>所谓继承，是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
<p>面向对象的三大特性，其中一个非常重要的用处就是使得程序可复用性极高，它使得我们的软件体系架构得到解耦。其实这些思想和操作系统也有着很大的关联，比如在<code>UNIX</code>操作系统中，IO设备是被设计成插件形式的，简单说就是：程序和设备无关。而这又可以引申出另一种编程模式：依赖反转。</p>
<h4 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h4><p>设想一下，假如有一个main函数，控制着A、B、C三个函数，而A、B、C分别控制着A1、A2、A3，B1、B2、B3，C1、C2、C3函数。这样，main函数要调用其他模块，就必须看到其他模块所在的模块，每个函数的调用方就必须引用被调用方所在的模块，<strong>这样就导致系统行为决定控制流，而控制流决定着源代码的依赖关系。</strong></p>
<p>再设想一下，有一个main函数、一个A接口、一个A接口的实现类，函数的调用是通过源代码级别的接口来实现的，此时的依赖关系方向和控制流是相反的，我们在称之为<code>依赖反转</code> 。</p>
<p>通过这种方法，软件工程师可以完全控制采用了面向对象编程方式中的所有源代码依赖关系，而不再收到系统控制流的限制。不管哪个模块调用或者被调用，软件工程师都可以随意更改源代码依赖关系。</p>
<h4 id="回到问题"><a href="#回到问题" class="headerlink" title="回到问题"></a>回到问题</h4><p><strong>那么我们回到最开始的问题，究竟什么才是面向对象编程呢？其实在笔者看过的许多经典作品中，很多人对此都有不同的说法和意见，但是对于软件工程师而言：面向对象编程就是以多态的手段对源代码中的依赖关系加以控制和约束，让高层代码对低层代码达到解耦的目的，实现相对独立的编程开发工作，这也是目前主流的软件体系架构思想。</strong></p>
<p>了解以上内容后，我们回到主题：什么是<code>ORM</code>思想？它和面向对象有什么关系？为什么需要<code>ORM</code>？</p>
<p>在目前的企业应用系统设计中，<code>MVC</code>，即 Model（模型）- View（视图）- Control（控制）为主要的系统架构模式。<code>MVC</code> 中的 Model 包含了复杂的业务逻辑和数据逻辑，以及数据存取机制（如<code> JDBC</code>的连接、<code>SQL</code>生成和<code>Statement</code>创建、还有<code>ResultSet</code>结果集的读取等）等。</p>
<p>将这些复杂的业务逻辑和数据逻辑分离，以将系统的紧耦 合关系转化为松耦合关系（即解耦合），是降低系统耦合度迫切要做的，也是持久化要做的工作。</p>
<p><code>MVC</code> 模式实现了架构上将表现层（即View）和数据处理层（即Model）分离的解耦合，而持久化的设计则实现了数据处理层内部的业务逻辑和数据逻辑分离的解耦合。 而 <code>ORM </code>作为持久化设计中的最重要也最复杂的技术，也是目前业界热点技术。</p>
<p>简单来说，按通常的系统设计，使用<code> JDBC</code> 操作数据库，业务处理逻辑和数据存取逻辑是混杂在一起的。<br>一般基本都是如下几个步骤：<br>1、建立数据库连接，获得<code>Connection</code>对象。<br>2、根据用户的输入组装查询<code> SQL</code> 语句。<br>3、根据<code> SQL</code> 语句建立<code> Statement</code> 对象 或者<code>PreparedStatement</code>对象。<br>4、用<code>Connection</code>对象执行<code> SQL</code>语句，获得结果集<code> ResultSet</code> 对象。<br>5、然后一条一条读取结果集 <code>ResultSet</code> 对象中的数据。<br>6、根据读取到的数据，按特定的业务逻辑进行计算。<br>7、根据计算得到的结果再组装更新<code> SQL</code> 语句。<br>8、再使用 <code>Connection</code> 对象执行更新 <code>SQL</code> 语句，以更新数据库中的数据。<br>9、最后依次关闭各个<code>Statement</code>对象和 <code>Connection</code> 对象。</p>
<p>由上可看出代码逻辑非常复杂，这还不包括某条语句执行失败的处理逻辑。其中的业务处理逻辑和数据存取逻辑完全混杂在一块。</p>
<p>而一个完整的系统要包含成 千上万个这样重复的而又混杂的处理过程，假如要对其中某些业务逻辑或者一些相关联的业务流程做修改，要改动的代码量将不可想象。</p>
<p>另一方面，假如要换数据库产品或者运行环境也可能是个不可能完成的任务。而用户的运行环境和要求却千差万别，我们不可能为每一个用户每一种运行环境设计一套一样的系统。</p>
<p>所以就要将一样的处理代码即业务逻辑和可能不一样的处理即数据存取逻辑分离开来，另一方面，关系型数据库中的数据基本都是以一行行的数据进行存取的，而程序 运行却是一个个对象进行处理，而目前大部分数据库驱动技术（如<code>ADO.NET</code>、<code>JDBC</code>、<code>ODBC</code>等等）均是以行集的结果集一条条进行处理的。</p>
<p>所以为解决这一困难，就出现<code> ORM</code> 这一个对象和数据之间映射技术。</p>
<p>举例来说，比如要完成一个购物打折促销的程序，用 <code>ORM</code> 思想将如下实现：</p>
<p>业务逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Double calcAmount(String customerid, double amount) &#123;</span><br><span class="line">  // 根据客户ID获得客户记录</span><br><span class="line">  Customer customer = CustomerManager.getCustomer(custmerid); </span><br><span class="line">  // 根据客户等级获得打折规则</span><br><span class="line">  Promotion promotion = PromotionManager.getPromotion(customer.getLevel()); </span><br><span class="line">  // 累积客户总消费额，并保存累计结果</span><br><span class="line">  customer.setSumAmount(customer.getSumAmount().add(amount); </span><br><span class="line">  CustomerManager.save(customer); </span><br><span class="line">  // 返回打折后的金额</span><br><span class="line">  return amount.multiply(protomtion.getRatio()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样代码就非常清晰了，而且与数据存取逻辑完全分离。设计业务逻辑代码的时候完全不需要考虑数据库<code>JDBC</code>的那些千篇一律的操作，而将它交给 <code>CustomerManager</code> 和 <code>PromotionManager</code> 两个类去完成。这就是一个简单的 <code>ORM</code> 设计，实际的 <code>ORM</code> 实现框架比这个要复杂的多。</p>
<h3 id="常用的ORM中间件"><a href="#常用的ORM中间件" class="headerlink" title="常用的ORM中间件"></a>常用的ORM中间件</h3><p>开发<code>ORM</code>中间件需要十分专业的知识，因此一般在企业应用开发过程中都使用第三方提供的<code>ORM</code>中间件。下面列出了一些常用的<code>ORM</code>软件可供参考使用：</p>
<table>
<thead>
<tr>
<th align="center">ORM软件</th>
<th align="center">URL</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hibernate</td>
<td align="center"><a href="http://www.hibernate.org/">http://www.hibernate.org/</a></td>
</tr>
<tr>
<td align="center">Mybatis</td>
<td align="center"><a href="http://www.mybatis.org/">http://www.mybatis.org/</a></td>
</tr>
<tr>
<td align="center">Torque</td>
<td align="center"><a href="http://db.apache.org/torque/">http://db.apache.org/torque/</a></td>
</tr>
<tr>
<td align="center">JRelationalFramework</td>
<td align="center"><a href="http://jrf.sourceforge.net/">http://jrf.sourceforge.net</a></td>
</tr>
</tbody></table>
<p>不管是哪类<code>ORM</code>产品，首先需要保证的就是不能渗透到应用中，应用的上层组件应该和<code>ORM</code>中间件保持独立。有些<code>ORM</code>中间件要求在实体域对象中引入它们的类和接口，这会影响实体域对象的可移植性，如果日后想改用其他的<code>ORM</code>中间件，必须改写实体域对象的程序代码。</p>
<p>另外,即使<code>ORM</code>中间件没有渗透到实体域对象中,应用程序中负责处理业务逻辑的过程域对象必须通过ORM中间件的API去访问数据库。</p>
<p>每个<code>ORM</code>软件都有各自的<code>API</code>，如果一个应用程序起初使用了<code> Hibernate</code>,日后如果要改为使用<code>MyBatis</code>,就必须重新编写访问 <code>ORM</code> 中间件的代码。为了削弱应用程序对特定<code>ORM</code>中间件的依赖性,<code>Oracle</code> 公司制定了统一的Java对象持久化 <code>API</code>(<code>Java Persistence API</code>,<code>JPA</code>)。<code>JPA</code>成为了各种<code> ORM</code>架的标准<code>API</code>。</p>
<p><code>JPA</code>充分吸收了现有的包括<code>Hibernate</code>在内的<code>ORM</code>软件的优点,具有易于使用和伸缩性强的优势。应用程序可通过<code>JPA</code>来对实体域对象进行持久化。</p>
]]></content>
      <categories>
        <category>SpringDataJPA</category>
      </categories>
  </entry>
  <entry>
    <title>精通JPA与Hibernate:对象持久化技术详解--摘录与理解</title>
    <url>/2022/02/22/%E7%B2%BE%E9%80%9AJPA%E4%B8%8EHibernate-%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3-%E6%91%98%E5%BD%95%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="1-包装类与基本类型的区别"><a href="#1-包装类与基本类型的区别" class="headerlink" title="1. 包装类与基本类型的区别"></a>1. 包装类与基本类型的区别</h3><p>一直以来对于这两者没有很清晰的认识，但是在本书中某一段给了我启示。</p>
<p>Java有8种基本类型，分别是byte, short, char, int, long, float, double 和 boolean。与此对应，Java提供了8种包装类型Byte, Short, Character, Integer, Long, Float, Double 和 Boolean。</p>
<p>基本类型的缺点在于无法表达null值。所有基本类型的默认值都不是null，如数字类型默认值是0。在一些场合是可以用基本类型的默认值来表示属性值是未知的。比如对于年龄，如果属性为0，可以表示是未知的，但是有些场合则不行。</p>
<p>比如对于成绩属性，有些成绩可能是未知的，这时候不能用0表示，因为0也是一个具有实际意义的分数，此时就需要用到包装类。</p>
<h3 id="2-数据库事务"><a href="#2-数据库事务" class="headerlink" title="2. 数据库事务"></a>2. 数据库事务</h3><p>之前一直对ACID特性有了解，可是看过之后总是容易忘，可能是没有真正理解。本书中我感觉解释的不错：</p>
<h5 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h5><p>指整个数据库事务是不可分割的工作单元。只有事务中所有的操作执行成功，才能算整个事务成功；事务中任何一个sql语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该回到执行事务前的状态。</p>
<h5 id="一致性："><a href="#一致性：" class="headerlink" title="一致性："></a>一致性：</h5><p>指数据库事务不能破坏关系数据的完整性以及业务逻辑的一致性。例如银行转账事务，不管事务成功还是失败，应该保证事务结束后表中数据一致。例如A和B在数据库种存款总额为2000，那么执行完成后，总额依然为2000.</p>
<h5 id="隔离性："><a href="#隔离性：" class="headerlink" title="隔离性："></a>隔离性：</h5><p>在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。</p>
<h5 id="持久性："><a href="#持久性：" class="headerlink" title="持久性："></a>持久性：</h5><p>指的是只要事务成功结束，它对数据库所做的更改必须永久保存下来，即使发生系统崩溃，重新启动数据库系统后，数据库仍能恢复到事务成功结束时的状态。</p>
<p>事务的ACID特性是由数据库系统来实现的。数据库系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新操作，如果某个事物在执行过程中发生错误，就可以根据日志撤销事务对数据库已做的更改操作。</p>
<p>数据库系统采用锁机制来实现事物的隔离性，当多个事务同时更新数据库中相同数据时，只允许持有锁的事务能够更新数据，其他事务必须等待，直到其释放锁。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>对象持久化技术</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读SpringBoot文档摘录</title>
    <url>/2022/01/23/%E9%98%85%E8%AF%BBSpringBoot%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>这篇博客是我在阅读 SpringBoot 英文文档过程中记录的对SpringBoot的新认知，或者说是之前比较模糊的概念。总而言之，算是我个人的随笔记录，方便以后查看，如果感觉对你帮助不大，可以跳过不看本篇博客。</p>
</blockquote>
<h3 id="1-Upgrading-to-a-new-feature-release"><a href="#1-Upgrading-to-a-new-feature-release" class="headerlink" title="1.  Upgrading to a new feature release"></a>1.  Upgrading to a new feature release</h3><p>When upgrading to a new feature release, some properties may have been renamed or removed. Spring Boot provides a way to analyze your application’s environment and print diagnostics at startup, but also temporarily migrate properties at runtime for you. To enable that feature, add the following dependency to your project:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-properties-migrator&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>这段代码其实我之前并没有去深究他的含义，这也是我之前学习过程中的一个弊端，很多东西并没有去深究，后面慢慢发现这是一个很不好的习惯。</p>
<p>这几行代码是因为在SpringBoot版本升级过程中，一些 properties 可能会被改名或者移除，但是如果有这行代码，他会自动分析你的应用环境并在启动时打印出分析结果，也可以运行时临时迁移属性。</p>
<blockquote>
<p>注意：一些较晚添加进环境的属性，比如 <code>@PropertySource</code> 这些，此配置不会对其生效。</p>
<p>另外，在完成迁移后，需要确认从项目依赖中移出这个依赖。</p>
</blockquote>
<h3 id="2-Using-the-“default”-Package"><a href="#2-Using-the-“default”-Package" class="headerlink" title="2. Using the “default” Package"></a>2. Using the “default” Package</h3><p>When a class does not include a <code>package</code> declaration, it is considered to be in the “default package”. The use of the “default package” is generally discouraged and should be avoided. It can cause particular problems for Spring Boot applications that use the <code>@ComponentScan</code>, <code>@ConfigurationPropertiesScan</code>, <code>@EntityScan</code>, or <code>@SpringBootApplication</code> annotations, since every class from every jar is read.</p>
<blockquote>
<p>We recommend that you follow Java’s recommended package naming conventions and use a reversed domain name (for example, <code>com.example.project</code>).</p>
</blockquote>
<h3 id="3-Locating-the-Main-Application-Class"><a href="#3-Locating-the-Main-Application-Class" class="headerlink" title="3. Locating the Main Application Class"></a>3. Locating the Main Application Class</h3><p>We generally recommend that you locate your main application class in a root package above other classes. The <a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#using.using-the-springbootapplication-annotation"><code>@SpringBootApplication</code> annotation</a> is often placed on your main class, and it implicitly defines a base “search package” for certain items. For example, if you are writing a JPA application, the package of the <code>@SpringBootApplication</code> annotated class is used to search for <code>@Entity</code> items. Using a root package also allows component scan to apply only on your project.</p>
<blockquote>
<p>If you do not want to use <code>@SpringBootApplication</code>, the <code>@EnableAutoConfiguration</code> and <code>@ComponentScan</code> annotations that it imports defines that behavior so you can also use those instead.</p>
</blockquote>
<p>简而言之，上面的意思就是推荐使用 <code>@SpringBootApplication</code> 注解，它可以提供搜索架包的功能。如果不使用的话，也可以使用<code>@EnableAutoConfiguration</code> 和<code>@ComponentScan</code> 注解来代替相同的行为。</p>
<h3 id="4-Auto-configuration"><a href="#4-Auto-configuration" class="headerlink" title="4. Auto-configuration"></a>4. Auto-configuration</h3><p>Spring Boot auto-configuration尝试根据添加的jar依赖项自动配置Spring应用程序。例如，如果<code>HSQLDB</code>在类路径上，并且您没有手动配置任何数据库连接bean，那么Spring Boot将自动配置内存中的数据库。</p>
<p>您需要通过在<code>@Configuration</code>类中添加<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>注释来选择自动配置。</p>
<blockquote>
<p>您应该只添加一个<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>注释。我们通常建议您只将其中一个添加到主<code>@Configuration</code>类中。</p>
</blockquote>
<h3 id="5-Automatic-Restart"><a href="#5-Automatic-Restart" class="headerlink" title="5. Automatic Restart"></a>5. Automatic Restart</h3><h4 id="5-1-Excluding-Resources"><a href="#5-1-Excluding-Resources" class="headerlink" title="5.1 Excluding Resources"></a>5.1 Excluding Resources</h4><p>某些资源在被更改时并不一定需要触发重新启动。例如，可以就地编辑<code>Thymeleaf</code>模板。默认情况下，在<code>/META-INF/maven</code>、<code>/META-INF/resources</code>、<code>/resources</code>、<code>/static</code>、<code>/public</code>或<code>/templates</code>中更改资源不会触发重启，但会触发实时重新加载。如果你想定制这些排除，你可以使用<code>spring.devtools.restart.exclude</code>属性。例如，要只排除<code>/static</code>和<code>/public</code>，你需要设置以下属性:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  devtools:</span><br><span class="line">    restart:</span><br><span class="line">      exclude: &quot;static/**,public/**&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你想保留这些默认值并添加额外的排除项，请改用<code>spring.devtools.restart.additional-exclude</code>属性。</p>
</blockquote>
<h4 id="5-2-Running-the-Remote-Client-Application"><a href="#5-2-Running-the-Remote-Client-Application" class="headerlink" title="5.2 Running the Remote Client Application"></a>5.2 Running the Remote Client Application</h4><p>远程客户端应用程序被设计为从IDE中运行。您需要使用与您连接的远程项目相同的类路径运行<code>org.springframework.boot.devtools.RemoteSpringApplication</code>。应用程序的唯一必需参数是它所连接到的远程URL。</p>
<p>例如，如果你正在使用<code>Eclipse</code>或<code>Spring Tools</code>，并且你有一个名为<code>my-app</code>的项目，你已经部署到<code>Cloud Foundry</code>，你会这样做:</p>
<ul>
<li>Select <code>Run Configurations…</code> from the <code>Run</code> menu.</li>
<li>Create a new <code>Java Application</code> “launch configuration”.</li>
<li>Browse for the <code>my-app</code> project.</li>
<li>Use <code>org.springframework.boot.devtools.RemoteSpringApplication</code> as the main class.</li>
<li>Add <code>https://myapp.cfapps.io</code> to the <code>Program arguments</code> (or whatever your remote URL is).</li>
</ul>
<h3 id="6-Application-Events-and-Listeners"><a href="#6-Application-Events-and-Listeners" class="headerlink" title="6. Application Events and Listeners"></a>6. Application Events and Listeners</h3><h4 id="6-1-应用程序事件发送顺序"><a href="#6-1-应用程序事件发送顺序" class="headerlink" title="6.1 应用程序事件发送顺序"></a>6.1 应用程序事件发送顺序</h4><p>当你的应用程序运行时，应用程序事件按以下顺序发送:</p>
<ol>
<li>An <code>ApplicationStartingEvent</code> is sent at the start of a run but before any processing, except for the registration of listeners and initializers.</li>
<li>An <code>ApplicationEnvironmentPreparedEvent</code> is sent when the <code>Environment</code> to be used in the context is known but before the context is created.</li>
<li>An <code>ApplicationContextInitializedEvent</code> is sent when the <code>ApplicationContext</code> is prepared and ApplicationContextInitializers have been called but before any bean definitions are loaded.</li>
<li>An <code>ApplicationPreparedEvent</code> is sent just before the refresh is started but after bean definitions have been loaded.</li>
<li>An <code>ApplicationStartedEvent</code> is sent after the context has been refreshed but before any application and command-line runners have been called.</li>
<li>An <code>AvailabilityChangeEvent</code> is sent right after with <code>LivenessState.CORRECT</code> to indicate that the application is considered as live.</li>
<li>An <code>ApplicationReadyEvent</code> is sent after any <a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.spring-application.command-line-runner">application and command-line runners</a> have been called.</li>
<li>An <code>AvailabilityChangeEvent</code> is sent right after with <code>ReadinessState.ACCEPTING_TRAFFIC</code> to indicate that the application is ready to service requests.</li>
<li>An <code>ApplicationFailedEvent</code> is sent if there is an exception on startup.</li>
</ol>
<p>上面的列表只包括与 <code>SpringApplication </code>绑定的<code> SpringApplicationEvents</code>。除此之外，以下事件也会在 <code>applicationprepareddevent </code>和 <code>applicationstarteddevent</code> 之后发布:</p>
<ul>
<li>A <code>WebServerInitializedEvent</code> is sent after the <code>WebServer</code> is ready. <code>ServletWebServerInitializedEvent</code> and <code>ReactiveWebServerInitializedEvent</code> are the servlet and reactive variants respectively.</li>
<li>A <code>ContextRefreshedEvent</code> is sent when an <code>ApplicationContext</code> is refreshed.</li>
</ul>
<h3 id="7-Web-Environment"><a href="#7-Web-Environment" class="headerlink" title="7. Web Environment"></a>7. Web Environment</h3><p>用来确定<code>WebApplicationType</code>的算法如下:</p>
<ul>
<li>如果存在<code>Spring MVC</code>，则会使用一个<code>AnnotationConfigServletWebServerApplicationContext</code></li>
<li>如果<code>Spring MVC</code>不存在而<code>Spring WebFlux</code>存在，那么会使用一个<code>AnnotationConfigReactiveWebServerApplicationContext</code></li>
<li>否则，使用<code>AnnotationConfigApplicationContext</code></li>
</ul>
<p>这意味着，如果你在同一个应用程序中使用<code>Spring MVC</code>和来自<code>Spring WebFlux</code>的新<code>WebClient</code>，那么默认情况下会使用<code>Spring MVC</code>。你可以通过调用<code>setWebApplicationType(WebApplicationType)</code>轻松覆盖它。也可以通过调用<code>setApplicationContextClass(…)</code>来完全控制<code>ApplicationContext</code>类型，具体可以参考源码去看。</p>
<h4 id="7-1-Application-Startup-tracking（可用于Debug学习）"><a href="#7-1-Application-Startup-tracking（可用于Debug学习）" class="headerlink" title="7.1 Application Startup tracking（可用于Debug学习）"></a>7.1 Application Startup tracking（可用于Debug学习）</h4><p>在应用程序启动期间，<code>SpringApplication</code>和<code>ApplicationContext</code>执行许多与应用程序生命周期、bean生命周期甚至处理应用程序事件相关的任务。使用<code>ApplicationStartup</code>, Spring框架允许你使用<code>StartupStep</code>对象跟踪应用程序的启动顺序。收集这些数据可以用于分析目的，或者只是为了更好地理解应用程序的启动过程。</p>
<p>在设置<code>SpringApplication</code>实例时，您可以选择一个<code>ApplicationStartup</code>实现。例如，要使用<code>BufferingApplicationStartup</code>，你可以这样写:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class MyApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication application = new SpringApplication(MyApplication.class);</span><br><span class="line">        application.setApplicationStartup(new BufferingApplicationStartup(2048));</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个可用的实现<code>FlightRecorderApplicationStartup</code>是由Spring Framework提供的。它将Spring特定的启动事件添加到<code>Java Flight Recorder</code>会话中，用于分析应用程序，并将它们的Spring上下文生命周期与<code>JVM</code>事件(如分配、gc、类加载……)关联起来。配置完成后，你可以通过启用<code>Flight Recorder</code>运行应用程序来记录数据:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ java -XX:StartFlightRecording:filename=recording.jfr,duration=10s -jar demo.jar</span><br></pre></td></tr></table></figure>

<p>Spring Boot自带<code>BufferingApplicationStartup</code>变量;这个实现是为了缓冲启动步骤，并将它们放入外部度量系统中。应用程序可以在任何组件中请求<code>BufferingApplicationStartup</code>类型的bean。</p>
<p>Spring Boot还可以配置为公开一个启动端点，该端点以<code>JSON</code>文档的形式提供该信息。</p>
<h4 id="7-2-外部化配置"><a href="#7-2-外部化配置" class="headerlink" title="7.2 外部化配置"></a>7.2 外部化配置</h4><p>Spring Boot使用了一个非常特殊的PropertySource顺序，其目的是允许合理地重写值。属性按以下顺序考虑(较低项的值覆盖前面项的值):</p>
<ol>
<li>Default properties (specified by setting <code>SpringApplication.setDefaultProperties</code>).</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a> annotations on your <code>@Configuration</code> classes. Please note that such property sources are not added to the <code>Environment</code> until the application context is being refreshed. This is too late to configure certain properties such as <code>logging.*</code> and <code>spring.main.*</code> which are read before refresh begins.</li>
<li>Config data (such as <code>application.properties</code> files).</li>
<li>A <code>RandomValuePropertySource</code> that has properties only in <code>random.*</code>.</li>
<li>OS environment variables.</li>
<li>Java System properties (<code>System.getProperties()</code>).</li>
<li>JNDI attributes from <code>java:comp/env</code>.</li>
<li><code>ServletContext</code> init parameters.</li>
<li><code>ServletConfig</code> init parameters.</li>
<li>Properties from <code>SPRING_APPLICATION_JSON</code> (inline JSON embedded in an environment variable or system property).</li>
<li>Command line arguments.</li>
<li><code>properties</code> attribute on your tests. Available on <a href="https://docs.spring.io/spring-boot/docs/2.6.3/api/org/springframework/boot/test/context/SpringBootTest.html"><code>@SpringBootTest</code></a> and the <a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.testing.spring-boot-applications.autoconfigured-tests">test annotations for testing a particular slice of your application</a>.</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/test/context/TestPropertySource.html"><code>@TestPropertySource</code></a> annotations on your tests.</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#using.devtools.globalsettings">Devtools global settings properties</a> in the <code>$HOME/.config/spring-boot</code> directory when devtools is active.</li>
</ol>
<p>配置数据文件的顺序如下:</p>
<ol>
<li><a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.external-config.files">Application properties</a> packaged inside your jar (<code>application.properties</code> and YAML variants).</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.external-config.files.profile-specific">Profile-specific application properties</a> packaged inside your jar (<code>application-&#123;profile&#125;.properties</code> and YAML variants).</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.external-config.files">Application properties</a> outside of your packaged jar (<code>application.properties</code> and YAML variants).</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.external-config.files.profile-specific">Profile-specific application properties</a> outside of your packaged jar (<code>application-&#123;profile&#125;.properties</code> and YAML variants).</li>
</ol>
<h4 id="7-3-Configuring-Random-Values"><a href="#7-3-Configuring-Random-Values" class="headerlink" title="7.3 Configuring Random Values"></a>7.3 Configuring Random Values</h4><p><code>RandomValuePropertySource</code>用于注入随机值(例如，注入秘密或测试用例)。它可以生成<code>integers</code>, <code>longs</code>, <code>uuids</code>, 或<code>string</code>，如下例所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my:</span><br><span class="line">  secret: &quot;$&#123;random.value&#125;&quot;</span><br><span class="line">  number: &quot;$&#123;random.int&#125;&quot;</span><br><span class="line">  bignumber: &quot;$&#123;random.long&#125;&quot;</span><br><span class="line">  uuid: &quot;$&#123;random.uuid&#125;&quot;</span><br><span class="line">  number-less-than-ten: &quot;$&#123;random.int(10)&#125;&quot;</span><br><span class="line">  number-in-range: &quot;$&#123;random.int[1024,65536]&#125;&quot;</span><br></pre></td></tr></table></figure>



<h4 id="7-4-Type-safe-Configuration-Properties"><a href="#7-4-Type-safe-Configuration-Properties" class="headerlink" title="7.4 Type-safe Configuration Properties"></a>7.4 Type-safe Configuration Properties</h4><h5 id="7-5-JavaBean-properties-binding"><a href="#7-5-JavaBean-properties-binding" class="headerlink" title="7.5  JavaBean properties binding"></a>7.5  JavaBean properties binding</h5><p>可以绑定声明标准javabean属性的bean，如以下示例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(&quot;my.service&quot;)</span><br><span class="line">public class MyProperties &#123;</span><br><span class="line"></span><br><span class="line">    private boolean enabled;</span><br><span class="line"></span><br><span class="line">    private InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    private final Security security = new Security();</span><br><span class="line"></span><br><span class="line">    // getters / setters...</span><br><span class="line"></span><br><span class="line">    public static class Security &#123;</span><br><span class="line"></span><br><span class="line">        private String username;</span><br><span class="line"></span><br><span class="line">        private String password;</span><br><span class="line"></span><br><span class="line">        private List&lt;String&gt; roles = new ArrayList&lt;&gt;(Collections.singleton(&quot;USER&quot;));</span><br><span class="line"></span><br><span class="line">        // getters / setters...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离模式下动态权限管理分析---以JeecgBoot为例</title>
    <url>/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>之前也写过关于前后端分离模式下动态权限管理相关的博客，但是由于之前对前后端知识了解尚且匮乏，因此在讲解时难免有讲的不够详细的地方，因此现在再以JeecgBoot项目（后面用 “本项目” 代替该词）中动态权限管理实现方式为例，重新详细讲解一遍。</p>
<blockquote>
<p>本例基于Vue2 + SpringBoot来讲解，对于我认为比较基础的知识不再赘述，只讲解实现的大致脉络，并且大部分讲解在代码注释部分，请仔细阅读。</p>
</blockquote>
<h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p>本项目最重要的方法位于<strong>src</strong>目录下的<strong>permission.js</strong>(注意与/store/modules下的区分)，精简代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line"> (...省略部分与该主题无关内容)</span><br><span class="line">      if (store.getters.permissionList.length === 0) &#123; // 判断vuex的store是否存储有权限列表，以此判断是否获取到（可能缓存了）</span><br><span class="line">        store.dispatch(&#x27;GetPermissionList&#x27;).then(res =&gt; &#123; </span><br><span class="line">              const menuData = res.result.menu;</span><br><span class="line">              if (menuData === null || menuData === &quot;&quot; || menuData === undefined) &#123;</span><br><span class="line">                return;</span><br><span class="line">              &#125;</span><br><span class="line">              let constRoutes = [];</span><br><span class="line">              constRoutes = generateIndexRouter(menuData); // 代码如下文所示</span><br><span class="line">              // 添加主界面路由</span><br><span class="line">              store.dispatch(&#x27;UpdateAppRouter&#x27;,  &#123; constRoutes &#125;).then(() =&gt; &#123; // 代码如下文所示</span><br><span class="line">                // 根据roles权限生成可访问的路由表</span><br><span class="line">                // 动态添加可访问路由表</span><br><span class="line">                router.addRoutes(store.getters.addRouters)</span><br><span class="line">                const redirect = decodeURIComponent(from.query.redirect || to.path)</span><br><span class="line">                if (to.path === redirect) &#123;</span><br><span class="line">                  // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record</span><br><span class="line">                  next(&#123; ...to, replace: true &#125;)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                  // 跳转到目的路由</span><br><span class="line">                  next(&#123; path: redirect &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          .catch(() =&gt; &#123;</span><br><span class="line">           /* notification.error(&#123;</span><br><span class="line">              message: &#x27;系统提示&#x27;,</span><br><span class="line">              description: &#x27;请求用户信息失败，请重试！&#x27;</span><br><span class="line">            &#125;)*/</span><br><span class="line">            store.dispatch(&#x27;Logout&#x27;).then(() =&gt; &#123;</span><br><span class="line">              next(&#123; path: &#x27;/user/login&#x27;, query: &#123; redirect: to.fullPath &#125; &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我认为优秀的代码就是最好的注释，你能根据命名猜测出这段代码的大致意思，所以对于如上代码，我只写了大致的注释。但是有一段代码需要提醒大家。对于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store.dispatch(&#x27;GetPermissionList&#x27;).then(...)</span><br></pre></td></tr></table></figure>

<p>有必要仔细阅读<a href="https://vuex.vuejs.org/zh/guide/actions.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%88%86%E5%8F%91-action">vuex参考文档</a></p>
<p>此外，对于上述中如下代码，需要进一步解释。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store.dispatch(&#x27;GetPermissionList&#x27;).then(...)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constRoutes = generateIndexRouter(menuData);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store.dispatch(&#x27;UpdateAppRouter&#x27;,  &#123; constRoutes &#125;).then(...)</span><br></pre></td></tr></table></figure>



<blockquote>
<p> <strong>store.dispatch(‘GetPermissionList’).then(…)</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetPermissionList(&#123; commit &#125;) &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        queryPermissionsByUser().then(response =&gt; &#123; // 后台查询用户权限信息</span><br><span class="line">          const menuData = response.result.menu; </span><br><span class="line">          const authData = response.result.auth;</span><br><span class="line">          const allAuthData = response.result.allAuth;</span><br><span class="line">          sessionStorage.setItem(USER_AUTH,JSON.stringify(authData));</span><br><span class="line">          sessionStorage.setItem(SYS_BUTTON_AUTH,JSON.stringify(allAuthData));</span><br><span class="line">          if (menuData &amp;&amp; menuData.length &gt; 0) &#123;</span><br><span class="line">            commit(&#x27;SET_PERMISSIONLIST&#x27;, menuData)</span><br><span class="line">            // 设置系统安全模式</span><br><span class="line">            commit(&#x27;SET_SYS_SAFE_MODE&#x27;, response.result.sysSafeMode)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            reject(&#x27;getPermissionList: permissions must be a non-null array !&#x27;)</span><br><span class="line">          &#125;</span><br><span class="line">          resolve(response)</span><br><span class="line">        &#125;).catch(error =&gt; &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中，上述返回的<strong>response结构</strong>如下所示（节选部分内容）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;success&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;allAuth&quot;</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;online:goGenerateCode&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;代码生成按钮&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:add&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;添加按钮&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:edit&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;用户编辑&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:sex&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;表单性别可见&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:form:birthday&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;禁用生日字段&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;2&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;demo:add&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;demo添加功能&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:form:phone&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;手机号禁用&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;2&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;auth&quot;</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;demo:add&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;demo添加功能&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;online:goGenerateCode&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;代码生成按钮&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:add&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;添加按钮&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;menu&quot;</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;redirect&quot;</span>:<span class="literal">null</span>,</span><br><span class="line">                <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/dashboard/analysis&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;dashboard/Analysis&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                    <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;icon&quot;</span>:<span class="string">&quot;home&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;Analysis&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;首页&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;dashboard-analysis&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;9502685863ab87f0ad1134142788a385&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;redirect&quot;</span>:<span class="literal">null</span>,</span><br><span class="line">                <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/report&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;layouts/RouteView&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;children&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/report/ArchivesStatisticst&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;jeecg/report/ArchivesStatisticst&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;ArchivesStatisticst&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;布局统计报表&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;report-ArchivesStatisticst&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;2aeddae571695cd6380f6d6d334d6e7d&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/report/ViserChartDemo&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;jeecg/report/ViserChartDemo&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;ViserChartDemo&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;ViserChartDemo&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;report-ViserChartDemo&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;020b06793e4de2eee0007f603000c769&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/online/cgreport/6c7f59741c814347905a938f06ee003c&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;modules/online/cgreport/auto/OnlCgreportAutoList&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;0&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;OnlCgreportAutoList&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;Online报表示例&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;online-cgreport-6c7f59741c814347905a938f06ee003c&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;1232123780958064642&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;a93c0c3609dece99e85f4aa1caaac981&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;layouts/IframePageView&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;IframePageView&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;Redis监控&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;&#123;&#123; window._CONFIG[&#x27;domianURL&#x27;] &#125;&#125;/jmreport/view/1352160857479581696?token=$&#123;token&#125;&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;&#123;&#123; window._CONFIG[&#x27;domianURL&#x27;] &#125;&#125;-jmreport-view-1352160857479581696?token=$&#123;token&#125;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;1352200630711652354&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                    <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;icon&quot;</span>:<span class="string">&quot;bar-chart&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;RouteView&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;统计报表&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;report&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;f0675b52d89100ee88472b6800754a08&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;redirect&quot;</span>:<span class="literal">null</span>,</span><br><span class="line">                <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/form&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;layouts/PageView&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;children&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/form/step-form&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;examples/form/stepForm/StepForm&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;StepForm&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;分步表单&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;form-step-form&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;6531cf3421b1265aeeeabaab5e176e6d&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/form/advanced-form&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;examples/form/advancedForm/AdvancedForm&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;AdvancedForm&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;高级表单&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;form-advanced-form&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;e5973686ed495c379d829ea8b2881fc6&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                    <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;icon&quot;</span>:<span class="string">&quot;form&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;PageView&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;表单页&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;form&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;e3c13679c73a4f829bcff2aba8fd68b1&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;sysSafeMode&quot;</span>:<span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>:<span class="number">1639477587569</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述数据结构相关说明</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&#123; Route &#125;` 对象</span><br><span class="line"></span><br><span class="line">| 参数     | 说明                                        | 类型    | 默认值 |</span><br><span class="line">| -------- | ----------------------------------------- -- ------- | ------ |</span><br><span class="line">| hidden   | 控制路由是否显示在 sidebar                    | boolean | falase |</span><br><span class="line">| redirect | 重定向地址, 访问这个路由时,自定进行重定向         | string  | -      |</span><br><span class="line">| name     | 路由名称, 建议设置,且不能重名                   | string  | -      |</span><br><span class="line">| meta     | 路由元信息（路由附带扩展信息）                   | object  | &#123;&#125;     |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`&#123; Meta &#125;` 路由元信息对象</span><br><span class="line"> </span><br><span class="line">| 参数                | 说明                                                                     | 类型    | 默认值 |</span><br><span class="line">| ------------------- |------------------------------------------------------------------------  ------- ------ |</span><br><span class="line">| title               | 路由标题, 用于显示面包屑, 页面标题 *推荐设置                                   | string  | -      |</span><br><span class="line">| icon                | 路由在 menu 上显示的图标                                                   | string  | -      |</span><br><span class="line">| keepAlive           | 缓存该路由                                                                | boolean | false  |</span><br><span class="line">| hiddenHeaderContent | *特殊 隐藏 [PageHeader]( 组件中的页面带的 面包屑和页面标题栏 )        | boolean | false  |</span><br><span class="line">| permission          | 与项目提供的权限拦截匹配的权限，如果不匹配，则会被禁止访问该路由页面                 | array   | []     |</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>generateIndexRouter(menuData)：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 生成首页路由</span><br><span class="line">export function generateIndexRouter(data) &#123; // 此处data参数即 menuData</span><br><span class="line">let indexRouter = [&#123;</span><br><span class="line">          path: &#x27;/&#x27;,</span><br><span class="line">          name: &#x27;dashboard&#x27;,</span><br><span class="line">          component: resolve =&gt; require([&#x27;@/components/layouts/TabLayout&#x27;], resolve),</span><br><span class="line">          meta: &#123; title: &#x27;首页&#x27; &#125;,</span><br><span class="line">          redirect: &#x27;/dashboard/analysis&#x27;,</span><br><span class="line">          children: [</span><br><span class="line">            ...generateChildRouters(data) // 代码如下文所示</span><br><span class="line">          ]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          &quot;path&quot;: &quot;*&quot;, &quot;redirect&quot;: &quot;/404&quot;, &quot;hidden&quot;: true</span><br><span class="line">        &#125;]</span><br><span class="line">  return indexRouter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 而上述对应的**generateChildRouters(data)**方法如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 生成嵌套路由（子路由）</span><br><span class="line">function generateChildRouters (data) &#123;</span><br><span class="line">  const routers = [];</span><br><span class="line">  for (let item of data) &#123;</span><br><span class="line">    let component = &quot;&quot;;</span><br><span class="line">    if(item.component.indexOf(&quot;layouts&quot;)&gt;=0)&#123; // 其实这里代码就做了一件事，将权限菜单的component进行拼接，得到文件夹的正确路径，不过为啥不一开始在路由表就存好正确的路径暂时没想通，项目较大，应该是迭代或者有其他我没注意到的地方的考虑</span><br><span class="line">       component = &quot;components/&quot;+item.component;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">       component = &quot;views/&quot;+item.component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // eslint-disable-next-line</span><br><span class="line">    let URL = (item.meta.url|| &#x27;&#x27;).replace(/&#123;&#123;([^&#125;&#125;]+)?&#125;&#125;/g, (s1, s2) =&gt; eval(s2)) // URL支持&#123;&#123; window.xxx &#125;&#125;占位符变量</span><br><span class="line">    if (isURL(URL)) &#123;</span><br><span class="line">      item.meta.url = URL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let componentPath</span><br><span class="line">    if(item.component==&quot;modules/online/cgform/OnlCgformHeadList&quot;)&#123;</span><br><span class="line">      componentPath = onlineCommons.OnlCgformHeadList</span><br><span class="line">    &#125;else if(item.component==&quot;modules/online/cgform/OnlCgformCopyList&quot;)&#123;</span><br><span class="line">      componentPath = onlineCommons.OnlCgformCopyList</span><br><span class="line">    &#125;  //(...省略部分与该主题无关的else if，上面的else if其实也无关，主要是最后else中的 `component` )</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      componentPath = resolve =&gt; require([&#x27;@/&#x27; + component+&#x27;.vue&#x27;], resolve)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let menu =  &#123;</span><br><span class="line">      path: item.path,</span><br><span class="line">      name: item.name,</span><br><span class="line">      redirect:item.redirect,</span><br><span class="line">      component: componentPath,</span><br><span class="line">      hidden:item.hidden,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        title:item.meta.title ,</span><br><span class="line">        icon: item.meta.icon,</span><br><span class="line">        url:item.meta.url ,</span><br><span class="line">        permissionList:item.meta.permissionList,</span><br><span class="line">        keepAlive:item.meta.keepAlive,</span><br><span class="line">        internalOrExternal:item.meta.internalOrExternal,</span><br><span class="line">        componentName:item.meta.componentName</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(item.alwaysShow)&#123;</span><br><span class="line">      menu.alwaysShow = true;</span><br><span class="line">      menu.redirect = menu.path;</span><br><span class="line">    &#125;</span><br><span class="line">    if (item.children &amp;&amp; item.children.length &gt; 0) &#123;</span><br><span class="line">      menu.children = [...generateChildRouters( item.children)];</span><br><span class="line">    &#125;</span><br><span class="line">    //根据后台菜单配置，判断是否路由菜单字段，动态选择是否生成路由（为了支持参数URL菜单）</span><br><span class="line">    //判断是否生成路由</span><br><span class="line">    if(item.route &amp;&amp; item.route === &#x27;0&#x27;)&#123;</span><br><span class="line">      //console.log(&#x27; 不生成路由 item.route：  &#x27;+item.route);</span><br><span class="line">      //console.log(&#x27; 不生成路由 item.path：  &#x27;+item.path);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      routers.push(menu);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return routers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>store.dispatch(‘UpdateAppRouter’,  { constRoutes }).then()</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 动态添加主界面路由，需要缓存</span><br><span class="line">    UpdateAppRouter(&#123; commit &#125;, routes) &#123; // 传入的routes为  generateIndexRouter(menuData) 的返回值，见上述该方法的代码</span><br><span class="line">      return new Promise(resolve =&gt; &#123;</span><br><span class="line">        let routelist = routes.constRoutes;</span><br><span class="line">        commit(&#x27;SET_ROUTERS&#x27;, routelist)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h2><blockquote>
<p>后端部分我个人认为最重要的地方是数据库表的设计，而相关的业务代码其实没什么好讲的，但是还是贴一下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询用户拥有的菜单权限和按钮权限</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/getUserPermissionByToken&quot;, method = RequestMethod.GET)</span></span><br><span class="line">	<span class="keyword">public</span> Result&lt;?&gt; getUserPermissionByToken() &#123;</span><br><span class="line">		Result&lt;JSONObject&gt; result = <span class="keyword">new</span> Result&lt;JSONObject&gt;();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//直接获取当前用户不适用前端token</span></span><br><span class="line">			LoginUser loginUser = (LoginUser) SecurityUtils.getSubject().getPrincipal();</span><br><span class="line">			<span class="keyword">if</span> (oConvertUtils.isEmpty(loginUser)) &#123;</span><br><span class="line">				<span class="keyword">return</span> Result.error(<span class="string">&quot;请登录系统！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			List&lt;SysPermission&gt; metaList = sysPermissionService.queryByUser(loginUser.getUsername());</span><br><span class="line">			<span class="comment">//添加首页路由</span></span><br><span class="line">			<span class="comment">//需要根据后台的路由配置来实现是否缓存</span></span><br><span class="line">			<span class="keyword">if</span>(!PermissionDataUtil.hasIndexPage(metaList))&#123;</span><br><span class="line">				SysPermission indexMenu = sysPermissionService.list(<span class="keyword">new</span> LambdaQueryWrapper&lt;SysPermission&gt;().eq(SysPermission::getName,<span class="string">&quot;首页&quot;</span>)).get(<span class="number">0</span>);</span><br><span class="line">				metaList.add(<span class="number">0</span>,indexMenu);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			List&lt;String&gt; roles = sysUserService.getRole(loginUser.getUsername());</span><br><span class="line">            String compUrl = RoleIndexConfigEnum.getIndexByRoles(roles);</span><br><span class="line">			<span class="keyword">if</span>(StringUtils.isNotBlank(compUrl))&#123;</span><br><span class="line">				List&lt;SysPermission&gt; menus = metaList.stream().filter(sysPermission -&gt; <span class="string">&quot;首页&quot;</span>.equals(sysPermission.getName())).collect(Collectors.toList());</span><br><span class="line">				menus.get(<span class="number">0</span>).setComponent(compUrl);</span><br><span class="line">			&#125;</span><br><span class="line">			JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">			JSONArray menujsonArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line">			<span class="keyword">this</span>.getPermissionJsonArray(menujsonArray, metaList, <span class="keyword">null</span>);</span><br><span class="line">			<span class="comment">//一级菜单下的子菜单全部是隐藏路由，则一级菜单不显示</span></span><br><span class="line">			<span class="keyword">this</span>.handleFirstLevelMenuHidden(menujsonArray);</span><br><span class="line"></span><br><span class="line">			JSONArray authjsonArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line">			<span class="keyword">this</span>.getAuthJsonArray(authjsonArray, metaList);</span><br><span class="line">			<span class="comment">//查询所有的权限</span></span><br><span class="line">			LambdaQueryWrapper&lt;SysPermission&gt; query = <span class="keyword">new</span> LambdaQueryWrapper&lt;SysPermission&gt;();</span><br><span class="line">			query.eq(SysPermission::getDelFlag, CommonConstant.DEL_FLAG_0);</span><br><span class="line">			query.eq(SysPermission::getMenuType, CommonConstant.MENU_TYPE_2);</span><br><span class="line">			<span class="comment">//query.eq(SysPermission::getStatus, &quot;1&quot;);</span></span><br><span class="line">			List&lt;SysPermission&gt; allAuthList = sysPermissionService.list(query);</span><br><span class="line">			JSONArray allauthjsonArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line">			<span class="keyword">this</span>.getAllAuthJsonArray(allauthjsonArray, allAuthList);</span><br><span class="line">			<span class="comment">//路由菜单</span></span><br><span class="line">			json.put(<span class="string">&quot;menu&quot;</span>, menujsonArray);</span><br><span class="line">			<span class="comment">//按钮权限（用户拥有的权限集合）</span></span><br><span class="line">			json.put(<span class="string">&quot;auth&quot;</span>, authjsonArray);</span><br><span class="line">			<span class="comment">//全部权限配置集合（按钮权限，访问权限）</span></span><br><span class="line">			json.put(<span class="string">&quot;allAuth&quot;</span>, allauthjsonArray);</span><br><span class="line">			json.put(<span class="string">&quot;sysSafeMode&quot;</span>, jeeccgBaseConfig.getSafeMode());</span><br><span class="line">			result.setResult(json);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			result.error500(<span class="string">&quot;查询失败:&quot;</span> + e.getMessage());  </span><br><span class="line">			log.error(e.getMessage(), e);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>提取几个业务相关（其实就是数据库查询）相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;SysPermission&gt; metaList = sysPermissionService.queryByUser(loginUser.getUsername());</span><br><span class="line"></span><br><span class="line">SysPermission indexMenu = sysPermissionService.list(<span class="keyword">new</span> LambdaQueryWrapper&lt;SysPermission&gt;().eq(SysPermission::getName,<span class="string">&quot;首页&quot;</span>)).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; roles = sysUserService.getRole(loginUser.getUsername());</span><br></pre></td></tr></table></figure>



<h4 id="相关数据库表设计如下"><a href="#相关数据库表设计如下" class="headerlink" title="相关数据库表设计如下"></a>相关数据库表设计如下</h4><blockquote>
<p>角色和权限相关，那么有权限表必然也有对应的角色表，因此我们关注的重点方向在于权限表、角色表 以及 权限角色关联表。</p>
</blockquote>
<blockquote>
<p><strong>sys_role表</strong></p>
</blockquote>
<p><img src="/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/image-20211214212015880.png"></p>
<blockquote>
<p><strong>sys_role_permission表（节选）</strong></p>
</blockquote>
<p><img src="/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/image-20211214212110982.png" alt="image-20211214212110982"></p>
<blockquote>
<p><strong>sys_permission表</strong>(如需看更多数据自行下载代码查看)</p>
</blockquote>
<p><img src="/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/image-20211214212252390.png" alt="image-20211214212252390"></p>
<p><img src="/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/image-20211214213445059.png" alt="image-20211214213445059"></p>
<blockquote>
<p>后端sql如下,总之，查询出来的数据就是上面介绍的json数据</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 获取登录用户拥有的权限 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Object&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;SysPermission&quot;</span>&gt;</span></span><br><span class="line">		   SELECT * FROM (</span><br><span class="line">			   SELECT p.*</span><br><span class="line">			   FROM  sys_permission p</span><br><span class="line">			   WHERE (exists(</span><br><span class="line">						select a.id from sys_role_permission a</span><br><span class="line">						join sys_role b on a.role_id = b.id</span><br><span class="line">						join sys_user_role c on c.role_id = b.id</span><br><span class="line">						join sys_user d on d.id = c.user_id</span><br><span class="line">						where p.id = a.permission_id AND d.username = #&#123;username,jdbcType=VARCHAR&#125;</span><br><span class="line">					)</span><br><span class="line">					or (p.url like &#x27;%:code&#x27; and p.url like &#x27;/online%&#x27; and p.hidden = 1)</span><br><span class="line">					or p.url = &#x27;/online&#x27;)</span><br><span class="line">			   and p.del_flag = 0</span><br><span class="line">			<span class="comment">&lt;!--update begin Author:lvdandan  Date:20200213 for：加入部门权限 --&gt;</span></span><br><span class="line">			   UNION</span><br><span class="line">			   SELECT p.*</span><br><span class="line">			   FROM  sys_permission p</span><br><span class="line">			   WHERE exists(</span><br><span class="line">					select a.id from sys_depart_role_permission a</span><br><span class="line">					join sys_depart_role b on a.role_id = b.id</span><br><span class="line">					join sys_depart_role_user c on c.drole_id = b.id</span><br><span class="line">					join sys_user d on d.id = c.user_id</span><br><span class="line">					where p.id = a.permission_id AND d.username = #&#123;username,jdbcType=VARCHAR&#125;</span><br><span class="line">			   )</span><br><span class="line">			   and p.del_flag = 0</span><br><span class="line">			<span class="comment">&lt;!--update end Author:lvdandan  Date:20200213 for：加入部门权限 --&gt;</span></span><br><span class="line">		   ) h order by h.sort_no ASC</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本思路为：数据库存储菜单结构、页面权限控制信息等，前端根据数据库中的菜单结构和权限信息来渲染一个菜单出来并只显示其有权限的菜单，并在路由守卫中进行权限控制防止手动输入path越权打开页面</p>
<p>1、前端路由（vue-router）中需要正常创建页面及路由。</p>
<p>2、数据库存储菜单结构和页面权限信息，需要时从数据库中查询出来</p>
<ul>
<li>所有角色都有的界面（比如dashboard）写死在前端</li>
<li>由权限控制得到的视图路径存在数据库中</li>
<li>菜单和页面组成上下级关系，一级可以是菜单也可以是内容页，内容页也可以放在菜单下，不可见的内容页也可以放在一个普通内容页下，这样理论（需要页面菜单样式支持）可以组成无限级菜单</li>
<li>菜单和页面的基本属性见上文 json数据 下面的说明</li>
<li>不需要控制权限且不需要显示到左侧菜单的路由这里可以不进行管理，比如404页面等</li>
</ul>
<p>3、前端打开后获取数据库的所有菜单、页面及结构，根据是否登录、是否需要验证权限等进行控制，或无权限跳转至登录页</p>
<p>4、用户登录成功后，再获取用户对应的的页面权限列表，使用上一步获得的所有页面、结构和用户拥有权限的列表渲染出一个菜单，只包含此用户拥有权限的相应视图</p>
<p>5、路由守卫中根据上一步获得的权限列表判断每个跳转，无权限可返回404或无权限页面，防止用户手动输入path越权访问</p>
]]></content>
      <categories>
        <category>前后端分离</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读Spring文档摘录</title>
    <url>/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>这篇博客是我在阅读 Spring 英文文档过程中记录的对 Spring 的新认知，或者说是之前比较模糊的概念。总而言之，算是我个人的随笔记录，方便以后查看，如果感觉对你帮助不大，可以跳过不看本篇博客。</p>
</blockquote>
<h3 id="1-Container-Overview"><a href="#1-Container-Overview" class="headerlink" title="1. Container Overview"></a>1. Container Overview</h3><p>The <code>org.springframework.context.ApplicationContext</code> interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects.</p>
<p>applicationcontext接口表示Spring IoC容器，并负责实例化、配置和组装bean。容器通过读取配置元数据来获取关于实例化、配置和组装哪些对象的指令。配置元数据以XML、Java注释或Java代码表示。它允许您表达组成应用程序的对象以及这些对象之间的丰富的相互依赖关系。</p>
<h3 id="2-Configuration-Metadata"><a href="#2-Configuration-Metadata" class="headerlink" title="2. Configuration Metadata"></a>2. Configuration Metadata</h3><p>For information about using other forms of metadata with the Spring container, see:</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config">Annotation-based configuration</a>: Spring 2.5 introduced support for annotation-based configuration metadata.</li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java">Java-based configuration</a>: Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus, you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html"><code>@Import</code></a>, and <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html"><code>@DependsOn</code></a> annotations.</li>
</ul>
<p>Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata configures these beans as <code>&lt;bean/&gt;</code> elements inside a top-level <code>&lt;beans/&gt;</code> element. Java configuration typically uses <code>@Bean</code>-annotated methods within a <code>@Configuration</code> class.</p>
<p>这段我认为需要理解好最后一句话：Java 配置通常在@Configuration 类中使用@Bean 注释的方法。</p>
<blockquote>
<p> Spring3.0开始，@Configuration用于定义配置类，定义的配置类可以替换xml文件，一般和@Bean注解联合使用。@Configuration注解主要标注在某个类上，相当于xml配置文件中的<beans>@Bean注解主要标注在某个方法上，相当于xml配置文件中的<bean></bean></beans></p>
</blockquote>
<p><img src="/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/development\myblog\source_posts\阅读Spring文档摘录\202004161021529.png" alt="D:\development\myblog\source\_posts\阅读Spring文档摘录\202004161021529.png"></p>
<h4 id="2-1-the-basic-structure-of-XML-based-configuration-metadata"><a href="#2-1-the-basic-structure-of-XML-based-configuration-metadata" class="headerlink" title="2.1 the basic structure of XML-based configuration metadata"></a>2.1 the basic structure of XML-based configuration metadata</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;  </span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>The <code>id</code> attribute is a string that identifies the individual bean definition.</li>
<li>The <code>class</code> attribute defines the type of the bean and uses the fully qualified classname.</li>
</ul>
<h3 id="3-Composing-XML-based-Configuration-Metadata"><a href="#3-Composing-XML-based-Configuration-Metadata" class="headerlink" title="3. Composing XML-based Configuration Metadata"></a>3. Composing XML-based Configuration Metadata</h3><p>It can be useful to have bean definitions span multiple XML files. Often, each individual XML configuration file represents a logical layer or module in your architecture.</p>
<p>You can use the application context constructor to load bean definitions from all these XML fragments. This constructor takes multiple <code>Resource</code> locations, as was shown in the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-instantiation">previous section</a>. Alternatively, use one or more occurrences of the <code>&lt;import/&gt;</code> element to load bean definitions from another file or files. The following example shows how to do so:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;import resource=&quot;services.xml&quot;/&gt;</span><br><span class="line">    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;</span><br><span class="line">    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>In the preceding example, external bean definitions are loaded from three files: <code>services.xml</code>, <code>messageSource.xml</code>, and <code>themeSource.xml</code>. <strong>All location paths are relative to the definition file doing the importing, so <code>services.xml</code> must be in the same directory or classpath location as the file doing the importing, while <code>messageSource.xml</code> and <code>themeSource.xml</code> must be in a <code>resources</code> location below the location of the importing file.</strong> As you can see, a leading slash is ignored. However, given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level <code>&lt;beans/&gt;</code> element, must be valid XML bean definitions, according to the Spring Schema.</p>
<p>上述内容主要就是描述了XML如何定义，其中黑体字标出的相对重要些：<strong>所有的位置路径都是相对于执行导入的定义文件的，因此services.xml必须与执行导入的文件位于相同的目录或类路径位置，而messageSource.xml和themeSource.xml必须位于导入文件位置下方的资源位置。</strong></p>
<blockquote>
<p>It is possible, but not recommended, to reference files in parent directories using a relative “../“ path. Doing so creates a dependency on a file that is outside the current application. In particular, this reference is not recommended for <code>classpath:</code> URLs (for example, <code>classpath:../services.xml</code>), where the runtime resolution process chooses the “nearest” classpath root and then looks into its parent directory. Classpath configuration changes may lead to the choice of a different, incorrect directory.</p>
<p>You can always use fully qualified resource locations instead of relative paths: for example, <code>file:C:/config/services.xml</code> or <code>classpath:/config/services.xml</code>. However, be aware that you are coupling your application’s configuration to specific absolute locations. It is generally preferable to keep an indirection for such absolute locations — for example, through “${…}” placeholders that are resolved against JVM system properties at runtime.</p>
</blockquote>
<blockquote>
<p>上述大概意思就是不推荐使用 “../” 这种形式的路径配置，这样做会在当前应用程序之外的文件上创建一个依赖项。特别是不建议<code>classpath:</code> URLs (比如 <code>classpath:../services.xml</code>) 这种形式的引用，运行时解析进程选择“最近的”类路径根，然后查看其父目录。</p>
<p>可以使用完全限定的资源位置而不是绝对位置: 比如  <code>file:C:/config/services.xml</code> 或者<code>classpath:/config/services.xml</code>。但是，请注意，您正在将应用程序的配置耦合到特定的绝对位置。对于这种绝对位置，通常更可取的做法是保持间接性ーー例如，通过在运行时根据 JVM 系统属性解析的“ ${ … }”占位符。</p>
</blockquote>
<h3 id="4-Naming-Beans"><a href="#4-Naming-Beans" class="headerlink" title="4. Naming Beans"></a>4. Naming Beans</h3><p>Every bean has one or more identifiers. These identifiers must be unique within the container that hosts the bean. A bean usually has only one identifier. However, if it requires more than one, the extra ones can be considered aliases.</p>
<p>In XML-based configuration metadata, you use the <code>id</code> attribute, the <code>name</code> attribute, or both to specify the bean identifiers. The <code>id</code> attribute lets you specify exactly one id. </p>
<p>The convention is to use the standard Java convention for instance field names when naming beans. That is, bean names start with a lowercase letter and are camel-cased from there. Examples of such names include <code>accountManager</code>, <code>accountService</code>, <code>userDao</code>, <code>loginController</code>, and so forth.</p>
<p>Naming beans consistently makes your configuration easier to read and understand. <strong>Also, if you use Spring AOP, it helps a lot when applying advice to a set of beans related by name.</strong></p>
<p>With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules described earlier: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved. These are the same rules as defined by <code>java.beans.Introspector.decapitalize</code> (which Spring uses here).</p>
<p>上述前两段主要就是描述每个 bean 都有一个或多个标识符。这些标识符在承载 bean 的容器中必须是唯一的。一个 bean 通常只有一个标识符。但是，如果它需要多于一个，那么额外的那些可以被认为是别名。Bean的命名方式通常有 <code>id</code> 和 <code>name</code> 命名，</p>
<p>中间两段主要介绍了并推荐使用驼峰命名。<strong>但是这部分最后一句加粗的文字目前我并不理解，暂且搁置。</strong></p>
<p>最后一段描述通过在类路径中进行组件扫描，Spring 为未命名的组件生成 bean 名称，遵循前面描述的规则: 本质上，使用简单的类名并将其初始字符转换为小写。<strong>但是，在(不寻常的)特殊情况下，当有多个字符且第一个和第二个字符都是大写字母时，原始大小写将得到保留。这些规则与 java.beans 定义的规则相同。</strong>这部分加粗文字和Java内省机制相关类 <code>Introspector</code> 有关，其中该类相关源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String decapitalize(String name) &#123;</span><br><span class="line">        if (name == null || name.length() == 0) &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        if (name.length() &gt; 1 &amp;&amp; Character.isUpperCase(name.charAt(1)) &amp;&amp;</span><br><span class="line">                        Character.isUpperCase(name.charAt(0)))&#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        char chars[] = name.toCharArray();</span><br><span class="line">        chars[0] = Character.toLowerCase(chars[0]);</span><br><span class="line">        return new String(chars);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般情况下，把字符串第一个字母变为小写，如把“FooBah”变为“fooBah”。但在特殊情况下，即字符串前两个字母都是大写的时候，什么也不做，如，遇到“URL”，原样返回。</p>
<p>decapitalize()的bug是：如果一个字符串，前两个字母大写，但后面还有小写字母，它仍然返回原字符串！</p>
<p>Hibernate的开发者注意到decapitalize()的特点，所以才在判断语句中使用一个或运算(不然只需要判断方法名截掉“get”，再改第一个字母为小写后的字符串与属性名是否相等即可，这也是按照JavaBean Specification定义的标准做法)。但是，Hibernate没有解决这个bug，可能是他们没有碰到我遇到的情况。</p>
<p>类似sAddress(一般性地说，第一个字母小写，第二个字母大写)属性命名就是bug的诱因。</p>
<p>那么，解决方法有三种：</p>
<p>把属性名改成SAddress，这样就满足上面匹配判断的第二个条件(方法名截掉“get”后，与属性名匹配)。但是，这样做不符合Java命名规范；</p>
<p>把getSAddress()改成getsAddress()，这样也满足上面匹配判断的第二个条件(方法名截掉“get”后，与属性名匹配)。但是，这样做不符合JavaBean命名规范；</p>
<p>把属性名改成strAddress，并形成一种约定：命名属性时，第二个字符只能是小写字母。这个方法不需要做更多地修改，符合所有规范，最为稳妥。</p>
</blockquote>
<h4 id="4-1-Aliasing-a-Bean-outside-the-Bean-Definition"><a href="#4-1-Aliasing-a-Bean-outside-the-Bean-Definition" class="headerlink" title="4.1 Aliasing a Bean outside the Bean Definition"></a>4.1 Aliasing a Bean outside the Bean Definition</h4><p>子系统 a 的配置元数据可以通过 subsystemA-DataSource 的名称引用 DataSource。子系统 b 的配置元数据可以通过 subsystemB-DataSource 的名称来引用 DataSource。当组合使用这两个子系统的主应用程序时，主应用程序通过 myapp-DataSource 的名称引用 DataSource。要让所有三个名称都指向同一个对象，可以向配置元数据添加以下别名定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt;</span><br><span class="line">&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>现在，每个组件和主应用程序都可以通过一个惟一的名称引用 dataSource，并保证不会与任何其他定义发生冲突(有效地创建名称空间) ，但它们引用的是同一个 bean。</p>
<blockquote>
<p>If you use Javaconfiguration, the <code>@Bean</code> annotation can be used to provide aliases. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-bean-annotation">Using the <code>@Bean</code> Annotation</a> for details.</p>
</blockquote>
<h4 id="4-2-Instantiation-with-a-Static-Factory-Method（用静态工厂方法实例化）"><a href="#4-2-Instantiation-with-a-Static-Factory-Method（用静态工厂方法实例化）" class="headerlink" title="4.2 Instantiation with a Static Factory Method（用静态工厂方法实例化）"></a>4.2 Instantiation with a Static Factory Method（用静态工厂方法实例化）</h4><p>调用这个方法(带有可选参数，如后面所述)并返回一个活动对象，随后该对象将被视为通过构造函数创建的。这种 bean 定义的一个用途是在遗留代码中调用静态工厂。</p>
<p>下面的 bean 定义指定通过调用 factory 方法创建 bean。该定义不指定返回对象的类型(类) ，只指定包含工厂方法的类。在本例中，createInstance ()方法必须是静态方法。下面的示例演示如何指定工厂方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    class=&quot;examples.ClientService&quot;</span><br><span class="line">    factory-method=&quot;createInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>下面的示例展示了一个与前面的 bean 定义一起工作的类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClientService &#123;</span><br><span class="line">    private static ClientService clientService = new ClientService();</span><br><span class="line">    private ClientService() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static ClientService createInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>遗留代码: Legacy Code</p>
<p>遗留代码是指不再受支持的应用程序系统源代码类型。遗留代码也可以指不支持的操作系统、硬件和格式。在大多数情况下，遗留代码被转换为现代软件语言和平台。然而，为了保留熟悉的用户功能，遗留代码有时会被带入新的环境中。</p>
</blockquote>
<blockquote>
<p>这里可以参考我的另一篇博客来理解静态工厂方法创建对象：<a href="https://hznu.asia/2022/01/13/Effective-Java-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/">Effective Java–创建和销毁对象</a></p>
</blockquote>
<h4 id="4-3-Instantiation-by-Using-an-Instance-Factory-Method-（使用实例工厂方法实例化）"><a href="#4-3-Instantiation-by-Using-an-Instance-Factory-Method-（使用实例工厂方法实例化）" class="headerlink" title="4.3 Instantiation by Using an Instance Factory Method （使用实例工厂方法实例化）"></a>4.3 Instantiation by Using an Instance Factory Method （使用实例工厂方法实例化）</h4><p>与通过静态工厂方法进行的实例化类似，使用实例工厂方法进行的实例化，从容器中调用现有 bean 的非静态方法来创建新 bean。要使用这种机制，保留 class 属性为空，并在 factory-bean 属性中，在当前(或父或祖先)容器中指定 bean 的名称，该容器包含要调用来创建对象的实例方法。使用 factory-method 属性设置 factory 方法本身的名称。下面的例子展示了如何配置这样一个 bean:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span><br><span class="line">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;</span><br><span class="line">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- the bean to be created via the factory bean --&gt;</span><br><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createClientServiceInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>下面的示例展示了相应的类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultServiceLocator &#123;</span><br><span class="line"></span><br><span class="line">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    public ClientService createClientServiceInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个工厂类也可以容纳多个工厂方法，如下面的示例所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;</span><br><span class="line">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createClientServiceInstance&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;accountService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createAccountServiceInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>下面的示例展示了相应的类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultServiceLocator &#123;</span><br><span class="line"></span><br><span class="line">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    private static AccountService accountService = new AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    public ClientService createClientServiceInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AccountService createAccountServiceInstance() &#123;</span><br><span class="line">        return accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法表明，工厂 bean 本身可以通过依赖注入管理器(DI)来管理和配置。详见<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-properties-detailed">依赖关系和配置</a>。</p>
<blockquote>
<p>在 Spring 文档中，”factory bean” 指的是在 Spring 容器中配置并通过实例或静态工厂方法创建对象的 bean。相比之下，FactoryBean (注意大写)引用了一个 spring 特定的 FactoryBean 实现类。</p>
</blockquote>
<h4 id="4-4-Determining-a-Bean’s-Runtime-Type"><a href="#4-4-Determining-a-Bean’s-Runtime-Type" class="headerlink" title="4.4 Determining a Bean’s Runtime Type"></a>4.4 Determining a Bean’s Runtime Type</h4><p>确定特定 bean 的运行时类型并不简单。Bean 元数据定义中的指定类仅仅是一个初始类引用，它可能与已声明的工厂方法或 FactoryBean 类结合在一起，后者可能导致 bean 的不同运行时类型，或者在实例级工厂方法(可以通过指定的工厂 bean 名称解析)的情况下根本不设置类。此外，AOP 代理可以使用基于接口的代理来包装 bean 实例，对目标 bean 的实际类型(仅仅是实现的接口)进行有限的公开。</p>
<p>查找特定 bean 的实际运行时类型的推荐方法是 BeanFactory.getType 调用指定的 bean 名称。这将考虑上述所有情况，并返回 BeanFactory.getBean 调用将返回的对象类型。</p>
<h3 id="5-Dependencies"><a href="#5-Dependencies" class="headerlink" title="5. Dependencies"></a>5. Dependencies</h3><h4 id="5-1-Constructor-Argument-Resolution"><a href="#5-1-Constructor-Argument-Resolution" class="headerlink" title="5.1 Constructor Argument Resolution"></a>5.1 <strong>Constructor Argument Resolution</strong></h4><p>使用参数的类型进行构造函数参数解析匹配。如果 bean 定义的构造函数参数中没有潜在的歧义，那么在 bean 定义中定义构造函数参数的顺序就是在 bean 被实例化时这些参数被提供给相应的构造函数的顺序。参考下面的类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThingOne &#123;</span><br><span class="line"></span><br><span class="line">    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 ThingTwo 和 thingThree类<strong>不通过继承关联</strong>，则不存在潜在的歧义。因此，下面的配置可以很好地工作，不需要在 &lt; constructor-arg/&gt; 元素中显式地指定构造函数参数索引或类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;beanTwo&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;beanThree&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>当引用另一个 bean 时，该类型是已知的，并且可以进行匹配(与前面的示例一样)。当使用简单类型时，如 <code>&lt; value &gt; true &lt;/value&gt;</code> ，Spring 无法确定值的类型，因此在没有帮助的情况下无法按类型进行匹配。参考下面的类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    // Number of years to calculate the Ultimate Answer</span><br><span class="line">    private final int years;</span><br><span class="line"></span><br><span class="line">    // The Answer to Life, the Universe, and Everything</span><br><span class="line">    private final String ultimateAnswer;</span><br><span class="line"></span><br><span class="line">    public ExampleBean(int years, String ultimateAnswer) &#123;</span><br><span class="line">        this.years = years;</span><br><span class="line">        this.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型匹配</strong></p>
<p>在前面的场景中，如果使用 type 属性显式指定构造函数参数的类型，那么容器可以对简单类型使用类型匹配，如下面的示例所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p><strong>构造函数参数的顺序</strong></p>
<p>可以使用 index 属性显式指定构造函数参数的索引，如下面的示例所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>除了解决多个简单值的不确定性，指定索引还可以解决构造函数具有两个相同类型的参数时的不确定性。</p>
<h3 id="5-2-Constructor-based-or-setter-based-DI"><a href="#5-2-Constructor-based-or-setter-based-DI" class="headerlink" title="5.2 Constructor-based or setter-based DI?"></a>5.2 Constructor-based or setter-based DI?</h3><p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies. Note that use of the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-required-annotation">@Required</a> annotation on a setter method can be used to make the property be a required dependency; however, constructor injection with programmatic validation of arguments is preferable.</p>
<p><strong>The Spring team generally advocates constructor injection,</strong> as it lets you implement application components as immutable objects and ensures that required dependencies are not <code>null</code>. Furthermore, constructor-injected components are always returned to the client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.</p>
<p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. <strong>One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later.</strong> Management through <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx">JMX MBeans</a> is therefore a compelling use case for setter injection.</p>
<p>Use the DI style that makes the most sense for a particular class. Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, then constructor injection may be the only available form of DI.</p>
<blockquote>
<p>译：由于可以混合使用基于构造函数和基于 setter 的 DI，因此对于强制依赖项使用构造函数和对于可选依赖项使用 setter 方法或配置方法是一个很好的经验法则。注意，在 setter 方法上使用@Required 注释可以使该属性成为必需的依赖项; 但是，带有参数编程验证的构造函数注入更可取。</p>
<p><strong>Spring 团队通常提倡构造函数注入，</strong>因为它允许您将应用程序组件实现为不可变对象，并确保所需的依赖项不为空。此外，构造函数注入的组件总是以完全初始化的状态返回给客户机(调用)代码。作为一个旁注，大量的构造函数参数是糟糕的代码，<strong>（本博客作者注：在《代码整洁之道》书中，作者建议一般不超过三个参数，超过的话意味着要对函数进行拆分）</strong>，这意味着类可能有太多的责任，应该重构以更好地解决适当的关注点分离/代码。</p>
<p>Setter 注入应该主要用于可选的依赖项，这些依赖项可以在类中分配合理的默认值。否则，必须在代码使用依赖项的所有地方执行非空检查。<strong>Setter 注入的一个好处是 setter 方法使该类的对象容易在以后重新配置或重新注入。</strong>因此，通过 JMX MBeans进行管理是 setter 注入的一个引人注目的用例。</p>
<p>使用对特定类最有意义的DI样式。有时，在处理没有源代码的第三方类时，可以自行选择。例如，如果一个第三方类不公开任何setter方法，那么构造函数注入可能是DI的唯一可用形式。</p>
</blockquote>
<blockquote>
<p><strong>构造注入是必须把一个对象的所有依赖的对象都进行实例化，才能实例化这个对象</strong></p>
<p><strong>Setter注入是先实例化这个对象，然后找到依赖的对象，对依赖的对象进行实例化。</strong></p>
<p>setter注入： 一般情况下所有的java bean, 我们都会使用setter方法和getter方法去设置和获取属性的值，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class namebean &#123;</span><br><span class="line">	String   name;</span><br><span class="line">	public void setName(String a) &#123;</span><br><span class="line">		name = a; </span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会创建一个bean的实例然后设置属性的值，spring的配置文件如下：</p>
<p>我们会创建一个bean的实例然后设置属性的值，spring的配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;bean1″ &gt;</span><br><span class="line">	&lt;property  name=&quot;name&quot; &gt;</span><br><span class="line">		&lt;value&gt;tom&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>Spring会调用setName方法来只是name属性为tom<br>构造方法注入：构造方法注入中，我们使用带参数的构造方法如下：</p>
<p>Spring会调用setName方法来只是name属性为tom<br>构造方法注入：构造方法注入中，我们使用带参数的构造方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class namebean &#123;</span><br><span class="line">	String name;</span><br><span class="line">	public namebean(String a) &#123;</span><br><span class="line">		name = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会在创建bean实例的时候以new namebean(”tom”)的方式来设置name属性, Spring配置文件如下：</p>
<p>我们会在创建bean实例的时候以new namebean(”tom”)的方式来设置name属性, Spring配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;bean1″ &gt;</span><br><span class="line">	&lt;constructor-arg&gt;</span><br><span class="line">		&lt;value&gt;My Bean Value&lt;/value&gt;</span><br><span class="line">	&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>使用constructor-arg标签来设置构造方法的参数。</p>
<p>使用constructor-arg标签来设置构造方法的参数。</p>
<p>引用：<a href="https://www.iteye.com/blog/yunqiang-zhang-hotmail-com-1601999">构造注入和Setter注入</a></p>
</blockquote>
<h4 id="5-3-Dependency-Resolution-Process（依赖解析的过程）"><a href="#5-3-Dependency-Resolution-Process（依赖解析的过程）" class="headerlink" title="5.3  Dependency Resolution Process（依赖解析的过程）"></a>5.3  Dependency Resolution Process（依赖解析的过程）</h4><p>The container performs bean dependency resolution as follows:</p>
<ul>
<li>The <code>ApplicationContext</code> is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified by XML, Java code, or annotations.</li>
<li>For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method (if you use that instead of a normal constructor). These dependencies are provided to the bean, when the bean is actually created.</li>
<li>Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.</li>
<li><strong>Each property or constructor argument that is a value is converted from its specified format to the actual type of that property or constructor argument. By default, Spring can convert a value supplied in string format to all built-in types, such as <code>int</code>, <code>long</code>, <code>String</code>, <code>boolean</code>, and so forth.</strong></li>
</ul>
<p>The Spring container validates the configuration of each bean as the container is created. However, the bean properties themselves are not set until the bean is actually created. Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Scopes are defined in <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes">Bean Scopes</a>. Otherwise, the bean is created only when it is requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s dependencies and its dependencies’ dependencies (and so on) are created and assigned. Note that resolution mismatches among those dependencies may show up late — that is, on first creation of the affected bean.</p>
<blockquote>
<p>容器执行 bean 依赖项解析如下:</p>
<p>创建 ApplicationContext 并使用描述所有 bean 的配置元数据进行初始化。可以通过 XML、 Java 代码或注释指定配置元数据。</p>
<p>对于每个 bean，它的依赖关系以属性、构造函数参数或静态工厂方法的参数的形式表示(如果您使用静态工厂方法而不是普通的构造函数)。在实际创建 bean 时，这些依赖项被提供给 bean。</p>
<p>每个属性或构造函数参数都是要设置的值的实际定义，或对容器中另一个 bean 的引用。</p>
<p><strong>作为值的每个属性或构造函数参数都将从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，如 int、 long、 String、 boolean 等。</strong></p>
<p>Spring 容器在创建容器时验证每个 bean 的配置。但是，在 bean 实际创建之前，不会设置 bean 属性本身。在创建容器时，将创建单一作用域并设置为预实例化(默认情况)的 bean。作用域在 Bean 作用域中定义。否则，只有在请求 bean 时才会创建它。创建 bean 可能会导致创建 bean 图，因为创建和分配 bean 的依赖项及其依赖项的依赖项(等等)。在首次创建受影响的 bean 时,请注意，这些依赖项之间的解析不匹配可能会延迟出现。</p>
</blockquote>
<p>You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created. This means that a Spring container that has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies — for example, the bean throws an exception as a result of a missing or invalid property. This potentially delayed visibility of some configuration issues is why <code>ApplicationContext</code> implementations by default pre-instantiate singleton beans. At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the <code>ApplicationContext</code> is created, not later. You can still override this default behavior so that singleton beans initialize lazily, rather than being eagerly pre-instantiated.</p>
<p>If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean. This means that, if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A. In other words, the bean is instantiated (if it is not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean">configured init method</a> or the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean">InitializingBean callback method</a>) are invoked.</p>
<blockquote>
<p>通常可以相信 Spring 会做正确的事情。它在容器加载时检测配置问题，例如对不存在的 bean 和循环依赖项的引用。Spring 在实际创建 bean 时设置属性并尽可能晚地解析依赖项。这意味着，如果创建对象或其某个依赖项时出现问题，那么正确加载的 Spring 容器随后可以在请求对象时生成异常ーー例如，由于缺少或无效属性，bean 抛出异常。一些配置问题的可见性可能会延迟，这就是为什么默认情况下 ApplicationContext 实现会预先实例化单例 bean。在实际需要这些 bean 之前，需要花费一些前期时间和内存来创建它们，因此在创建 ApplicationContext 时(而不是以后)会发现配置问题。您仍然可以覆盖这个默认行为，以便单例 bean 以惰性方式初始化，而不是急切地预先实例化。</p>
<p>如果不存在循环依赖关系，当一个或多个合作 bean 被注入到依赖 bean 中时，每个合作 bean 在被注入到依赖 bean 之前都会被完全配置。这意味着，如果 bean a 对 bean b 有依赖关系，那么在调用 bean a 上的 setter 方法之前，Spring IoC 容器将完全配置 bean b。换句话说，bean 被实例化(如果它不是预实例化的单例) ，它的依赖关系被设置，相关的生命周期方法(如配置的 init 方法或 InitializingBean 回调方法)被调用。</p>
</blockquote>
<h3 id="6-Dependencies-and-Configuration-in-Detail"><a href="#6-Dependencies-and-Configuration-in-Detail" class="headerlink" title="6. Dependencies and Configuration in Detail"></a>6. Dependencies and Configuration in Detail</h3><h4 id="6-1-Straight-Values-Primitives-Strings-and-so-on"><a href="#6-1-Straight-Values-Primitives-Strings-and-so-on" class="headerlink" title="6.1 Straight Values (Primitives, Strings, and so on)"></a>6.1 Straight Values (Primitives, Strings, and so on)</h4><p>元素的 value 属性将属性或构造函数参数指定为人类可读的字符串表示形式。Spring 的转换服务用于将这些值从 String 转换为属性或参数的实际类型。下面的示例显示了正在设置的各种值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">    &lt;!-- results in a setDriverClassName(String) call --&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;misterkaoli&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>下面的示例使用 p 名称空间进行更简洁的 XML 配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span><br><span class="line">        destroy-method=&quot;close&quot;</span><br><span class="line">        p:driverClassName=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">        p:url=&quot;jdbc:mysql://localhost:3306/mydb&quot;</span><br><span class="line">        p:username=&quot;root&quot;</span><br><span class="line">        p:password=&quot;misterkaoli&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>还可以配置 java.util.Properties 实例，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;mappings&quot;</span><br><span class="line">    class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- typed as a java.util.Properties --&gt;</span><br><span class="line">    &lt;property name=&quot;properties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>Spring 容器将 &lt; value/&gt; 元素内的文本转换为 java.util。属性实例，使用 javabean PropertyEditor 机制。这是一个很好的快捷方式，也是 Spring 团队确实喜欢使用嵌套的 &lt; value/&gt; 元素而不是 value 属性样式的少数几个地方之一。</p>
<h4 id="6-2-The-idref-element"><a href="#6-2-The-idref-element" class="headerlink" title="6.2 The idref element"></a>6.2 <strong>The</strong> <code>idref</code> <strong>element</strong></h4><p><code>Idref</code> 元素只是一种防错的方法，用于将容器中另一个 bean 的 id (字符串值——而不是引用)传递给一个 &lt; constructor-arg/&gt; 或 &lt; property/&gt; 元素。下面的例子展示了如何使用它:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;theClientBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;targetName&quot;&gt;</span><br><span class="line">        &lt;idref bean=&quot;theTargetBean&quot;/&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>前面的 bean 定义片段与下面的片段完全等效(在运行时) :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;client&quot; class=&quot;...&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;targetName&quot; value=&quot;theTargetBean&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>第一种形式比第二种更可取，因为使用 idref 标记可以让容器在部署时验证所引用的命名 bean 是否确实存在。在第二个变体中，不对传递给客户端 bean 的 targetName 属性的值执行验证。只有在实际实例化客户端 bean 时才会发现输入错误(很可能会导致致命的结果)。如果客户端 bean 是一个原型 bean，那么只有在部署容器之后很长时间才能发现这个排版错误和由此产生的异常。</p>
<blockquote>
<p>Idref 元素的本地属性在4.0 beans XSD 中不再受支持，因为它不再在常规 bean 引用上提供值。升级到4.0模式时，将现有的 idref 本地引用更改为 idref bean。</p>
</blockquote>
<h4 id="6-3-Collections"><a href="#6-3-Collections" class="headerlink" title="6.3 Collections"></a>6.3 Collections</h4><p><code>&lt;list/&gt;</code>、<code>&lt;set/&gt;</code>、<code>&lt;map/&gt;</code>和<code>&lt;props/&gt;</code>元素分别设置Java集合类型list、set、map和properties的属性和参数。下面的例子展示了如何使用它们:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;</span><br><span class="line">    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span><br><span class="line">    &lt;property name=&quot;adminEmails&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeList(java.util.List) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someList&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;a list element followed by a reference&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;myDataSource&quot; /&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someMap&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someSet&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;just some string&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;myDataSource&quot; /&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-Strongly-typed-collection"><a href="#6-4-Strongly-typed-collection" class="headerlink" title="6.4 Strongly-typed collection"></a>6.4 <strong>Strongly-typed collection</strong></h4><p>随着Java 5中泛型类型的引入，您可以使用强类型集合。也就是说，可以声明一个Collection类型，使其只能包含(例如)String元素。如果您使用Spring将强类型集合的依赖项注入到bean中，那么您可以利用Spring的类型转换支持，以便在将强类型集合实例的元素添加到集合之前将其转换为适当的类型。下面的Java类和bean定义展示了如何做到这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SomeClass &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Float&gt; accounts;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(Map&lt;String, Float&gt; accounts) &#123;</span><br><span class="line">        this.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;something&quot; class=&quot;x.y.SomeClass&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accounts&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=&quot;one&quot; value=&quot;9.99&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;two&quot; value=&quot;2.75&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;six&quot; value=&quot;3.99&quot;/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>当 <code>something</code> bean的 <code>accounts</code> 属性准备注入时，关于强类型 <code>Map&lt;String, Float&gt;</code> 的元素类型的泛型信息通过反射可用。因此，Spring的类型转换基础设施将各种值元素识别为<code>Float</code>类型，并将字符串值(<code>9.99</code>、<code>2.75</code>和<code>3.99</code>)转换为实际的<code>Float</code>类型。</p>
<h4 id="6-5-XML-Shortcut-with-the-p-namespace"><a href="#6-5-XML-Shortcut-with-the-p-namespace" class="headerlink" title="6.5 XML Shortcut with the p-namespace"></a>6.5 XML Shortcut with the p-namespace</h4><p>p名称空间允许使用bean元素的属性(而不是嵌套的<property>元素)来描述协作bean的属性值，或者两者都使用。</property></p>
<p>Spring支持具有名称空间的可扩展配置格式，名称空间基于XML Schema定义。本章中讨论的bean配置格式是在XML Schema文档中定义的。但是，p名称空间并没有在XSD文件中定义，它只存在于Spring的核心中。</p>
<p>下面的例子展示了两个XML片段(第一个使用标准XML格式，第二个使用p-命名空间)，它们解析到相同的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;email&quot; value=&quot;someone@somewhere.com&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;</span><br><span class="line">        p:email=&quot;someone@somewhere.com&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>该示例显示了bean定义中<code>p-namespace</code>中的一个名为<code>email</code>的属性。这告诉Spring包含一个属性声明。如前所述，<code>p-namespace</code>没有模式定义，因此可以将属性的名称设置为属性名称。</p>
<p>下一个例子包含另外两个bean定义，它们都有对另一个bean的引用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;john-modern&quot;</span><br><span class="line">        class=&quot;com.example.Person&quot;</span><br><span class="line">        p:name=&quot;John Doe&quot;</span><br><span class="line">        p:spouse-ref=&quot;jane&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>这个示例不仅包含使用<code>p-namespace</code>的属性值，而且还使用一种特殊的格式来声明属性引用。第一个bean定义使用<code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code>来创建从<code>bean john</code>到<code>bean jane</code>的引用，而第二个bean定义使用<code>p:spouse-ref=&quot;jane&quot;</code>作为属性来做完全相同的事情。在本例中，<code>spouse</code>是属性名，而<code>-ref</code>部分表明这不是一个直接的值，而是对另一个bean的引用。</p>
<h4 id="6-6-XML-Shortcut-with-the-c-namespace"><a href="#6-6-XML-Shortcut-with-the-c-namespace" class="headerlink" title="6.6 XML Shortcut with the c-namespace"></a>6.6 XML Shortcut with the c-namespace</h4><p>与带有<code>p-namespace</code>的XML Shortcut类似，<strong>在Spring 3.1中引入的<code>c-namespace</code>允许内联属性来配置构造函数参数，而不是嵌套<code>constructor-arg</code>元素。</strong></p>
<p>下面的例子使用了<code>c: namespace</code>来做和from基于构造函数的依赖注入一样的事情:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- traditional declaration with optional argument names --&gt;</span><br><span class="line">    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;email&quot; value=&quot;something@somewhere.com&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- c-namespace declaration with argument names --&gt;</span><br><span class="line">    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot;</span><br><span class="line">        c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p><code>c:</code>命名空间使用与<code>p: </code>one相同的约定(后面的-ref表示bean引用)，通过它们的名称设置构造函数参数。类似地，它需要在XML文件中声明，即使它没有在XSD模式中定义(它存在于Spring核心中)。</p>
<p>对于构造函数参数名不可用的罕见情况(通常是在没有调试信息的情况下编译字节码)，你可以使用回退到参数索引，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- c-namespace index declaration --&gt;</span><br><span class="line">&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:_0-ref=&quot;beanTwo&quot; c:_1-ref=&quot;beanThree&quot;</span><br><span class="line">    c:_2=&quot;something@somewhere.com&quot;/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于XML语法的原因，索引表示法要求前面有_，因为XML属性名称不能以数字开头(尽管有些ide允许)。对于<constructor-arg>元素也可以使用相应的索引表记法，但并不常用，因为这里的声明顺序通常就足够了。</constructor-arg></p>
</blockquote>
<h3 id="7-Method-Injection"><a href="#7-Method-Injection" class="headerlink" title="7. Method Injection"></a>7. Method Injection</h3><p>在大多数应用程序场景中，容器中的大多数bean都是单例的。<strong>当一个单例bean需要与另一个单例bean协作，或者一个非单例bean需要与另一个非单例bean协作时，通常通过将一个bean定义为另一个bean的属性来处理依赖关系。</strong>当bean生命周期不同时，问题就出现了。假设单例bean A需要使用非单例(原型)bean B，也许是在对A的每个方法调用中。容器只创建一次单例bean A，因此只得到一次设置属性的机会。容器不能在每次需要bean B的新实例时为bean A提供新实例。</p>
<p>一种解决方案是放弃某些控制倒置。你可以通过实现ApplicationContextAware接口让bean A知道容器，并且每次bean A需要它时，通过getBean(“B”)调用容器来请求(典型的新)bean B实例。下面的例子展示了这种方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// a class that uses a stateful Command-style class to perform some processing</span><br><span class="line">package fiona.apple;</span><br><span class="line"></span><br><span class="line">// Spring-API imports</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line">public class CommandManager implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    public Object process(Map commandState) &#123;</span><br><span class="line">        // grab a new instance of the appropriate Command</span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        // set the state on the (hopefully brand new) Command instance</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Command createCommand() &#123;</span><br><span class="line">        // notice the Spring API dependency!</span><br><span class="line">        return this.applicationContext.getBean(&quot;command&quot;, Command.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setApplicationContext(</span><br><span class="line">            ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-Request-Session-Application-and-WebSocket-Scopes"><a href="#8-Request-Session-Application-and-WebSocket-Scopes" class="headerlink" title="8.  Request, Session, Application, and WebSocket Scopes"></a>8.  Request, Session, Application, and WebSocket Scopes</h3><h4 id="8-1-Request-scope"><a href="#8-1-Request-scope" class="headerlink" title="8.1  Request scope"></a>8.1  Request scope</h4><p>Spring容器通过为每个HTTP请求使用LoginAction bean定义来创建LoginAction bean的新实例。也就是说，loginAction bean的作用域为HTTP请求级别。您可以随心所欲地更改创建的实例的内部状态，因为从相同的loginAction bean定义创建的其他实例不会在状态中看到这些更改。它们是针对个人要求的。当请求完成处理时，将范围限定在请求的bean丢弃。</p>
<p>在使用注释驱动的组件或Java配置时，可以使用@RequestScope注释将组件分配给请求范围。下面的例子展示了如何做到这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestScope</span><br><span class="line">@Component</span><br><span class="line">public class LoginAction &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-2-Session-Scope"><a href="#8-2-Session-Scope" class="headerlink" title="8.2 Session Scope"></a>8.2 Session Scope</h4><p>Spring容器通过在单个HTTP会话的生命周期中使用<code>UserPreferences </code>bean定义来创建<code>UserPreferences</code> bean的新实例。换句话说，<code>userPreferences</code> bean有效地限定在HTTP <code>Session</code>级别。与请求范围内bean一样,你可以改变内部状态的实例创建尽可能多的你想要的,知道其他HTTP会话实例也使用相同的实例创建<code>userPreferences</code> bean定义看不到这些变化状态,因为他们是特定于一个单独的HTTP会话。当HTTP会话最终被丢弃时，限定在该特定HTTP会话范围内的bean也被丢弃。</p>
<p>在使用注释驱动的组件或Java配置时，可以使用<code>@SessionScope</code>注释将组件分配给会话作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SessionScope</span><br><span class="line">@Component</span><br><span class="line">public class UserPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-3-Application-Scope"><a href="#8-3-Application-Scope" class="headerlink" title="8.3 Application Scope"></a>8.3 Application Scope</h4><p>Spring容器通过对整个web应用程序使用一次<code>AppPreferences bean</code>定义来创建一个<code>AppPreferences bean</code>的新实例。也就是说，<code>appPreferences bean</code>的作用域在<code>ServletContext</code>级别，并存储为一个常规<code>ServletContext</code>属性。这有点类似于弹簧单例bean,但在两个重要方面不同:它是一个单例每<code>ServletContext</code>不是每<code>Spring ApplicationContext</code>(可能有几个在任何给定的web应用程序),它实际上是暴露,因此可见<code>ServletContext</code>属性。</p>
<p>在使用注释驱动的组件或Java配置时，可以使用<code>@ApplicationScope</code>注释将组件分配给应用程序范围。下面的例子展示了如何做到这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApplicationScope</span><br><span class="line">@Component</span><br><span class="line">public class AppPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-4-WebSocket-Scope"><a href="#8-4-WebSocket-Scope" class="headerlink" title="8.4 WebSocket Scope"></a>8.4 WebSocket Scope</h4><p>WebSocket作用域与WebSocket会话的生命周期相关，适用于WebSocket上的STOMP应用程序，更多细节请参阅<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-websocket-scope">WebSocket作用域</a>。</p>
<h3 id="9-Customizing-the-Nature-of-a-Bean-定制Bean的性质"><a href="#9-Customizing-the-Nature-of-a-Bean-定制Bean的性质" class="headerlink" title="9. Customizing the Nature of a Bean(定制Bean的性质)"></a>9. Customizing the Nature of a Bean(定制Bean的性质)</h3><p>Spring框架提供了许多接口，您可以使用这些接口来定制bean的性质。本节将它们分组如下:</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle">Lifecycle Callbacks</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aware-list">Other <code>Aware</code> Interfaces</a></li>
</ul>
<h4 id="9-1-Lifecycle-Callbacks"><a href="#9-1-Lifecycle-Callbacks" class="headerlink" title="9.1 Lifecycle Callbacks"></a>9.1 Lifecycle Callbacks</h4><p>要与容器对bean生命周期的管理交互，你可以实现Spring InitializingBean和DisposableBean接口。容器对前者调用afterPropertiesSet()，对后者调用destroy()，让bean在初始化和销毁bean时执行某些操作。</p>
<blockquote>
<p>JSR-250 <code>@PostConstruct</code>和<code>@PreDestroy</code>注释通常被认为是现代Spring应用程序中接收生命周期回调的最佳实践。使用这些注释意味着您的bean没有耦合到特定于spring的接口。详细信息请参见使用<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations">Using <code>@PostConstruct</code> and <code>@PreDestroy</code></a>。</p>
<p>如果你不想使用JSR-250注释，但是你仍然想要移除耦合，考虑 <code>init-method</code> 和 <code>destroy-method</code> bean定义元数据。</p>
</blockquote>
<p>在内部，Spring框架使用<code>BeanPostProcessor</code>实现来处理它可以找到并调用适当方法的任何回调接口。如果您需要定制特性或Spring默认不提供的其他生命周期行为，您可以自己实现<code>BeanPostProcessor</code>。有关更多信息，请参见<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension">Container Extension Points</a>。</p>
<p>除了初始化和销毁回调，spring管理的对象还可以实现<code>Lifecycle</code>接口，这样这些对象就可以参与启动和关闭过程，这是由容器自己的生命周期驱动的。</p>
<p>本节介绍生命周期回调接口。</p>
<h5 id="9-1-1-Initialization-Callbacks"><a href="#9-1-1-Initialization-Callbacks" class="headerlink" title="9.1.1 Initialization Callbacks"></a>9.1.1 Initialization Callbacks</h5><p><code>initializingbean</code>接口允许bean在容器设置完bean上所有必要的属性后执行初始化工作。<code>InitializingBean</code>接口指定了一个单一的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void afterPropertiesSet() throws Exception;</span><br></pre></td></tr></table></figure>

<p>我们建议您不要使用<code>InitializingBean</code>接口，因为它不必要地将代码耦合到Spring。另外，我们建议使用<code>@PostConstruct</code>注释或指定POJO初始化方法。在基于xml的配置元数据的情况下，可以使用<code>init-method</code>属性指定具有空无参数签名的方法的名称。在Java配置中，您可以使用<code>@Bean</code>的<code>initMethod</code>属性。请参见接收生命周期回调。考虑以下例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        // do some initialization work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子和下面的例子(包含两个清单)效果几乎完全相同:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AnotherExampleBean implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        // do some initialization work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，前面两个示例中的第一个并没有将代码与Spring耦合起来。(后一个继承了<code>InitializingBean</code>)</p>
<h5 id="9-1-2-Destruction-Callbacks"><a href="#9-1-2-Destruction-Callbacks" class="headerlink" title="9.1.2 Destruction Callbacks"></a>9.1.2 Destruction Callbacks</h5><p>实现这个接口（ <code>org.springframework.beans.factory.DisposableBean</code>）可以让bean在容器销毁时获得回调函数。DisposableBean接口指定了一个单独的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void destroy() throws Exception;</span><br></pre></td></tr></table></figure>

<p>我们建议您不要使用DisposableBean回调接口，因为它不必要地将代码与Spring耦合起来。另外，我们建议使用@PreDestroy注释或指定bean定义支持的泛型方法。使用基于xml的配置元数据，可以在<bean>上使用destroy-method属性。在Java配置中，您可以使用@Bean的destroyMethod属性。请参见接收生命周期回调。考虑以下定义:</bean></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    public void cleanup() &#123;</span><br><span class="line">        // do some destruction work (like releasing pooled connections)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的定义与下面的定义具有几乎完全相同的效果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AnotherExampleBean implements DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        // do some destruction work (like releasing pooled connections)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，前面两个定义中的第一个并没有将代码与Spring耦合起来。</p>
<blockquote>
<p>……此外本节还有一些没有摘录</p>
</blockquote>
<h5 id="9-1-3-Combining-Lifecycle-Mechanisms（结合生命周期机制）"><a href="#9-1-3-Combining-Lifecycle-Mechanisms（结合生命周期机制）" class="headerlink" title="9.1.3 Combining Lifecycle Mechanisms（结合生命周期机制）"></a>9.1.3 Combining Lifecycle Mechanisms（结合生命周期机制）</h5><p>在Spring 2.5中，你有三个控制bean生命周期行为的选项:</p>
<ul>
<li><code>InitializingBean</code>和<code>DisposableBean</code>回调接口</li>
<li>自定义<code>init()</code>和<code>destroy()</code>方法</li>
<li><code>@PostConstruct</code>和<code>@PreDestroy</code>注释。您可以组合这些机制来控制给定的bean。</li>
</ul>
<h5 id="9-1-4-Startup-and-Shutdown-Callbacks"><a href="#9-1-4-Startup-and-Shutdown-Callbacks" class="headerlink" title="9.1.4 Startup and Shutdown Callbacks"></a>9.1.4 Startup and Shutdown Callbacks</h5><p><code>Lifecycle</code>接口为任何有自己生命周期需求的对象定义了基本方法(比如启动和停止一些后台进程):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Lifecycle &#123;</span><br><span class="line"></span><br><span class="line">    void start();</span><br><span class="line"></span><br><span class="line">    void stop();</span><br><span class="line"></span><br><span class="line">    boolean isRunning();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何spring管理的对象都可以实现<code>Lifecycle</code>接口。然后，当<code>ApplicationContext</code>本身接收到启动和停止信号时(例如，对于运行时的停止/重启场景)，它将这些调用级联到在该上下文中定义的所有<code>Lifecycle</code>实现。它通过委托给<code>LifecycleProcessor</code>来实现，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface LifecycleProcessor extends Lifecycle &#123;</span><br><span class="line"></span><br><span class="line">    void onRefresh();</span><br><span class="line"></span><br><span class="line">    void onClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="9-1-5-Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications"><a href="#9-1-5-Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications" class="headerlink" title="9.1.5 Shutting Down the Spring IoC Container Gracefully in Non-Web Applications"></a>9.1.5 Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</h5><p>本节讲述了在非 web 应用程序中优雅地关闭 Spring IoC 容器，我个人认为这里暂时用的不多，以后有需要再看。</p>
<h3 id="10-Container-Extension-Points（扩展容器）"><a href="#10-Container-Extension-Points（扩展容器）" class="headerlink" title="10 . Container Extension Points（扩展容器）"></a>10 . Container Extension Points（扩展容器）</h3><h4 id="10-1-Customizing-Beans-by-Using-a-BeanPostProcessor"><a href="#10-1-Customizing-Beans-by-Using-a-BeanPostProcessor" class="headerlink" title="10.1 Customizing Beans by Using a BeanPostProcessor"></a>10.1 Customizing Beans by Using a <code>BeanPostProcessor</code></h4><p><code>BeanPostProcessor</code>接口定义了回调方法，您可以实现这些方法来提供您自己的(或覆盖容器的默认值)实例化逻辑、依赖关系解析逻辑，等等。如果您想在Spring容器完成实例化、配置和初始化bean之后实现一些自定义逻辑，您可以插入一个或多个自定义<code>BeanPostProcessor</code>实现。</p>
<p>您可以配置多个BeanPostProcessor实例，并且可以通过设置order属性来控制这些<code>BeanPostProcessor</code>实例运行的顺序。只有当<code>BeanPostProcessor</code>实现了<code>Ordered</code>接口时，才能设置此属性。如果编写自己的<code>BeanPostProcessor</code>，还应该考虑实现<code>Ordered</code>接口。要了解更多细节，请参阅<code>BeanPostProcessor</code>和<code>Ordered</code>接口的javadoc。请参见有关<code>BeanPostProcessor</code>实例的编程式注册的说明。</p>
<h4 id="10-2-Example-Hello-World-BeanPostProcessor-style"><a href="#10-2-Example-Hello-World-BeanPostProcessor-style" class="headerlink" title="10.2 Example: Hello World, BeanPostProcessor-style"></a>10.2 Example: Hello World, <code>BeanPostProcessor</code>-style</h4><p>下面的例子展示了如何在<code>ApplicationContext</code>中编写、注册和使用<code>BeanPostProcessor</code>实例。</p>
<p>第一个示例演示了基本用法。这个例子展示了一个自定义的BeanPostProcessor实现，它在容器创建每个bean时调用它的toString()方法，并将结果字符串打印到系统控制台。</p>
<p>下面的清单显示了自定义的BeanPostProcessor实现类定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package scripting;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line">public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    // simply return the instantiated bean as-is</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line">        return bean; // we could potentially return any object reference here...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) &#123;</span><br><span class="line">        System.out.println(&quot;Bean &#x27;&quot; + beanName + &quot;&#x27; created : &quot; + bean.toString());</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的bean元素使用了<code>InstantiationTracingBeanPostProcessor</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:lang=&quot;http://www.springframework.org/schema/lang&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/lang</span><br><span class="line">        https://www.springframework.org/schema/lang/spring-lang.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;lang:groovy id=&quot;messenger&quot;</span><br><span class="line">            script-source=&quot;classpath:org/springframework/scripting/groovy/Messenger.groovy&quot;&gt;</span><br><span class="line">        &lt;lang:property name=&quot;message&quot; value=&quot;Fiona Apple Is Just So Dreamy.&quot;/&gt;</span><br><span class="line">    &lt;/lang:groovy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    when the above bean (messenger) is instantiated, this custom</span><br><span class="line">    BeanPostProcessor implementation will output the fact to the system console</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean class=&quot;scripting.InstantiationTracingBeanPostProcessor&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>注意<code>InstantiationTracingBeanPostProcesso</code>r是如何定义的。它甚至没有名称，而且，因为它是一个bean，所以可以像其他任何bean一样进行依赖注入。(前面的配置还定义了一个由Groovy脚本支持的bean。Spring的动态语言支持将在<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/languages.html#dynamic-language">“动态语言支持”</a>一章中详细介绍。)</p>
<p>以下Java应用程序运行上述代码和配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.springframework.scripting.Messenger;</span><br><span class="line"></span><br><span class="line">public final class Boot &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) throws Exception &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;scripting/beans.xml&quot;);</span><br><span class="line">        Messenger messenger = ctx.getBean(&quot;messenger&quot;, Messenger.class);</span><br><span class="line">        System.out.println(messenger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述应用程序的输出如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bean &#x27;messenger&#x27; created : org.springframework.scripting.groovy.GroovyMessenger@272961</span><br><span class="line">org.springframework.scripting.groovy.GroovyMessenger@272961</span><br></pre></td></tr></table></figure>



<h4 id="10-3-Example-The-Class-Name-Substitution-PropertySourcesPlaceholderConfigurer"><a href="#10-3-Example-The-Class-Name-Substitution-PropertySourcesPlaceholderConfigurer" class="headerlink" title="10.3 Example: The Class Name Substitution PropertySourcesPlaceholderConfigurer"></a>10.3 Example: The Class Name Substitution <code>PropertySourcesPlaceholderConfigurer</code></h4><p>您可以使用<code>propertysourcesconfigururer</code>来通过使用标准Java Properties格式将bean定义中的属性值外部化到单独的文件中。这样一来，部署应用程序的人员就可以定制特定于环境的属性，如数据库url和密码，而无需修改主XML定义文件或容器文件，从而避免了复杂性或风险。</p>
<p>参考以下基于xml的配置元数据片段，其中定义了一个具有占位符值的数据源:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;locations&quot; value=&quot;classpath:com/something/jdbc.properties&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;dataSource&quot; destroy-method=&quot;close&quot;</span><br><span class="line">        class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>该示例显示了从外部properties文件配置的属性。在运行时，<code>propertysourcesconfigururer</code>被应用于元数据，用来替换数据源的一些属性。要替换的值被指定为<code>$&#123;property-name&#125;</code>形式的占位符，它遵循Ant、log4j和JSP EL风格。</p>
<p>实际值来自另一个标准Java <code>Properties</code>格式的文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driverClassName=org.hsqldb.jdbcDriver</span><br><span class="line">jdbc.url=jdbc:hsqldb:hsql://production:9002</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>



<h3 id="11-Annotation-based-Container-Configuration"><a href="#11-Annotation-based-Container-Configuration" class="headerlink" title="11.  Annotation-based Container Configuration"></a>11.  Annotation-based Container Configuration</h3><blockquote>
<p>​                                                                        <strong>注解是否比XML更适合配置Spring?</strong></p>
<p>基于注释的配置的引入提出了这样一个问题:这种方法是否比XML“更好”。简短的回答是“视情况而定”。长一点的答案是，每种方法都有其优点和缺点，通常，这取决于开发人员决定哪种策略更适合他们。由于注解的定义方式，注解在其声明中提供了大量的上下文，从而使配置更短、更简洁。但是，XML擅长在不修改源代码或重新编译它们的情况下连接组件。一些开发人员更喜欢将连接连接到源代码附近，而另一些开发人员则认为，带注释的类不再是pojo，而且，配置变得分散，更难控制。</p>
<p>无论选择什么，Spring都可以容纳这两种风格，甚至可以将它们混合在一起。值得指出的是，通过它的JavaConfig选项，Spring允许以一种非侵入性的方式使用注释，而不涉及目标组件源代码。</p>
</blockquote>
<p>一如既往，您可以将后处理器注册为单独的 bean 定义，但也可以通过在基于 xml 的 Spring 配置中包含以下标记来隐式注册它们(注意包含上下文名称空间) :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;context:annotation-config/&gt;</code>元素隐式地注册了以下的后处理器:</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/context/annotation/ConfigurationClassPostProcessor.html"><code>ConfigurationClassPostProcessor</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/context/event/EventListenerMethodProcessor.html"><code>EventListenerMethodProcessor</code></a></li>
</ul>
<blockquote>
<p>&lt;仅在定义注解的应用程序上下文中查找bean上的注解。这意味着，如果你把<code>&lt;context:annotation-config/&gt;</code>放在一个<code>DispatcherServlet</code>的<code>WebApplicationContext</code>中，它只检查你的控制器中的<code>@Autowired</code> bean，而不是你的服务。更多信息请参见<code>DispatcherServlet</code>。</p>
</blockquote>
<p><strong>注释的相关讲解参考Spring官方文档</strong></p>
<h4 id="11-1-Resource和-Autowired的区别"><a href="#11-1-Resource和-Autowired的区别" class="headerlink" title="11.1 @Resource和@Autowired的区别"></a>11.1 <code>@Resource</code>和<code>@Autowired</code>的区别</h4><p>参考：<a href="https://blog.csdn.net/weixin_40906484/article/details/113937179">https://blog.csdn.net/weixin_40906484/article/details/113937179</a></p>
<h4 id="11-2-基于自定义注解的依赖注入"><a href="#11-2-基于自定义注解的依赖注入" class="headerlink" title="11.2 基于自定义注解的依赖注入"></a>11.2 基于自定义注解的依赖注入</h4><p>您可以创建自己的自定义限定符注释。要做到这一点，请定义一个注释，并在定义中提供<code>@Qualifier</code>注释，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface Genre &#123;</span><br><span class="line"></span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以在自动连接的字段和参数上提供自定义限定符，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Genre(&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionCatalog;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog comedyCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setComedyCatalog(@Genre(&quot;Comedy&quot;) MovieCatalog comedyCatalog) &#123;</span><br><span class="line">        this.comedyCatalog = comedyCatalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，您可以为候选bean定义提供信息。您可以将<code>&lt;qualifier/&gt;</code>标记添加为<code>&lt;bean/&gt;</code>标记的子元素，然后指定类型和值，以匹配您的自定义限定符注释。该类型与注释的完全限定类名相匹配。另外，如果不存在名称冲突的风险，为了方便起见，可以使用简短的类名。下面的例子演示了这两种方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;Genre&quot; value=&quot;Action&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;example.Genre&quot; value=&quot;Comedy&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;movieRecommender&quot; class=&quot;example.MovieRecommender&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>还可以定义自定义限定符注释，在简单的value属性之外或之外接受命名属性。<strong>如果在一个要自动连接的字段或参数上指定了多个属性值，那么bean定义必须匹配所有这些属性值，才能被视为自动连接候选属性</strong>。例如，参考以下注释定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface MovieQualifier &#123;</span><br><span class="line"></span><br><span class="line">    String genre();</span><br><span class="line"></span><br><span class="line">    Format format();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>Format</code>是一个enum，定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Format &#123;</span><br><span class="line">    VHS, DVD, BLURAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要自动连接的字段用自定义限定符标注，并包含两个属性的值:<code>genre</code>和<code>format</code>，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.DVD, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionDvdCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.BLURAY, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyBluRayCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，bean定义应该包含匹配的限定符值。这个例子还演示了您可以使用bean的元属性而不是<code>&lt;qualifier/&gt;</code>元素。如果可用，<code>&lt;qualifier/&gt;</code>元素及其属性优先，但如果没有这样的限定符，自动组合机制将返回到<code>&lt;meta/&gt;</code>标记中提供的值，就像下面示例中的最后两个bean定义一样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;</span><br><span class="line">            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;</span><br><span class="line">            &lt;attribute key=&quot;genre&quot; value=&quot;Action&quot;/&gt;</span><br><span class="line">        &lt;/qualifier&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;</span><br><span class="line">            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;</span><br><span class="line">            &lt;attribute key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;</span><br><span class="line">        &lt;/qualifier&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;meta key=&quot;format&quot; value=&quot;DVD&quot;/&gt;</span><br><span class="line">        &lt;meta key=&quot;genre&quot; value=&quot;Action&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;meta key=&quot;format&quot; value=&quot;BLURAY&quot;/&gt;</span><br><span class="line">        &lt;meta key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<h3 id="12-AOP-Concepts"><a href="#12-AOP-Concepts" class="headerlink" title="12. AOP Concepts"></a>12. AOP Concepts</h3><p>相关术语：</p>
<h5 id="1-通知（Advice）"><a href="#1-通知（Advice）" class="headerlink" title="1.通知（Advice）"></a>1.通知（Advice）</h5><p>　　就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。</p>
<h5 id="2-连接点（JoinPoint）"><a href="#2-连接点（JoinPoint）" class="headerlink" title="2.连接点（JoinPoint）"></a>2.连接点（JoinPoint）</h5><p>　　这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。</p>
<h5 id="3-切入点（Pointcut）"><a href="#3-切入点（Pointcut）" class="headerlink" title="3.切入点（Pointcut）"></a>3.切入点（Pointcut）</h5><p>　　上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。</p>
<h5 id="4-切面（Aspect）"><a href="#4-切面（Aspect）" class="headerlink" title="4.切面（Aspect）"></a>4.切面（Aspect）</h5><p>　　切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好<strong>理解</strong>切点，搞出来的，明白这个<strong>概念</strong>就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p>
<h5 id="5-引入（introduction）"><a href="#5-引入（introduction）" class="headerlink" title="5.引入（introduction）"></a>5.引入（introduction）</h5><p>　　允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗</p>
<h5 id="6-目标（target）"><a href="#6-目标（target）" class="headerlink" title="6.目标（target）"></a>6.目标（target）</h5><p>　　引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。</p>
<h5 id="7-代理-proxy"><a href="#7-代理-proxy" class="headerlink" title="7.代理(proxy)"></a>7.代理(proxy)</h5><p>　　怎么实现整套aop机制的，都是通过代理，这个一会给细说。</p>
<h5 id="8-织入-weaving"><a href="#8-织入-weaving" class="headerlink" title="8.织入(weaving)"></a>8.织入(weaving)</h5><p>　　把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。</p>
<p>　　关键就是：切点定义了哪些连接点会得到通知</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
