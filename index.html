<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo32px.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo16px.png">
  <link rel="mask-icon" href="/images/logosvg.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hznu.asia","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="国家地板级演员 GitHub顶级粉丝">
<meta property="og:type" content="website">
<meta property="og:title" content="realhuang">
<meta property="og:url" content="http://hznu.asia/index.html">
<meta property="og:site_name" content="realhuang">
<meta property="og:description" content="国家地板级演员 GitHub顶级粉丝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Huang Rui">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hznu.asia/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>realhuang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="realhuang" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">realhuang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">16</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-sitemap fa-fw"></i>留言</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2023/02/01/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-01 21:16:41" itemprop="dateCreated datePublished" datetime="2023-02-01T21:16:41+08:00">2023-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 21:00:10" itemprop="dateModified" datetime="2023-02-21T21:00:10+08:00">2023-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/02/01/Redis/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/02/01/Redis/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-Redis为什么早期选择单线程？"><a href="#1-Redis为什么早期选择单线程？" class="headerlink" title="1.  Redis为什么早期选择单线程？"></a>1.  Redis为什么早期选择单线程？</h3><p>其实就是历史原因，开发者嫌多线程麻烦，后来这个CPU的利用问题就被抛给了使用者。</p>
<p>Redis 4.0 之后开始变成多线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 Key 的删除等等。</p>
<h3 id="2-Redis6-0使用多线程是怎么回事"><a href="#2-Redis6-0使用多线程是怎么回事" class="headerlink" title="2. Redis6.0使用多线程是怎么回事?"></a>2. Redis6.0使用多线程是怎么回事?</h3><p>其实Redis在执行命令时，使用的还是单线程；在执行I/O和协议解析等操作时，执行的是多线程。</p>
<p>这是因为Redis的性能瓶颈在网络I/O而非CPU。</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b7b24e25-d2dc-4457-994f-95bdb3674b8e.png" alt="Redis6.0多线程" style="zoom:67%;">



<h3 id="3-Redis持久化方式有哪些？有什么区别？"><a href="#3-Redis持久化方式有哪些？有什么区别？" class="headerlink" title="3. Redis持久化方式有哪些？有什么区别？"></a>3. Redis持久化方式有哪些？有什么区别？</h3><p>Redis持久化方式有AOF和RDB。</p>
<ul>
<li><strong>AOF：</strong>以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</li>
<li><strong>RDB：</strong>RDB方式则是将当前数据快照存储到磁盘，分手动触发和自动触发，RDB文件是一个压缩的二进制文件。</li>
</ul>
<h3 id="4-RDB-和-AOF-各自有什么优缺点？"><a href="#4-RDB-和-AOF-各自有什么优缺点？" class="headerlink" title="4. RDB 和 AOF 各自有什么优缺点？"></a>4. RDB 和 AOF 各自有什么优缺点？</h3><p><strong>RDB：</strong></p>
<ul>
<li>优点：<ul>
<li>数据恢复快</li>
<li>容灾性好，可以将备份数据远程拷贝到其他机器，用于容灾恢复</li>
</ul>
</li>
<li>缺点：<ul>
<li>实时性低，RDB并不能做到秒级持久化，而是会间隔一段时间再持久化</li>
</ul>
</li>
</ul>
<p><strong>AOF：</strong></p>
<ul>
<li>优点：<ul>
<li>实时性好</li>
</ul>
</li>
<li>缺点：<ul>
<li>AOF文件较大，并且恢复速度慢</li>
</ul>
</li>
</ul>
<h3 id="5-Redis的主从复制原理了解吗？"><a href="#5-Redis的主从复制原理了解吗？" class="headerlink" title="5. Redis的主从复制原理了解吗？"></a>5. Redis的主从复制原理了解吗？</h3><ol>
<li>首先在从节点（slave）保存主节点的ip和端口号</li>
<li>从节点（slave）发现主节点（master）后，向主节点（master）发送ping请求进行首次通信，本次通信是检测主从之间网络套接字是否可用、主节点当前是否可以接受处理命令。</li>
<li>若主节点要求密码验证，从节点需要发送账号密码用于验证</li>
<li>建立连接后，主节点会把数据全部发送给从节点</li>
<li>之后的主节点会持续把<code>写命令</code>发送给从节点，保证数据一致性</li>
</ol>
<h3 id="6-主从复制存在哪些问题呢？"><a href="#6-主从复制存在哪些问题呢？" class="headerlink" title="6. 主从复制存在哪些问题呢？"></a>6. 主从复制存在哪些问题呢？</h3><p>主从复制虽好，但也存在一些问题：</p>
<ul>
<li>一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预。</li>
<li>主节点的写能力受到单机的限制。</li>
<li>主节点的存储能力受到单机的限制。</li>
</ul>
<p>第一个问题是Redis的高可用问题，第二、三个问题属于Redis的分布式问题。</p>
<h3 id="7-Redis-Sentinel（哨兵）了解吗？"><a href="#7-Redis-Sentinel（哨兵）了解吗？" class="headerlink" title="7. Redis Sentinel（哨兵）了解吗？"></a>7. Redis Sentinel（哨兵）了解吗？</h3><p>主从复制存在一个问题，没法完成自动故障转移。所以我们需要一个方案来完成自动故障转移，它就是Redis Sentinel（哨兵）。</p>
<p>Redis Sentinel ，它由两部分组成，哨兵节点和数据节点：</p>
<ul>
<li><strong>哨兵节点：</strong> 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据，对数据节点进行监控。</li>
<li><strong>数据节点：</strong> 主节点和从节点都是数据节点；</li>
</ul>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-8b1a055c-f077-49ff-9432-c194d4fc3639.png" alt="Redis Sentinel" style="zoom:67%;">



<h3 id="8-什么是缓存击穿、缓存穿透、缓存雪崩？"><a href="#8-什么是缓存击穿、缓存穿透、缓存雪崩？" class="headerlink" title="8. 什么是缓存击穿、缓存穿透、缓存雪崩？"></a>8. 什么是缓存击穿、缓存穿透、缓存雪崩？</h3><ul>
<li><strong>缓存击穿：</strong>缓存击穿是指访问量很大的某个key突然失效，请求一下全部打到数据库。解决方案如下：<ul>
<li>若缓存是基本不更新的，可以设置为永不过期</li>
<li>若缓存中数据经常使用，且为热点数据，那么可以每查询一次便重新更新他的失效时间（我在项目中就是这样做的）</li>
<li>加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了（感觉这样性能比较差）</li>
</ul>
</li>
<li><strong>缓存穿透：</strong>缓存穿透是指查询的是缓存中和数据库都不存在的数据，这样每次请求都打到数据库上。解决方案如下：<ul>
<li>每次都数据库查数据时，如果没查到数据，就写一个空值到缓存中去，再设置一个失效时间，这样再有相同请求走的都是缓存。</li>
</ul>
</li>
<li><strong>缓存雪崩：</strong>缓存雪崩是指大量缓存突然失效，造成大量请求打到数据库<ul>
<li>事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。</li>
<li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。 </li>
<li>事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
</li>
</ul>
<h3 id="9-什么是布隆过滤器？"><a href="#9-什么是布隆过滤器？" class="headerlink" title="9. 什么是布隆过滤器？"></a>9. 什么是布隆过滤器？</h3><p>布隆过滤器，它是一个连续的数据结构，每个存储位存储都是一个<code>bit</code>，即<code>0</code>或者<code>1</code>, 来标识数据是否存在。</p>
<p>存储数据的时时候，使用K个不同的哈希函数将这个变量映射为bit列表的的K个点，把它们置为1。</p>
<p>我们判断缓存key是否存在，同样，K个哈希函数，映射到bit列表上的K个点，判断是不是1：</p>
<ul>
<li>如果全不是1，那么key不存在；</li>
<li>如果都是1，也只是表示key可能存在。</li>
</ul>
<p><strong>简单说，布隆过滤器就是判断某个数据在不在布隆过滤器内，</strong>使用方式如下：</p>
<p>Redis实现布隆过滤器的底层是通过bitmap数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.17.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:26379&quot;);</span><br><span class="line">        config.useSingleServer().setPassword(&quot;myredis&quot;);</span><br><span class="line">        config.useSingleServer().setDatabase(0);</span><br><span class="line">        RedissonClient client = Redisson.create(config);</span><br><span class="line">        RBloomFilter&lt;Object&gt; bloomFilter = client.getBloomFilter(&quot;bloomnumber&quot;);</span><br><span class="line">        // 初始化布隆过滤器，设计预计元素数量为1000000L, 误差率为1%</span><br><span class="line">        int n = 1000000;</span><br><span class="line">        bloomFilter.tryInit(1000000L, 0.01);</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            bloomFilter.add(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; (n*2); i++) &#123;</span><br><span class="line">            if (bloomFilter.contains(String.valueOf(i))) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;过滤器误判率：&quot; + (count - n)/Double.valueOf(n));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>布隆过滤器也有一些缺点：</p>
<ol>
<li>它在判断元素是否在集合中时是有一定错误几率，因为哈希算法有一定的碰撞的概率。</li>
<li>不支持删除元素。</li>
</ol>
<blockquote>
<p>在openArt项目中，我们在判断用户短信验证码是否从夫验证时使用了。</p>
</blockquote>
<h3 id="10-Redis的过期淘汰策略？"><a href="#10-Redis的过期淘汰策略？" class="headerlink" title="10. Redis的过期淘汰策略？"></a>10. Redis的过期淘汰策略？</h3><p>Redis的过期淘汰策略是：<strong>定时删除 + 惰性删除。</strong></p>
<p>Redis的默认定时100ms拿出一批数据来删除其中过期的数据。</p>
<p>但是如果数据量过大，有10wkey，就不可能每次删除都遍历一遍看是否过期然后删除，那样性能消耗过高。所以Redis执行的是<strong>定时随机</strong>抽取一批数据，看里面是否有过期的数据，如果过期，便删除。</p>
<p>但是这样会有大量过期的Key没被删除，这样就会走<strong>内存淘汰策略</strong>。</p>
<p>Redis的内存淘汰策略有以下几种：</p>
<ul>
<li>当内存不足以容纳新写入数据时，新写入操作会报错（很少有人用）</li>
<li>当内存不足以容纳新写入数据时，在键空间内，删除最近最久未使用的key（常用）</li>
<li>当内存不足以容纳新写入数据时，随机干掉某个key（很少有人用）</li>
<li>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近 最少使用的 key（这个一般不太合适）</li>
<li>在设置了过期时间的键空间中，随机 移除某个 key</li>
</ul>
<h3 id="11-Redis报内存不足怎么处理？"><a href="#11-Redis报内存不足怎么处理？" class="headerlink" title="11. Redis报内存不足怎么处理？"></a>11. Redis报内存不足怎么处理？</h3><ul>
<li>增加Redis可用内存</li>
<li>修改内存淘汰策略</li>
<li>使用 Redis 集群模式，进行横向扩容</li>
</ul>
<h3 id="12-大key问题了解吗？"><a href="#12-大key问题了解吗？" class="headerlink" title="12. 大key问题了解吗？"></a>12. 大key问题了解吗？</h3><p><strong>大key的成因：</strong></p>
<ul>
<li>单个的key的value很大，超过10kb</li>
<li>list、set、zset或hash存储了过多元素</li>
</ul>
<p><strong>大key会造成什么问题呢？</strong></p>
<ul>
<li><p>客户端耗时增加，甚至超时</p>
</li>
<li><p>对大key进行IO操作时，会严重占用带宽和CPU</p>
</li>
<li><p>造成Redis集群中数据倾斜</p>
</li>
<li><p>主动删除、被动删等，可能会导致阻塞</p>
</li>
</ul>
<p><strong>如何找到大key?</strong></p>
<ul>
<li>bigkeys命令：使用bigkeys命令以遍历的方式分析Redis实例中的所有Key，并返回整体统计信息与每个数据类型中Top1的大Key</li>
<li>redis-rdb-tools：redis-rdb-tools是由Python写的用来分析Redis的rdb快照文件用的工具，它可以把rdb快照文件生成json文件或者生成报表用来分析Redis的使用详情。</li>
</ul>
<p><strong>怎么处理大key？</strong></p>
<ul>
<li><strong>删除大key</strong><ul>
<li>当Redis版本大于4.0时，可使用UNLINK命令安全地删除大Key，该命令能够以非阻塞的方式，逐步地清理传入的Key。</li>
<li>当Redis版本小于4.0时，避免使用阻塞式命令KEYS，而是建议通过SCAN命令执行增量迭代扫描key，然后判断进行删除。</li>
</ul>
</li>
<li><strong>压缩和拆分key</strong><ul>
<li>当vaule是string时，比较难拆分，则使用序列化、压缩算法将key的大小控制在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗。</li>
<li>当value是string，压缩之后仍然是大key，则需要进行拆分，一个大key分为不同的部分，记录每个部分的key，使用multiget等操作实现事务读取。</li>
<li>当value是list/set等集合类型时，根据预估的数据规模来进行分片，不同的元素计算后分到不同的片。</li>
</ul>
</li>
</ul>
<h3 id="13-Redis底层数据结构有哪些，编码方式有哪些？"><a href="#13-Redis底层数据结构有哪些，编码方式有哪些？" class="headerlink" title="13. Redis底层数据结构有哪些，编码方式有哪些？"></a>13. Redis底层数据结构有哪些，编码方式有哪些？</h3><ul>
<li><strong>底层数据结构：</strong>ZipList、SDS、SkipList、ht（字典）、list、intset（整数集合）</li>
</ul>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-7cf91aa9-8db5-4abe-803e-a9e8f3bcb9e4.png" alt="类型-编码-结构" style="zoom:67%;">

<h3 id="14-假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#14-假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="14. 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>14. 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h3><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2023/01/26/Mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/26/Mybatis/" class="post-title-link" itemprop="url">Mybatis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-26 11:32:37" itemprop="dateCreated datePublished" datetime="2023-01-26T11:32:37+08:00">2023-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-20 21:05:30" itemprop="dateModified" datetime="2023-02-20T21:05:30+08:00">2023-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/01/26/Mybatis/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/01/26/Mybatis/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-MyBatis使用过程？生命周期？"><a href="#1-MyBatis使用过程？生命周期？" class="headerlink" title="1. MyBatis使用过程？生命周期？"></a>1. MyBatis使用过程？生命周期？</h3><ul>
<li>1）创建SqlSessionFactory</li>
</ul>
<p>可以从配置或者直接编码来创建SqlSessionFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<ul>
<li>2）通过SqlSessionFactory创建SqlSession</li>
</ul>
<p>SqlSession（会话）可以理解为程序和数据库之间的桥梁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<ul>
<li>3）通过sqlsession执行数据库操作</li>
</ul>
<p>可以通过 SqlSession 实例来直接执行已映射的 SQL 语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blog blog = (Blog)session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<p>更常用的方式是先获取Mapper(映射)，然后再执行SQL语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>4）调用session.commit()提交事务</li>
</ul>
<p>如果是更新、删除语句，我们还需要提交一下事务。</p>
<ul>
<li>5）调用session.close()关闭会话</li>
</ul>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/mybatis-47bab2e8-5c08-4f61-9c0c-dddfe09fb2b5.png" alt="Mybatis基本使用步骤" style="zoom:67%;">

<p><strong>MyBatis生命周期：</strong>上面提到了几个MyBatis的组件，一般说的MyBatis生命周期就是这些组件的生命周期</p>
<ul>
<li><strong>SqlSessionBuilder：</strong>生命周期是方法级的，因为创建完成SqlSeesionFactory后就不需要了</li>
<li><strong>SqlSeesionFactory：</strong>生命周期是贯穿整个应用生命周期的，相当于数据库连接池，并且单例</li>
<li><strong>SqlSession：</strong>非线程安全，不能共享，所以最佳生命周期是一次请求或一个方法</li>
<li><strong>Mapper：</strong>映射器接口的实例是从 SqlSession 中获得的，它的生命周期在sqlsession事务方法之内，一般会控制在方法级。</li>
</ul>
<h3 id="2-和-的区别"><a href="#2-和-的区别" class="headerlink" title="2. #{}和${}的区别"></a>2. <code>#&#123;&#125;和$&#123;&#125;的区别</code></h3><p><code>#&#123;&#125;</code> 匹配的是一个占位符，相当于 JDBC 中的一个?，会对一些敏感字符进行过滤，编译过后会对传递的值加上双引号，因此可以防止 SQL 注入问题。</p>
<p><code>$&#123;&#125;</code> 匹配的是真实传递的值，<strong>传递过后，会与 SQL 语句进行字符串拼接</strong>。${} 会与其他 SQL 进行字符串拼接，无法防止 SQL 注入问题。</p>
<ul>
<li><p>#{}会进行预编译处理，${}是拼接符，字符串替换，不进行预编译处理</p>
</li>
<li><p>#{}可以防止Sql注入</p>
</li>
<li><p>#{}替换在DBMS内，${}替换在DBMS外</p>
</li>
<li><p>Mybatis在处理<code>#&#123;&#125;</code>时，<code>#&#123;&#125;</code>传入参数是以字符串传入，会将SQL中的<code>#&#123;&#125;</code>替换为?号，调用PreparedStatement的set方法来赋值。</p>
</li>
</ul>
<h3 id="3-MyBatis是否支持延迟加载？原理？"><a href="#3-MyBatis是否支持延迟加载？原理？" class="headerlink" title="3. MyBatis是否支持延迟加载？原理？"></a>3. MyBatis是否支持延迟加载？原理？</h3><p>支持，并且Hibernate等也支持，原理如下：</p>
<p>首先Cglib生成目标对象的代理对象，当调用目标方法时进入拦截，比如调用的是<code>A.getB().getName</code>，拦截器如果发现<code>A.getB()</code>为空，则会首先保存好需要B对象才能查询的Sql，然后等查询到B后，调用 <code>A.setB(b)</code>，将其注入A中，此时B不为空，再执行<code>A.getB().getName</code>。这就是延迟加载的基本原理。</p>
<h3 id="4-说说Mybatis的一级、二级缓存？"><a href="#4-说说Mybatis的一级、二级缓存？" class="headerlink" title="4. 说说Mybatis的一级、二级缓存？"></a>4. 说说Mybatis的一级、二级缓存？</h3><ul>
<li><code>一级缓存</code>是 SqlSession 级别的缓存。在操作数据库时需要构造 SqlSession 对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的是 SqlSession 之间的缓存数据区（HashMap）是互相不影响，MyBatis默认开启一级缓存。</li>
<li><code>二级缓存</code>是 Mapper 级别的缓存，多个 SqlSession 去操作同一个 Mapper 的 sql 语句，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。</li>
</ul>
<h3 id="5-能说说MyBatis的工作原理吗？"><a href="#5-能说说MyBatis的工作原理吗？" class="headerlink" title="5. 能说说MyBatis的工作原理吗？"></a>5. 能说说MyBatis的工作原理吗？</h3><ol>
<li>读取 MyBatis 配置文件——mybatis-config.xml 、加载映射文件——映射文件即 SQL 映射文件，文件中配置了操作数据库的 SQL 语句。最后生成一个配置对象。</li>
<li>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</li>
<li>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</li>
<li>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</li>
<li>StatementHandler：数据库会话器，串联起参数映射的处理和运行结果映射的处理。</li>
<li>参数处理：对输入参数的类型进行处理，并预编译。</li>
<li>结果处理：对返回结果的类型进行处理，根据对象映射规则，返回相应的对象</li>
</ol>
<h3 id="6-PageHelper分页原理？"><a href="#6-PageHelper分页原理？" class="headerlink" title="6. PageHelper分页原理？"></a>6. PageHelper分页原理？</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a578977626/article/details/122355025">https://blog.csdn.net/a578977626/article/details/122355025</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2023/01/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-14 16:44:07" itemprop="dateCreated datePublished" datetime="2023-01-14T16:44:07+08:00">2023-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-20 11:27:23" itemprop="dateModified" datetime="2023-02-20T11:27:23+08:00">2023-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/01/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/01/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-从浏览器地址栏输入-url-到显示主页的过程？"><a href="#1-从浏览器地址栏输入-url-到显示主页的过程？" class="headerlink" title="1. 从浏览器地址栏输入 url 到显示主页的过程？"></a>1. 从浏览器地址栏输入 url 到显示主页的过程？</h3><ol>
<li>DNS解析。首先将域名发到DNS服务器，解析获取IP地址。</li>
<li>TCP连接。与服务器进行三次TCP握手，获取连接。</li>
<li>向目标服务器发起HTTP请求。</li>
<li>目标服务器处理HTTP请求，返回响应内容。</li>
<li>拿到响应内容后，浏览器解析响应内容渲染到网页上。</li>
<li>TCP四次回收，结束连接。</li>
</ol>
<h3 id="2-说说DNS解析的过程？"><a href="#2-说说DNS解析的过程？" class="headerlink" title="2. 说说DNS解析的过程？"></a>2. 说说DNS解析的过程？</h3><p>假如要查询<a href="http://www.baidu.com的IP地址：">www.baidu.com的IP地址：</a></p>
<ol>
<li>首先主机向本地DNS服务器发起查询，假如本地DNS服务器有缓存，则之间返回，否则进行下一步。</li>
<li>主机向根服务器发起请求，根服务器返回所有带<code>com</code>的<strong>顶级域名服务器的IP地址列表</strong>。</li>
<li>本地DNS服务器再向一个负责<code>com</code>的顶级域名服务器发送请求，返回负责<code>baidu.com</code> 的<strong>权限域名服务器的IP地址列表</strong>。</li>
<li>本地DNS服务器再向一个负责 <code>baidu.com</code> 的权限域名服务器发送请求，返回 <code>www.baidu.com</code> 对应的IP地址。</li>
</ol>
<h3 id="3-WebSocket和Socket的区别？"><a href="#3-WebSocket和Socket的区别？" class="headerlink" title="3. WebSocket和Socket的区别？"></a>3. WebSocket和Socket的区别？</h3><ul>
<li>Socket相当于IP+端口+协议，屏蔽了网络的细节，是一个接口。</li>
<li>而WebSocket则是解决HTTP不能持久化连接的问题，用于通信层，是一个通信协议。</li>
</ul>
<h3 id="4-Get和Post请求的区别？"><a href="#4-Get和Post请求的区别？" class="headerlink" title="4. Get和Post请求的区别？"></a>4. Get和Post请求的区别？</h3><p>Get能被CDN缓存，Post不会。</p>
<p>Get具有幂等性，更安全。</p>
<p>Get有长度限制，Post没有。</p>
<h3 id="5-URL和URI的区别？"><a href="#5-URL和URI的区别？" class="headerlink" title="5. URL和URI的区别？"></a>5. URL和URI的区别？</h3><ul>
<li>URI：统一资源定位符。URI的重点是在于标识资源，它其实是一个抽象定义，无论用什么方式来实现，只要可以唯一标识一个资源，都可以叫做URI。</li>
<li>URL：它是 URI 的一种子集，主要作用是提供资源的路径。</li>
</ul>
<blockquote>
<p>它们的主要区别在于，URL 除了提供了资源的标识，还提供了资源访问的方式。这么比喻，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人——人类住址协议://地球/中国/北京市/海淀区/xx 职业技术学院/14 号宿舍楼/525 号寝/张三.男。</p>
</blockquote>
<h3 id="6-说下-HTTP-1-0，1-1，2-0-以及HTTP3的区别？"><a href="#6-说下-HTTP-1-0，1-1，2-0-以及HTTP3的区别？" class="headerlink" title="6. 说下 HTTP/1.0，1.1，2.0 以及HTTP3的区别？"></a>6. 说下 HTTP/1.0，1.1，2.0 以及HTTP3的区别？</h3><p>关键需要记住 <strong>HTTP/1.0</strong> 默认是短连接，可以强制开启，HTTP/1.1 默认长连接，HTTP/2.0 采用<strong>多路复用</strong>。</p>
<ul>
<li> <strong>HTTP/1.0：</strong></li>
<li>默认短连接，可以开启长连接。</li>
<li> <strong>HTTP 1.1：</strong></li>
<li>引入了持久化连接，即 TCP 连接默认不关闭，可以被多个请求复用。</li>
<li>分块传输编码，即服务端每产生一块数据，就发送一块，用” 流模式” 取代” 缓存模式”。</li>
<li>管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求。</li>
<li> <strong>HTTP 2.0：</strong></li>
<li>报头压缩，每次请求都必须附上所有信息。HTTP/2.0 引入了头信息压缩机制，使用 gzip 或 compress 压缩后再发送</li>
<li>完全多路复用，客户端和服务端都可以同时发送多个请求，而且不用按照顺序一一对应</li>
<li>服务端推送，运行服务端不经请求，主动向客户端发送消息</li>
<li><strong>HTTP 3：</strong><ul>
<li>使用UDP传输，并且使用QUIC协议保证安全性，在传输的过程中就完成了 TLS 加密握手</li>
<li>HTTPS 要建立⼀个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 <strong>3</strong> 次，减少了交互次数。</li>
<li>QUIC 有自己的⼀套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。</li>
</ul>
</li>
</ul>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-9384b248-3ea3-4437-b343-f8b7e73f9157.jpg" alt="HTTP 协议变迁" style="zoom:50%;">



<h3 id="7-HTTPS-工作流程是怎样的？"><a href="#7-HTTPS-工作流程是怎样的？" class="headerlink" title="7. HTTPS 工作流程是怎样的？"></a>7. HTTPS 工作流程是怎样的？</h3><ol>
<li>客户端向服务端发起HTTPS请求，连接到服务端的443端口</li>
<li>服务端收到请求后，将证书发送给客户端（公钥在证书中，私钥服务端持有）</li>
<li>客户端收到后，会验证证书的合法性。验证通过后，生成一个随机对称密匙，使用证书中的公钥进行加密，加密后发送给服务端</li>
<li>服务端收到后，使用自己的私钥进行非对称解密，解密后得到客户端的密匙，这样用客户端密匙对称加密传输数据，传输的数据就是密文</li>
<li>服务端收到客户端用密文加密过的数据后，再使用自己的密匙解密就得到了数据</li>
</ol>
<h3 id="8-客户端怎么去校验证书的合法性？"><a href="#8-客户端怎么去校验证书的合法性？" class="headerlink" title="8. 客户端怎么去校验证书的合法性？"></a>8. 客户端怎么去校验证书的合法性？</h3><p><strong>CA证书的形成过程如下：</strong></p>
<ul>
<li>在CA证书的签发过程中给，客户端会将密匙、有效时间、用途、颁发者等信息打成一个包，然后将这些信息进行Hash计算，得到一个Hash值。</li>
<li>然后使用自己的私匙对这些信息加密，加密后生成 <code>Certificate Signature</code>，也就是对证书做了签名，</li>
<li>然后将其添加在证书上，形成了数字证书。</li>
</ul>
<p><strong>客户端校验服务端的数字证书的过程如下：</strong></p>
<p>客户端首先会根据相同的Hash算法获取该证书的Hash值H1</p>
<p>浏览器使用自身集成的CA证书的公钥信息，解密证书，得到H2</p>
<p>比较H1和H2就可以知道证书是否合法</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-77213977-9def-4118-b125-a26e8737d423.jpg" alt="证书签名和客户端校验-来源参考" style="zoom:50%;">



<h3 id="8-对称加密和非对称加密？"><a href="#8-对称加密和非对称加密？" class="headerlink" title="8. 对称加密和非对称加密？"></a>8. 对称加密和非对称加密？</h3><p><strong>密匙不同：</strong>对称加密加密和解密用的都是一个密匙，非对称加密加密和解密的密匙不一样</p>
<p><strong>安全性不同：</strong>对称加密加密解密密匙都是同一个，安全性不够。而非对称加密有公匙和私匙，公匙是可以给别人看的，私匙是对方持有用来解密的。</p>
<p><strong>数字签名不同：</strong>对称加密不可以用于数字签名和数字鉴别，非对称加密可以用于数字签名和数字鉴别</p>
<h3 id="9-MD5属于那种加密算法"><a href="#9-MD5属于那种加密算法" class="headerlink" title="9. MD5属于那种加密算法?"></a>9. MD5属于那种加密算法?</h3><p>MD5加密既不是对称加密，也不是非对称加密。</p>
<p>MD5具有计算速度快，加密速度快，不需要密匙等优点。可以检查文件的完整性，一旦文件被更改，MD5值会发生改变。</p>
<p>但是MD5也有缺点，比如很多公司数据库存放的密码都是MD5加密后的，假如密码较为简单，攻击者会将一些常见的密码进行MD5计算，然后与数据库中的MD5比较，相同便获取了密码。</p>
<h3 id="10-TCP的三次握手？"><a href="#10-TCP的三次握手？" class="headerlink" title="***10. TCP的三次握手？"></a>***10. TCP的三次握手？</h3><p>最开始，客户端和服务端都处于close状态，服务端监听客户端请求，服务端进入 LISTEN 状态</p>
<p>首先，客户端向服务端发送一个请求，包含随机生成初始序号（称为seq = client_isn）和SYN = 1，客户端进入SYN_SENT状态</p>
<p>服务端接收到后，向客户端答复SYN=1，服务端随机初始序号（称为seq = server_isn）和 ack = client_isn + 1，服务端进入SYN_RCV 状态</p>
<p>客户端收到服务端答复后，再向服务端发送 SYN = 0，ack = server_isn +1 和 seq = client_isn + 1 ，两边都进入ESTABLISHED 状态</p>
<h3 id="11-TCP-握手为什么是三次，为什么不能是两次？不能是四次？"><a href="#11-TCP-握手为什么是三次，为什么不能是两次？不能是四次？" class="headerlink" title="11. TCP 握手为什么是三次，为什么不能是两次？不能是四次？"></a>11. TCP 握手为什么是三次，为什么不能是两次？不能是四次？</h3><ul>
<li><strong>为了防止服务端产生不必要的连接开销</strong>：假如客户端向服务端发送请求，服务端返回的一端信息丢失，客户端收不到自然也没有响应不会继续发送消息，这样服务端会一直保持连接，浪费开销</li>
<li><strong>同步初始化序列化：</strong>在连接中有一个seq序号是为了保证连接的稳定性，他能告诉服务端和客户端他们发的消息是否收到了，如果是两次连接，将不能保证。</li>
</ul>
<p>TCP三次连接已经够了，四次只会产生不必要的开销。</p>
<h3 id="12-三次握手中各次没收到报文会发生什么情况？"><a href="#12-三次握手中各次没收到报文会发生什么情况？" class="headerlink" title="12. 三次握手中各次没收到报文会发生什么情况？"></a>12. 三次握手中各次没收到报文会发生什么情况？</h3><ul>
<li><strong>第一次服务端没收到客户端消息：</strong>服务端将不会有任何动作；客户端会重新发送SYN报文，如果超出次数限制，将会返回建立连接失败。</li>
<li><strong>第二次客户端没收到服务端消息：</strong>客户端将重新发送消息，直到超出次数限制；服务端将阻塞在 <code>accept()</code>处，等待客户端的消息。</li>
<li><strong>第三次服务端没收到客户端消息：</strong>服务端会重传消息，直到超出次数限制，超出后<code>accept()</code>将返回-1；而客户端会误以为建立了连接，会向服务端发送消息，但是服务端收到数据时会返回<code>RST</code> 报文给客户端，消除客户端单方面建立连接的状态</li>
</ul>
<h3 id="13-第二次握手传回了-ACK，为什么还要传回-SYN？"><a href="#13-第二次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="13. 第二次握手传回了 ACK，为什么还要传回 SYN？"></a>13. 第二次握手传回了 ACK，为什么还要传回 SYN？</h3><p>第二次握手是服务器端收到SYN报文后，回复一个ACK报文，表示服务器端已经收到了客户端的请求。但是这时服务器端还需要向客户端发送一个SYN报文，用来表示服务器端也想要与客户端建立连接。</p>
<h3 id="14-第-3-次握手可以携带数据吗？"><a href="#14-第-3-次握手可以携带数据吗？" class="headerlink" title="14. 第 3 次握手可以携带数据吗？"></a>14. 第 3 次握手可以携带数据吗？</h3><p>可以携带。此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。</p>
<p>第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在 SYN 报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成 CPU 和内存的消耗。</p>
<h3 id="15-什么是半连接队列？"><a href="#15-什么是半连接队列？" class="headerlink" title="15. 什么是半连接队列？"></a>15. 什么是半连接队列？</h3><p>服务端会从 <strong>CLOSED</strong> 状态变为 <strong>LISTEN</strong> 状态，同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p>
<p>顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。</p>
<h3 id="16-TCP的四次挥手？"><a href="#16-TCP的四次挥手？" class="headerlink" title="***16. TCP的四次挥手？"></a>***16. TCP的四次挥手？</h3><p>数据传输结束后，客户端和服务端都可以主动发起断开请求，假如客户端先发起：</p>
<ul>
<li>第一次挥手客户端发送FIN=1，seq=u，发送后客户端进入FIN_WAIT_1状态</li>
<li>第二次挥手服务端发送ack=u+1，seq=v，发送后服务端进入CLOSE_WAIT状态，客户端进入FIN_EAIT_2状态</li>
<li>第三次挥手，服务端发送ack=u+1，seq=w，发送后服务端进入LAST_ACK状态</li>
<li>第四次挥手，客户端发送ack=w+1，seq=u+1，发送后进入客户端TIME_WAIT状态，等待固定的一段时间（<strong>2MSL</strong>，<strong>2 Maximum Segment Lifetime</strong>）后没有收到服务端的ACK后，认为服务器已经关闭，进入CLOSE状态，服务端收到后也进入CLOSE状态</li>
</ul>
<h3 id="17-TCP-挥手为什么需要四次呢？"><a href="#17-TCP-挥手为什么需要四次呢？" class="headerlink" title="17. TCP 挥手为什么需要四次呢？"></a>17. TCP 挥手为什么需要四次呢？</h3><ul>
<li>在关闭连接时，客户端向服务端发送 <code>FIN</code> 时，表示客户端不再向服务端发送消息，但是还可以接收消息</li>
<li>当服务端收到后，发送 <code>ACK</code> 表示收到消息了，<strong>而此时服务端可能还有消息需要处理</strong>，等到处理完成后再发送 <code>FIN</code> 表示也不再发送消息了</li>
</ul>
<p>因此，主要是因为在服务端收到消息后，可能还有消息需要处理，因此先答复收到了，等处理完成再答复可以关闭连接。</p>
<h3 id="18-TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？"><a href="#18-TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？" class="headerlink" title="18. TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？"></a>18. TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</h3><p><strong>为什么要等待：</strong>为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</p>
<p>因为在发送之后，可能因为网络等原因服务端收不到客户端的最后一次确认。而服务端则会超时重传，这样就需要客户等待后，再进入CLOSE状态。如果在这里时间内收到了服务端的消息，则需要重新发送消息给服务端通知其进入CLOSE状态。</p>
<p><strong>为什么是2MSL：</strong>    MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>为什么时2MSL比较靠谱的说法是客户端发送最后一次消息时，如果出现丢包等情况，服务端会超时重试，超时重试的消息也要发送给客户端，这样一来一回就是2MSL最多（而超时重传的时间则和客户端发送最后一次消息时间重合）。</p>
<h3 id="19-TCP-是如何保证可靠性的？"><a href="#19-TCP-是如何保证可靠性的？" class="headerlink" title="***19. TCP 是如何保证可靠性的？"></a>***19. TCP 是如何保证可靠性的？</h3><p>TCP通过拥塞控制、超时重传、确认应答、序列号、流量控制、校验和、连接管理、最大消息长度 保证可靠性</p>
<ul>
<li><strong>连接管理：</strong>即TCP三次握手和四次挥手</li>
<li><strong>拥塞控制：</strong>在通信过程中，会先发送一部分消息出去“探路”，根据当前网络状况决定以多大速率发送数据，这也被称为慢启动机制</li>
<li><strong>超时重传：</strong>当接收方长时间无应答时，发送方会启动超时重传</li>
<li><strong>序列号/确认应答：</strong>当接收方收到消息后，会给发送方发送确认消息，一般是根据序列号应答</li>
<li><strong>流量控制：</strong>在接收方和发送方首部都有一块缓冲区，如果数据传输速率过大，接收方将提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。</li>
<li><strong>校验和：</strong>TCP传输过程中，如果数据又变化，校验和将改变，接收方将丢弃或拒收该消息</li>
<li><strong>最大消息长度</strong>：在建立 TCP 连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</li>
</ul>
<h3 id="20-说说-TCP-的粘包和拆包？"><a href="#20-说说-TCP-的粘包和拆包？" class="headerlink" title="20. 说说 TCP 的粘包和拆包？"></a>20. 说说 TCP 的粘包和拆包？</h3><p>TCP传输过程中包大小会根据缓冲区实际情况进行包的划分：</p>
<ul>
<li> 要发送的数据大于TCP发送缓冲区<strong>剩余大小</strong>，将拆包</li>
<li>要发送的数据小于TCP缓冲区大小，多条数据将一起发送，发生粘包</li>
<li>要发送的数据大于 <code>最大报文长度</code>，将发生拆包</li>
<li>接收端的应用层，没有及时读取接收缓冲区中的数据，将发生粘包</li>
</ul>
<h3 id="21-TCP和UDP的区别？"><a href="#21-TCP和UDP的区别？" class="headerlink" title="21. TCP和UDP的区别？"></a>21. TCP和UDP的区别？</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否面向连接</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">传输形式</td>
<td align="center">字节流</td>
<td align="center">数据段报文</td>
</tr>
<tr>
<td align="center">应用场景</td>
<td align="center">文件传输、邮件传输</td>
<td align="center">即时通讯、语音通话</td>
</tr>
<tr>
<td align="center">首部字节</td>
<td align="center">20-60</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">可靠</td>
<td align="center">不可靠</td>
</tr>
<tr>
<td align="center">所需资源</td>
<td align="center">多</td>
<td align="center">少</td>
</tr>
<tr>
<td align="center">传输速率</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
</tbody></table>
<h3 id="22-UDP-协议为什么不可靠？"><a href="#22-UDP-协议为什么不可靠？" class="headerlink" title="22. UDP 协议为什么不可靠？"></a>22. UDP 协议为什么不可靠？</h3><p>UDP 在传输数据之前不需要先建立连接，远地主机的运输层在接收到 UDP 报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>
<ul>
<li>不保证消息交付</li>
<li>不保证交付顺序</li>
<li>不提供拥塞控制</li>
<li>不跟踪连接状态</li>
</ul>
<h3 id="23-DNS使用的是什么协议？"><a href="#23-DNS使用的是什么协议？" class="headerlink" title="23. DNS使用的是什么协议？"></a>23. DNS使用的是什么协议？</h3><p>DNS使用的既有TCP协议，也有UDP协议。</p>
<p>当进行区域传输（主域名服务器到辅助域名服务器）时，采用TCP保证可靠性。</p>
<p>当客户端使用DNS服务器查询域名时，使用的是UDP。</p>
<h3 id="24-IP协议有哪些作用？"><a href="#24-IP协议有哪些作用？" class="headerlink" title="24. IP协议有哪些作用？"></a>24. IP协议有哪些作用？</h3><p><strong>寻址和路由：</strong>在IP数据报中包含了源地址和目标地址。IP数据报在传输的过程中，如果中间节点碰到路由器，则会会根据路由器中的路由表进行数据转发，会提供最合适的路径。</p>
<p><strong>分段和重组：</strong>IP数据报在传输过程中，可能经过不同的网络，不同的网络对传输的数据报最大长度大小限制是不一样的，IP协议会给每段被拆分的数据报分配一个标识符用于后续组装，等传送到目的地址，在根据这些标识符对IP数据报进行重组，得到完整的数据报。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2023/01/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-02 21:24:35" itemprop="dateCreated datePublished" datetime="2023-01-02T21:24:35+08:00">2023-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-20 21:55:25" itemprop="dateModified" datetime="2023-02-20T21:55:25+08:00">2023-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/01/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/01/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-什么是僵尸进程？"><a href="#1-什么是僵尸进程？" class="headerlink" title="1. 什么是僵尸进程？"></a>1. 什么是僵尸进程？</h3><p>一般在有父子关系的进程中会存在。在子进程退出后，如果父进程没有调用<code>wait()</code>等方式，子进程将不会主动退出，从而成为僵尸进程。</p>
<h3 id="2-什么是孤儿进程？"><a href="#2-什么是孤儿进程？" class="headerlink" title="2. 什么是孤儿进程？"></a>2. 什么是孤儿进程？</h3><p>当父进程退出后，子进程还没有退出，这些子进程会成为孤儿进程。此时这些子进程将过继给init根进程，并由 init 进程对它们完成状态收集工作。</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="3-进程有哪些调度算法？"><a href="#3-进程有哪些调度算法？" class="headerlink" title="3. 进程有哪些调度算法？"></a>3. 进程有哪些调度算法？</h3><ul>
<li>先来先服务算法</li>
<li>优先级调度算法</li>
<li>时间片轮转算法</li>
<li>短作业优先算法</li>
<li>最短剩余时间优先算法</li>
</ul>
<h3 id="4-进程有哪些通信方式？"><a href="#4-进程有哪些通信方式？" class="headerlink" title="4. 进程有哪些通信方式？"></a>4. 进程有哪些通信方式？</h3><ul>
<li><strong>管道</strong>：<strong>所谓的管道就是内核中的一串缓存</strong>，从管道的一端写入数据，就是缓存在了内核里，另一端读取，也是从内核中读取这段数据。管道可以分为两类：<strong>匿名管道</strong>和<strong>命名管道</strong>。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道是双向的，可以实现本机任意两个进程通信。</li>
<li><strong>消息队列</strong>：<strong>消息队列就是保存在内核中的消息链表</strong>，包括Posix消息队列和System V消息队列。</li>
<li><strong>共享内存</strong>：<strong>就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写⼊的东西，另外的进程⻢上就能看到。共享内存是最快的 IPC 方式，</li>
<li><strong>信号量</strong>：<strong>它本质上是一个整数计数器</strong>，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。</li>
<li><strong>信号</strong>：信号可以理解成一种电报，发送方发送内容，指定接收进程，然后发出特定的软件中断，操作系统接到中断请求后，找到接收进程，通知接收进程处理信号。比如<code>kill -9 1050</code>就是一种信号。</li>
<li><strong>socket：</strong>与其他通信机制不同的是，它可用于不同机器间的进程通信。</li>
</ul>
<h3 id="5-线程有哪些实现方式？"><a href="#5-线程有哪些实现方式？" class="headerlink" title="5. 线程有哪些实现方式？"></a>5. 线程有哪些实现方式？</h3><p><strong>内核态线程实现</strong>、<strong>⽤户态线程实现</strong>、<strong>混合线程实现</strong>。</p>
<p>现代操作系统基本都是将两种方式结合起来使用。用户态的执行系统负责进程内部线程在非阻塞时的切换；内核态的操作系统负责阻塞线程的切换。即我们同时实现内核态和用户态线程管理。其中内核态线程数量较少，而用户态线程数量较多。每个内核态线程可以服务一个或多个用户态线程。</p>
<h3 id="6-什么是快表？"><a href="#6-什么是快表？" class="headerlink" title="6. 什么是快表？"></a>6. 什么是快表？</h3><p>同样利用了<code>局部性原理</code>，即在⼀段时间内，整个程序的执行仅限于程序中的某⼀部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p>
<p>利用这⼀特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了⼀个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为页表缓存、转址旁路缓存、快表等。</p>
<h3 id="7-页面置换算法有哪些？"><a href="#7-页面置换算法有哪些？" class="headerlink" title="7. 页面置换算法有哪些？"></a>7. 页面置换算法有哪些？</h3><ul>
<li>先进先出置换算法：</li>
<li>最佳页面置换算法：</li>
<li>最近最久未使用置换算法：</li>
<li><strong>时钟页面置换算法：</strong>这个算法的思路是，把所有的页面都保存在⼀个类似钟面的环形链表中，⼀个表针指向最老的页面。当发生缺页中断时，算法首先检查表针指向的页面：如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移⼀个位置；如果访问位是 1 就清除访问位，并把表针前移⼀个位置，重复这个过程直到找到了⼀个访问位为 0 的页面为止；</li>
</ul>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-3646408f-999e-48a1-84e9-113525778aca.png" alt="时钟页面置换算法" style="zoom: 50%;">

<ul>
<li>最近未使用置换算法：</li>
</ul>
<h3 id="8-硬链接和软链接有什么区别？"><a href="#8-硬链接和软链接有什么区别？" class="headerlink" title="8. 硬链接和软链接有什么区别？"></a>8. 硬链接和软链接有什么区别？</h3><p>硬链接与原文件在磁盘上实际上指向同一个数据块，因此修改其中一个文件，另一个文件也会被修改。而软链接只是一个指向原文件的路径名，因此修改原文件不会影响软链接，软链接也可以指向其他路径的文件。</p>
<h3 id="9-介绍一下零拷贝技术？"><a href="#9-介绍一下零拷贝技术？" class="headerlink" title="9. 介绍一下零拷贝技术？"></a>9. 介绍一下零拷贝技术？</h3><p>在数据传输过程中，普通拷贝一般有四步，涉及到四次用户态和内核态之间的切换，开销较大。</p>
<p>所以为了减少用户态和核心态之间的切换以及内存拷贝的次数，使用了零拷贝技术。</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-1e595664-6585-4d56-8939-08b7ce510218.png" alt="传统文件传输示意图-来源参考[3]" style="zoom: 50%;">

<ul>
<li>mmap + write</li>
</ul>
<p>本技术是将内核缓冲区里的数据“映射”到用户空间，这样，操作系统内核和用户空间就不需要再进行任何数据拷贝。</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-6dc49f9d-0bc3-4956-a650-7c7236f234a2.png" alt="mmap示意图-来源参考[3]" style="zoom:50%;">

<ul>
<li>sendfile</li>
</ul>
<p>在 Linux 内核版本 2.1 中，提供了⼀个专门发送文件的系统调⽤函数 sendfile() 。用这个函数代替read() 和 write() 两个函数，可以减少一次系统调用，也就是减少了两次上下文切换开销。</p>
<p>另外，可以把内核缓冲区内的数据直接拷贝到socket缓冲区，而不是先拷贝到用户态中。这样总共就只有两次线程上下文切换的开销。</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-0b087b8a-8d51-4aad-898d-d99c38d36592.png" alt="sendfile示意图-来源参考[3]" style="zoom:50%;">

<p>在Kafka和Rocket中，都有这些零拷贝技术的运用。</p>
<h3 id="10-讲讲几种I-O模型？"><a href="#10-讲讲几种I-O模型？" class="headerlink" title="10. 讲讲几种I/O模型？"></a>10. 讲讲几种I/O模型？</h3><blockquote>
<p>I/O是面向流的，NIO是面向缓冲区的</p>
</blockquote>
<blockquote>
<p>内核利用文件描述符来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。</p>
</blockquote>
<ul>
<li><strong>阻塞I/O：</strong>阻塞I/O模型是最常见的I/O模型，它的特点是当应用程序进行I/O操作时，操作系统会一直等待I/O操作完成，直到返回结果，期间应用程序会被阻塞，无法进行其他操作。这种模型在面对高并发和大量I/O操作时可能导致性能下降。</li>
</ul>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-f06db5ff-661c-4ddf-9115-4ed9c9a21d01.png" alt="阻塞I/O" style="zoom:50%;">

<ul>
<li><strong>非阻塞I/O：</strong>非阻塞I/O模型是一种优化阻塞I/O的方式，它的特点是当应用程序进行I/O操作时，操作系统不会一直等待I/O操作完成，而是立即返回一个错误码，表示操作正在进行中。这样应用程序可以不停地进行轮询，直到I/O操作完成。这种模型可以提高应用程序的响应速度和吞吐量。（多个调用可以同时执行，没好的话只是都返回错误码，提高吞吐量）</li>
</ul>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-771e014e-7ed9-4101-8bb5-4413b8069fd6.png" alt="非阻塞I/O" style="zoom:50%;">

<ul>
<li><strong>基于非阻塞的I/O复用：</strong>基于非阻塞I/O的多路复用是一种更高效的I/O模型，它的特点是通过一个系统调用同时监听多个文件描述符的读写状态，一旦有数据可读或可写，就会通知应用程序进行处理。这种模型避免了不必要的轮询，提高了应用程序的效率和性能。</li>
</ul>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-86e54fa3-ad36-43c7-9d2d-5a68139c310f.png" alt="基于非阻塞的I/O多路复用" style="zoom:50%;">

<blockquote>
<p><strong>无论是阻塞 I/O、还是非阻塞 I/O、非阻塞I/O多路复用，都是同步调用。因为它们在read调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步</strong>的，如果内核实现的拷贝效率不高，read调用就会在这个同步过程中等待比较长的时间。</p>
</blockquote>
<ul>
<li><p><strong>异步I/O：</strong>真正的<strong>异步</strong> <strong>I/O</strong> 是<code>内核数据准备好</code>和<code>数据从内核态拷贝到⽤户态</code>这两个过程都不用等待。</p>
<p>发起 aio_read 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。</p>
</li>
</ul>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/os-869021ed-5e4e-4490-9174-7291d8ddf55c.png" alt="异步/IO" style="zoom:50%;">



<h3 id="11-详细讲讲I-O多路复用？"><a href="#11-详细讲讲I-O多路复用？" class="headerlink" title="11. 详细讲讲I/O多路复用？"></a>11. 详细讲讲I/O多路复用？</h3><p>I/O多路复用，指的是一个进程维护多个socket，也就是多个连接复用一个进程/线程。</p>
<p>I/O多路复用有三种实现机制</p>
<ul>
<li><strong>select</strong></li>
</ul>
<p>select执行过程如下：</p>
<p>假如进程A启动时，要监听的socket三个文件描述符为3、4、5，此时网卡还没有接收到有数据到达，进程A便会让出CPU，阻塞线程。此时select会将三个socket连接从用户态拷贝进内核态的等待队列。</p>
<p>等到有数据到达时，网卡通过中断信号告诉CPU，执行中断程序，中断程序做了以下几件事：</p>
<ol>
<li>将数据写入到对应的socket数据连接</li>
<li>唤醒进程A，重新放入CPU的运行队列</li>
</ol>
<p>数据到达后，select执行结束，文件描述符集合拷贝到用户态。</p>
<img src="https://s2.51cto.com/images/20220525/1653408849167681.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="深入理解NIO多路复用_多路复用_35" style="zoom: 67%;">

<p><strong>select缺点如下：</strong></p>
<ol>
<li>开销过大。刚开始时select会将文件描述符集从用户态拷贝到内核态，收到数据，select执行完成后又会将其从内核态拷贝到用户态。有两次用户态和内核态之间的上下文切换。（epoll优化为不拷贝）</li>
<li>每次调用select都需要在内核遍历传递进来的所有fd_set。进程被唤醒后，不知道哪些连接已就绪（收到了数据），需要遍历文件描述符集。（epoll优化为异步事件通知）</li>
<li>select只返回就绪文件的个数，具体哪个可读还要遍历。（epoll优化为返回就绪的文件描述符）</li>
<li>同时能够监听的连接数太少，在编译内核时就确定并且无法修改，一般是 32 位操作系统是 1024，64 位是 2048。（poll、epoll 优化为适应链表方式）</li>
</ol>
<ul>
<li><strong>poll</strong></li>
</ul>
<p><strong>poll主要解决的就是文件描述符集合数量限制的问题</strong>，它采用链表进行存储。</p>
<p>但是在使用过程中还是需要遍历整个链表获取哪些socket可读以及哪些socket就绪，时间复杂度太高。</p>
<ul>
<li><strong>epoll</strong></li>
</ul>
<p>epoll解决了select的“性能开销大”和“文件描述符数量少”这两个缺点，是性能最高的多路复用实现方式，能支持的并发量也是最大。解决的方法具体如下：</p>
<p>通过维护一个红黑树结构存储所有待检测的文件描述符，在每次有新的socket连接时，通过函数调用将其加入红黑树内。而不是像select/poll一样每次都传入一个集合，减少了用户空间和内核之间的大量数据拷贝和内存分配。</p>
<p>epoll 使用事件驱动的机制，在内核态维护一个链表记录就绪事件，当socket有事件发生时，通过回调函数，内核会将其加入就绪事件列表。而不是进程唤醒后，每次去遍历去找哪个可读，然后标记。</p>
<p>当用户态需要时会调用<code>epoll_wait()</code>函数，会返回有事件发生的文件描述符。而不是只返回就绪文件个数，然后一个个去遍历找哪个可读。</p>
<img src="https://s2.51cto.com/images/20220525/1653410054495894.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="深入理解NIO多路复用_多路复用_37" style="zoom:67%;">

<blockquote>
<p>可以看讲的较为细的文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5xj42JPKG8o5T7hjXIKywg">https://mp.weixin.qq.com/s/5xj42JPKG8o5T7hjXIKywg</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/12/19/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/19/Spring/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-19 21:51:10" itemprop="dateCreated datePublished" datetime="2022-12-19T21:51:10+08:00">2022-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-15 21:04:05" itemprop="dateModified" datetime="2023-02-15T21:04:05+08:00">2023-02-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/12/19/Spring/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/12/19/Spring/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-Spring中用到了哪些设计模式？"><a href="#1-Spring中用到了哪些设计模式？" class="headerlink" title="1. Spring中用到了哪些设计模式？"></a>1. Spring中用到了哪些设计模式？</h3><ul>
<li><strong>工厂模式：</strong>使用工程模式通过BeanFactory和ApplicationContext创建对象。</li>
<li><strong>单例模式：</strong>Spring的容器中Bean默认都是单例的。</li>
<li><strong>策略模式：</strong>继承自Resource下的有不同的实现类，会根据不同实现类访问资源。</li>
</ul>
<blockquote>
<p>ByteArrayResource、ClassPathResource、FileSystemResource、UrlResource、InputStreamResource</p>
</blockquote>
<ul>
<li><strong>观察者模式：</strong>Spring的事件驱动模型使用的是观察者模式</li>
</ul>
<blockquote>
<p>Spring的事件驱动模型是基于观察者设计模式实现的。在该模型中，事件源（如应用程序、框架或第三方库）生成事件，事件由事件监听器（观察者）处理。Spring的事件机制包括一个事件发布者（ApplicationEventPublisher）和一个事件监听器（ApplicationListener），发布者负责发布事件，监听器负责处理事件。通过这种模型，Spring框架实现了松耦合、可扩展的应用程序架构。</p>
</blockquote>
<ul>
<li><strong>代理模式：</strong>Spring的AOP就是通过代理实现，分为动态代理和静态代理</li>
<li><strong>适配器模式：</strong>Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller</li>
</ul>
<h3 id="2-FactoryBean与BeanFactory的区别"><a href="#2-FactoryBean与BeanFactory的区别" class="headerlink" title="2. FactoryBean与BeanFactory的区别"></a>2. FactoryBean与BeanFactory的区别</h3><ol>
<li>BeanFactory是Spring框架最基本的接口，它是一个工厂，负责创建和管理Bean实例。FactoryBean是BeanFactory的一个扩展接口，它允许开发人员自定义Bean对象的创建过程。</li>
<li>BeanFactory接口是Spring容器的核心，负责管理Bean对象的生命周期和依赖关系。而FactoryBean接口则是在BeanFactory接口的基础上提供了更多的灵活性，可以通过FactoryBean接口来实现AOP代理、动态代理等高级功能。</li>
<li>当Spring容器需要创建一个Bean对象时，它首先会检查这个Bean是否是一个FactoryBean。如果是，Spring容器会调用FactoryBean的getObject()方法来获取Bean对象实例，而不是直接调用Bean对象的构造方法或工厂方法。</li>
</ol>
<p>下面截取了两者的部分代码用于分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactory &#123;</span><br><span class="line">    String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class="line">    Object getBean(String var1) throws BeansException;</span><br><span class="line">    &lt;T&gt; T getBean(String var1, Class&lt;T&gt; var2) throws BeansException;</span><br><span class="line">    &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; var1);</span><br><span class="line">    boolean containsBean(String var1);</span><br><span class="line">    boolean isSingleton(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line">    boolean isPrototype(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line">    boolean isTypeMatch(String var1, ResolvableType var2) throws NoSuchBeanDefinitionException;</span><br><span class="line">    @Nullable</span><br><span class="line">    Class&lt;?&gt; getType(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line">    String[] getAliases(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line">    String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;;</span><br><span class="line">    @Nullable</span><br><span class="line">    T getObject() throws Exception;</span><br><span class="line">    @Nullable</span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    default boolean isSingleton() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中FactoryBean的<code>getObject()</code>方法会返回该FactoryBean“生产”的对象实例，简单说就是有些对象实例化逻辑比较复杂，而我们又想自己实现的时候，就可以继承该接口并且重写<code>getObject()</code>方法。</p>
<h3 id="3-为什么要FactoryBean"><a href="#3-为什么要FactoryBean" class="headerlink" title="3. 为什么要FactoryBean"></a>3. 为什么要FactoryBean</h3><p>当某些对象的实例化过程过于烦琐，通过XML配置过于复杂，使我们宁愿使用Java代码来完成这个实例化过程的时候，或者，某些第三方库不能直接注册到Spring容器的时候，就可以实现<code>org.springframework.beans.factory.FactoryBean</code>接口，给出自己的对象实例化逻辑代码。当然，不使用FactoryBean，而像通常那样实现自定义的工厂方法类也是可以的。</p>
<p>这样说可能不好理解，我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Bean</span><br><span class="line"> */</span><br><span class="line">public class Mapper &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    public Mapper(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MapperFactoryBean implements FactoryBean&lt;Mapper&gt; &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private Mapper mapper;</span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Mapper getObject() &#123;</span><br><span class="line">        if (mapper == null) &#123;</span><br><span class="line">            mapper = new Mapper(id);</span><br><span class="line">        &#125;</span><br><span class="line">        return mapper;</span><br><span class="line">    &#125;</span><br><span class="line">     // 这里是getObjectType() 和 isSingleton() 实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;mapper&quot; class=&quot;com.wangtao.spring.bean.MapperFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class BaseTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void application() &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);</span><br><span class="line">        // 下面这句将抛出异常</span><br><span class="line">        // MapperFactoryBean mapper = context.getBean(&quot;mapper&quot;, MapperFactoryBean.class);</span><br><span class="line">        Mapper mapper = context.getBean(&quot;mapper&quot;, Mapper.class);</span><br><span class="line">        Assert.assertEquals(1, mapper.getId().intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从测试结果中得知，我们虽然配置的是<code>MapperFactoryBean</code>的实例，但是根据id拿到的是<code>getObject</code>方法创建的对象。其实在容器中创建的对象仍然是<code>MapperFactoryBean</code>的实例，只是在获取的时候会判断这个结果对象是不是派生于<code>FactoryBean</code>，如果是的话则返回<code>getObject</code>方法创建的对象，并且这个对象并不是容器初始化时创建的，而是使用<code>context.getBean()</code>方法时才创建。</p>
<p>如果想要获取<code>FactoryBean</code>实例，需要这样写:</p>
<p><code>MapperFactoryBean mapper = context.getBean(&quot;&amp;mapper&quot;, MapperFactoryBean.class)</code> ；</p>
<p>即在bean的名字ID前加上&amp;符号。</p>
<h3 id="4-能简单说一下-Spring-IOC-的实现机制吗？"><a href="#4-能简单说一下-Spring-IOC-的实现机制吗？" class="headerlink" title="4. 能简单说一下 Spring IOC 的实现机制吗？"></a>4. 能简单说一下 Spring IOC 的实现机制吗？</h3><p>简单的Spring IOC流程大致如下：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-1d55c63d-2d12-43b1-9f43-428f5f4a1413.png" alt="mini版本Spring IOC"></p>
<h3 id="5-说说-BeanFactory-和-ApplicationContext"><a href="#5-说说-BeanFactory-和-ApplicationContext" class="headerlink" title="5. 说说 BeanFactory 和 ApplicationContext?"></a>5. 说说 BeanFactory 和 ApplicationContext?</h3><p>简单说，ApplicantContext在BeanFactory的基础上，提供了很多扩展。</p>
<ul>
<li>BeanFactory（Bean 工厂）是 Spring 框架的基础设施，面向 Spring 本身。</li>
<li>ApplicantContext（应用上下文）建立在 BeanFactory 基础上，面向使用 Spring 框架的开发者</li>
</ul>
<p>BeanFactory是用于Bean的创建，管理Bean的生命周期等，并提供了从容器中获取Bean的诸多方法。</p>
<p>ApplicationContext除了拥有 BeanFactory支持的所有功能之外，还进一步扩展了基本容器的功能，包括<code>BeanFactoryPostProcessor</code>、<code>BeanPostProcessor</code>以及其他特殊类型bean的自动识别、容器启动后bean实例的自动初始化、 国际化的信息支持、容器内事件发布等。</p>
<h3 id="6-BeanPostProcessor是什么？"><a href="#6-BeanPostProcessor是什么？" class="headerlink" title="6. BeanPostProcessor是什么？"></a>6. BeanPostProcessor是什么？</h3><p>它是用来拦截所有 bean 的初始化的，在 bean 的初始化之前，和初始化之后做一些事情。这点从 BeanPostProcessor 接口的定义也可以看出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">    @Nullable</span><br><span class="line">    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-你知道-Spring-容器启动阶段会干什么吗？"><a href="#7-你知道-Spring-容器启动阶段会干什么吗？" class="headerlink" title="7. 你知道 Spring 容器启动阶段会干什么吗？"></a>7. 你知道 Spring 容器启动阶段会干什么吗？</h3><p>Spring IOC容器工作过程分为两部分，一个是启动阶段，一个是Bean实例化阶段。</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-8f8103f7-2a51-4858-856e-96a4ac400d76.png" alt="容器启动和Bean实例化阶段" style="zoom:67%;">

<p>容器启动开始，首先会通过某种途径加载 Congiguration MetaData，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的 Configuration MetaData 进行解析和分析，并将分析后的信息组为相应的 BeanDefinition。</p>
<p>最后把这些保存了 Bean 定义必要信息的 BeanDefinition，注册到相应的 BeanDefinitionRegistry，这样容器启动就完成了。</p>
<h3 id="8-Spring-Bean的生命周期？"><a href="#8-Spring-Bean的生命周期？" class="headerlink" title="8. Spring Bean的生命周期？"></a>8. Spring Bean的生命周期？</h3><p>实例化——》属性赋值——》初始化——》使用——》销毁</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-942a927a-86e4-4a01-8f52-9addd89642ff.png" alt="SpringBean生命周期" style="zoom:67%;">

<ul>
<li><strong>实例化：</strong>图中第一步是实例化Bean，</li>
<li><strong>属性赋值：</strong>图中第二步设置对象属性</li>
<li><strong>初始化：</strong>5、6 步是真正的初始化，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，初始化完成之后，Bean 就可以被使用了</li>
<li><strong>销毁：</strong>第 8~10 步，第 8 步其实也可以算到销毁阶段，但不是真正意义上的销毁，而是先在使用前注册了销毁的相关调用接口，为了后面第 9、10 步真正销毁 Bean 时再执行相应的方法</li>
</ul>
<blockquote>
<p>spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，或者在配置文件中同过init-method指定，两种方式可以同时使用。</p>
</blockquote>
<h3 id="9-Spring中Bean的作用域有哪些？"><a href="#9-Spring中Bean的作用域有哪些？" class="headerlink" title="9. Spring中Bean的作用域有哪些？"></a>9. Spring中Bean的作用域有哪些？</h3><ul>
<li>singleton：单例的，在Spring容器中只存在一个实例，是Bean默认的作用域。</li>
<li>prototype：每次创建都会返回新的的实例。</li>
</ul>
<p>以下三个只存在Web容器中</p>
<ul>
<li>request：每次Http请求都会产生一个Bean，并且只在当前的Http Request中有效</li>
<li>session：同一个Http Session共享一个Bean，不同的Http Session使用不同的Bean</li>
<li>globalSession：同一个全局 Session 共享一个 Bean，只用于基于 Protlet 的 Web 应用，Spring5 中已经不存在了。</li>
</ul>
<h3 id="10-Spring-中的单例-Bean-会存在线程安全问题吗？"><a href="#10-Spring-中的单例-Bean-会存在线程安全问题吗？" class="headerlink" title="10. Spring 中的单例 Bean 会存在线程安全问题吗？"></a>10. Spring 中的单例 Bean 会存在线程安全问题吗？</h3><p>会存在。即便Spring IoC容器中的Bean是单例的，但是是线程共享的，所以不是线程安全的。</p>
<p>如果要解决单例Bean的线程安全问题，可以将变量保存在ThreadLocal中，实现变量在线程间的隔离。</p>
<h3 id="11-Spring如何解决循环依赖？"><a href="#11-Spring如何解决循环依赖？" class="headerlink" title="11. Spring如何解决循环依赖？"></a>11. Spring如何解决循环依赖？</h3><p>最好的方式就是在设计时避免循环依赖。</p>
<p>但是如果有循环依赖，就需要像Spring一样依靠三层缓存区解决。</p>
<p>比如当A和B之间有循环依赖时，大致解决步骤如下：</p>
<ol>
<li>首先将A放入三级缓存，表示A要开始实例化了，虽然还不完整，但是此时的目的就是曝光出来让大家知道。</li>
<li>A在属性注入时，发现依赖了B，此时就会去实例化B</li>
<li>而B在属性注入的过程中，发现又依赖了A，就会去缓存中寻找A，在三级缓存中找到了A，虽然A不完善，但是存在，于是将A放入二级缓存，同时删除三级缓存的A，与此同时B也实例化完成，B放入一级缓存</li>
<li>接着A继续属性注入赋值，并在一级缓存拿到了B，于是A也进入一级缓存，删除二级缓存的A</li>
</ol>
<p>这就是为什么Spring能解决Setter注入的循环依赖，因为分为实例化和属性注入几个步骤，简单说就是有一个时间差，所以能用缓存去解决。而构造器就不行了，直接在实例化时就注入了。</p>
<blockquote>
<p>详细解答参考（有必要看）：<a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_16-%E9%82%A3-spring-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%91%A2">https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_16-%E9%82%A3-spring-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%91%A2</a></p>
</blockquote>
<p>详细步骤：</p>
<p>1、getSingleton(“a”, true) 获取 a：会依次从 3 个级别的缓存中找 a，此时 3 个级别的缓存中都没有 a</p>
<p>2、将 a 丢到正在创建的 beanName 列表中（Set<String> singletonsCurrentlyInCreation）</String></p>
<p>3、实例化 a：A a = new A();这个时候 a 对象是早期的 a，属于半成品</p>
<p>4、将早期的 a 丢到三级缓存中（Map&lt;String, ObjectFactory&lt;?&gt; &gt; singletonFactories）</p>
<p>5、调用 populateBean 方法，注入依赖的对象，发现 setB 需要注入 b</p>
<p>6、调用 getSingleton(“b”, true) 获取 b：会依次从 3 个级别的缓存中找 a，此时 3 个级别的缓存中都没有 b</p>
<p>7、将 b 丢到正在创建的 beanName 列表中</p>
<p>8、实例化 b：B b = new B();这个时候 b 对象是早期的 b，属于半成品</p>
<p>9、将早期的 b 丢到三级缓存中（Map&lt;String, ObjectFactory&lt;?&gt; &gt; singletonFactories）</p>
<p>10、调用 populateBean 方法，注入依赖的对象，发现 setA 需要注入 a</p>
<p>11、调用 getSingleton(“a”, true) 获取 a：此时 a 会从第 3 级缓存中被移到第 2 级缓存，然后将其返回给 b 使用，此时 a 是个半成品（属性还未填充完毕）</p>
<p>12、b 通过 setA 将 11 中获取的 a 注入到 b 中</p>
<p>13、b 被创建完毕，此时 b 会从第 3 级缓存中被移除，然后被丢到 1 级缓存</p>
<p>14、b 返回给 a，然后 b 被通过 A 类中的 setB 注入给 a</p>
<p>15、a 的 populateBean 执行完毕，即：完成属性填充，到此时 a 已经注入到 b 中了</p>
<p>16、调用<code>a= initializeBean(&quot;a&quot;, a, mbd)</code>对 a 进行处理，这个内部可能对 a 进行改变，有可能导致 a 和原始的 a 不是同一个对象了</p>
<p>17、调用<code>getSingleton(&quot;a&quot;, false)</code>获取 a，注意这个时候第二个参数是 false，这个参数为 false 的时候，只会从前 2 级缓存中尝试获取 a，而 a 在步骤 11 中已经被丢到了第 2 级缓存中，所以此时这个可以获取到 a，这个 a 已经被注入给 b 了</p>
<p>18、此时判断注入给 b 的 a 和通过<code>initializeBean</code>方法产生的 a 是否是同一个 a，不是同一个，则弹出异常</p>
<h3 id="12-为什么要三级缓存？二级不行吗？"><a href="#12-为什么要三级缓存？二级不行吗？" class="headerlink" title="12. 为什么要三级缓存？二级不行吗？"></a>12. 为什么要三级缓存？二级不行吗？</h3><ul>
<li>singletonObjects：第一级缓存，里面存放的都是创建好的成品Bean。</li>
<li>earlySingletonObjects : 第二级缓存，里面存放的都是半成品的Bean。</li>
<li>singletonFactories ：第三级缓存， 不同于前两个存的是 Bean对象引用，此缓存存的bean 工厂对象，也就存的是 专门创建Bean的一个工厂对象。此缓存用于解决循环依赖</li>
</ul>
<p><strong>在Spring中需要三级缓存的主要原因是因为Spring AOP需要生成代理对象。如果不是Spring框架的话，使用二级缓存也是可以的。</strong></p>
<p><strong>简单说，Bean在初始化后（创建Bean的最后一个阶段），会判断是否需要创建代理对象。如果创建了代理，那么最终返回的就是代理实例的引用。</strong></p>
<p>假如A和B存在循环依赖需要解决，三级缓存是会提前暴露对象（不完整的没有属性注入的对象），但是如果需要代理对象的话，在填充完属性后会创建代理对象的（代理对象需要在最后一个阶段创建），此时的Bean和提前暴露对象的Bean应该要一样，但是实际是不一样的，一个拥有属性，一个则是不完整的Bean。所以三级缓存才能保证不管什么时候使用的都是⼀个对象。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?search_click_id=12197758318362842576-1676449107049-0075004220&__biz=MzI3ODcxMzQzMw==&mid=2247558166&idx=1&sn=68cfa76fec70ca02ccd69694aedeb5ca&chksm=eb516120dc26e836ff042e0e2d4b82eaeb23af2dd310e18788f65ebaf3b8780643843adfabb8&scene=7&key=d63319dbe768b294acfb42f16f098f6fb1f91ec370a25bbbf213a2c0b02c4c68266d32507eda6062273dc64a5bf9efafd3b8a1733ddcb71caf46e7a6788b1ab8209d8d7961ec5acd7690ab769c2a337ffa9bc22ff12aa73d03dafcb7df9737a5fadb51eef231a4276892c616b311cc5a7a019e89c49f47fb2a9d1695960e8024&ascene=0&uin=Mjc1MDc1NzMzMw==&devicetype=Windows+10+x64&version=6309001c&lang=zh_CN&countrycode=CN&exportkey=n_ChQIAhIQDm56EFda45N3lTeKu/D8OBLgAQIE97dBBAEAAAAAAATMGqV2ElEAAAAOpnltbLcz9gKNyK89dVj0eraFvKNktQdV5codY72U1LfFLtP7qMEqtkcgObkSFOxDi7QEnw4UgV83LPXio7KYZSgdEHrn3D49NG8ea+IYhJ7hT5a3BEjuWMP2mzqocdGhR66qFuewzlR00lDOTmpbakqPfOH5wQvcHdv4c7tPdED+GbPDS3CFgQyf/kvd0YtxgYKiScx1rwvqWymElFL9JYOfDMdtkWeqofZOXuxwqcJWlGGTayQ7KzKds641+5PMet/RC3e9LL0D&acctmode=0&pass_ticket=yZ4SyqXyHG0YANcve3F3ZuLMRDeApErjIJuNHXd3pZ+6uiQ421FaRuhlH7npK/LqwR8huHbJMA/+b+Nevw8Hlg==&wx_header=1&fontgear=2">详细解答可看：</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/pBo5NkBwPwA_WATGe2xugQ">或者这个</a></p>
</blockquote>
<h3 id="13-说说-JDK-动态代理和-CGLIB-代理-？"><a href="#13-说说-JDK-动态代理和-CGLIB-代理-？" class="headerlink" title="13. 说说 JDK 动态代理和 CGLIB 代理 ？"></a>13. 说说 JDK 动态代理和 CGLIB 代理 ？</h3><ul>
<li><strong>JDK动态代理：</strong><ul>
<li>JDK动态代理需要实现InvocationHandler</li>
<li>在实现该接口后，可以在前后写横切逻辑，调用invoke方法执行</li>
<li>Proxy利用 InvocationHandler 动态创建一个符合目标类实现的接口的实例，生成目标类的代理对象。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 接口</span><br><span class="line">public interface ISolver &#123;</span><br><span class="line">    void solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 目标类</span><br><span class="line">public class Solver implements ISolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void solve() &#123;</span><br><span class="line">        System.out.println(&quot;疯狂掉头发解决问题……&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyFactory &#123;</span><br><span class="line">    // 维护一个目标对象</span><br><span class="line">    private Object target;</span><br><span class="line">    public ProxyFactory(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    // 为目标对象生成代理对象</span><br><span class="line">    public Object getProxyInstance() &#123;</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        System.out.println(&quot;请问有什么可以帮到您？&quot;);</span><br><span class="line">                        // 调用目标对象方法</span><br><span class="line">                        Object returnValue = method.invoke(target, args);</span><br><span class="line">                        System.out.println(&quot;问题已经解决啦！&quot;);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 客户端</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //目标对象:程序员</span><br><span class="line">        ISolver developer = new Solver();</span><br><span class="line">        //代理：客服小姐姐</span><br><span class="line">        ISolver csProxy = (ISolver) new ProxyFactory(developer).getProxyInstance();</span><br><span class="line">        //目标方法：解决问题</span><br><span class="line">        csProxy.solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Cglib动态代理：</strong><ul>
<li>Cglib原理是生成一个子类，并在采用方法拦截父类执行，并织入横切逻辑在其中</li>
<li>相比JDK动态代理只能通过继承接口实现，Cglib则没有这个限制</li>
<li>如果目标类使用了final方法，Cglib则无法使用，因为他是通过创建子类进而实现的</li>
<li><strong>CgLib</strong> 创建的动态代理对象性能比 JDK 创建的动态代理对象的性能高不少，但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 目标类</span><br><span class="line">public class Solver &#123;</span><br><span class="line">    public void solve() &#123;</span><br><span class="line">        System.out.println(&quot;疯狂掉头发解决问题……&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 动态工厂</span><br><span class="line">public class ProxyFactory implements MethodInterceptor &#123;</span><br><span class="line">   //维护一个目标对象</span><br><span class="line">    private Object target;</span><br><span class="line">    public ProxyFactory(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    //为目标对象生成代理对象</span><br><span class="line">    public Object getProxyInstance() &#123;</span><br><span class="line">        //工具类</span><br><span class="line">        Enhancer en = new Enhancer();</span><br><span class="line">        //设置父类</span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        //设置回调函数</span><br><span class="line">        en.setCallback(this);</span><br><span class="line">        //创建子类对象代理</span><br><span class="line">        return en.create();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;请问有什么可以帮到您？&quot;);</span><br><span class="line">        // 执行目标对象的方法</span><br><span class="line">        Object returnValue = method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;问题已经解决啦！&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //目标对象:程序员</span><br><span class="line">        Solver developer = new Solver();</span><br><span class="line">        //代理：客服小姐姐</span><br><span class="line">        Solver csProxy = (Solver) new ProxyFactory(developer).getProxyInstance();</span><br><span class="line">        //目标方法：解决问题</span><br><span class="line">        csProxy.solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-说说-Spring-AOP-和-AspectJ-AOP-区别"><a href="#14-说说-Spring-AOP-和-AspectJ-AOP-区别" class="headerlink" title="14. 说说 Spring AOP 和 AspectJ AOP 区别?"></a>14. 说说 Spring AOP 和 AspectJ AOP 区别?</h3><p><strong>Spring AOP（运行时增强）：</strong></p>
<ul>
<li>基于动态代理实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现。</li>
<li>需要依赖IoC容器来管理，使用纯Java实现</li>
<li>由于动态代理时会生成代理实例对象，相应的方法调用也会增加栈调用的深度，因此性能相对没有AspectJ好</li>
</ul>
<p><strong>AspectJ AOP（编译时增强）：</strong></p>
<ul>
<li>属于编译时增强，可以单独使用，也可以整合到其他框架，但是需要依赖单独的编译器<code>ajc</code></li>
<li>属于静态织入，有以下几个织入时机：<ul>
<li>编译期织入：在编译时织入</li>
<li>编译后织入：在已经编译成class文件，并且打成Jar后，需要织入就要使用这种方式</li>
<li>类加载后织入：在加载类的时候</li>
</ul>
</li>
</ul>
<h3 id="15-Spring的事务种类？"><a href="#15-Spring的事务种类？" class="headerlink" title="15. Spring的事务种类？"></a>15. Spring的事务种类？</h3><p>编程式事务和声明式事务。</p>
<p><strong>编程式事务：</strong></p>
<ul>
<li>编程式事务管理使用 TransactionTemplate，需要显式执行事务</li>
</ul>
<p><strong>声明式事务：</strong></p>
<ul>
<li>基于AOP实现的，本质就是在方法执行前添加一个事务，在执行完成后，根据执行结果决定回滚或者提交</li>
<li>只需要在代码中添加@Transation注解即可</li>
</ul>
<h3 id="16-Spring-的事务隔离级别？"><a href="#16-Spring-的事务隔离级别？" class="headerlink" title="16. Spring 的事务隔离级别？"></a>16. Spring 的事务隔离级别？</h3><ol>
<li>DEFAULT（默认）：使用数据库默认的隔离级别。对于大多数数据库，这通常是 READ_COMMITTED 级别。</li>
<li>READ_UNCOMMITTED（读未提交）：最低的隔离级别，在该级别下，一个事务可以读取另一个事务未提交的数据，这可能导致脏读、不可重复读和幻读等问题。</li>
<li>READ_COMMITTED（读已提交）：一个事务只能读取另一个事务已经提交的数据。这种隔离级别可以防止脏读，但是在并发情况下可能会导致不可重复读和幻读等问题。</li>
<li>REPEATABLE_READ（可重复读）：一个事务在多次执行相同的查询时，结果都是相同的。在该级别下，读取的数据是事务开始时的一致性视图，可以防止脏读和不可重复读，但是仍然存在幻读问题。</li>
<li>SERIALIZABLE（串行化）：最高的隔离级别，通过强制事务串行执行来避免并发问题。在该级别下，事务之间完全隔离，可以防止脏读、不可重复读和幻读等问题，但是会影响性能。</li>
</ol>
<p>在 Spring 中，可以通过在事务注解 @Transactional 中指定 isolation 属性来设置隔离级别，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(isolation = Isolation.READ_COMMITTED)</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="17-声明式事务的原理？"><a href="#17-声明式事务的原理？" class="headerlink" title="17. 声明式事务的原理？"></a>17. 声明式事务的原理？</h3><p>主要就是通过AOP动态代理。</p>
<p>简单说分三步：</p>
<ol>
<li>查找@Transation注解，如果目标类是接口使用JDK代理，否则使用Cglib代理。</li>
<li>在执行该方法时，会调用相关的事务处理接口进行处理</li>
</ol>
<h3 id="18-声明式事务在哪些情况下会失效？"><a href="#18-声明式事务在哪些情况下会失效？" class="headerlink" title="**18. 声明式事务在哪些情况下会失效？"></a>**18. 声明式事务在哪些情况下会失效？</h3><ol>
<li>事务传播级别设置错误。有些事务传播会以非事务状态运行</li>
<li>被本类的其他方法调用。比如同一个类A调用了B，此时在B上加了@Transation注解，而A没有，此时调用A事务会失效，本质是因为AOP的原因，因为只有当事务方法被当前类以外的代码调用时，才会由 Spring 生成的代理对象来管理。</li>
<li>rollBackFor设置出错时。因为Java中默认抛出Error或uncheck异常时才回滚事务。</li>
<li>应用在非public方法时。是因为代理对象（JDK和Cglib都会）会调用一个方法获取@Transation注解的信息，而此方法会检查目标方法的修饰符是否为 public，不是 public 则不会获取@Transactional 的属性配置信息。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/12/07/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/07/JVM/" class="post-title-link" itemprop="url">JVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-07 09:16:08" itemprop="dateCreated datePublished" datetime="2022-12-07T09:16:08+08:00">2022-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-14 21:54:03" itemprop="dateModified" datetime="2023-02-14T21:54:03+08:00">2023-02-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/12/07/JVM/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/12/07/JVM/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-什么是JVM？"><a href="#1-什么是JVM？" class="headerlink" title="1. 什么是JVM？"></a>1. 什么是JVM？</h3><p>JVM是指Java虚拟机，在JVM上可以运行Java编译后的字节码文件，也正是因为JVM使得Java具有跨平台性。</p>
<h3 id="2-简单介绍下JVM的内存区域？"><a href="#2-简单介绍下JVM的内存区域？" class="headerlink" title="2. 简单介绍下JVM的内存区域？"></a>2. 简单介绍下JVM的内存区域？</h3><p>JVM内存区域有堆、栈、本地方法栈、虚拟机栈和程序计数器。</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-3.png" alt="Java虚拟机运行时数据区" style="zoom:67%;">

<p>其中方法区和堆是线程共享的。</p>
<p><strong>虚拟机栈：</strong>每个线程都有其自己的虚拟机栈，是其私有的，方法执行时，栈帧会存储其局部变量、操作数栈和动态链接。</p>
<p><strong>本地方法栈：</strong>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
<p><strong>程序计数器：</strong>也被称为 PC 寄存器，是一块较小的内存空间。它可以看作是当前线程所执行的字节码的行号指示器。</p>
<p><strong>Java堆：</strong>Java堆一般都是最大的区域，里面还细分了很多区域，一般垃圾回收都在堆内进行，并且几乎所有的对象创建也在堆上。</p>
<p><strong>方法区：</strong>方法区是比较特别的一块区域，和堆类似，它也是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>它特别在 Java 虚拟机规范对它的约束非常宽松，所以方法区的具体实现历经了许多变迁，例如 jdk1.7 之前使用永久代作为方法区的实现。</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-4.png" alt="Java虚拟机栈" style="zoom: 67%;">

<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-5.png" alt="Java 堆内存结构" style="zoom:67%;">



<h3 id="3-说一下-JDK1-6、1-7、1-8-内存区域的变化？"><a href="#3-说一下-JDK1-6、1-7、1-8-内存区域的变化？" class="headerlink" title="3. 说一下 JDK1.6、1.7、1.8 内存区域的变化？"></a>3. 说一下 JDK1.6、1.7、1.8 内存区域的变化？</h3><p>JDK1.6时使用永久代作为方法区：</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-6.png" alt="JDK 1.6内存区域" style="zoom:67%;">

<p>JDK1.7时将字符串常量池、静态变量，存放在堆上：</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-7.png" alt="JDK 1.7内存区域" style="zoom:67%;">

<p>在 JDK1.8 时彻底干掉了永久代，而在直接内存中划出一块区域作为<strong>元空间</strong>，运行时常量池、类常量池都移动到元空间：</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-8.png" alt="JDK 1.8内存区域" style="zoom:67%;">

<h3 id="4-运行时常量池、类常量池和字符串常量池分别是什么？"><a href="#4-运行时常量池、类常量池和字符串常量池分别是什么？" class="headerlink" title="4. 运行时常量池、类常量池和字符串常量池分别是什么？"></a>4. 运行时常量池、类常量池和字符串常量池分别是什么？</h3><p>运行时常量池（Runtime Constant Pool）是 Java 虚拟机内存中的一块区域，它存储着在类文件的常量池（Class Constant Pool）中的所有常量，并且在运行时期间可以在程序中被引用到。运行时常量池中存储的内容包括了字符串常量、整型常量、浮点型常量等类型。</p>
<p>类常量池（Class Constant Pool）是在编译期间预先在 class 文件中创建的一个常量池，它存储着类的相关信息，如类名、方法名、字符串常量、整型常量等。</p>
<p>字符串常量池（String Constant Pool）是一个特殊的常量池，它存储着字符串常量，并且使用字符串常量池可以节省内存，因为所有的字符串常量在内存中只有一份拷贝，避免了创建多份字符串常量对象所带来的内存浪费。</p>
<h3 id="5-为什么用元空间代替永久代？"><a href="#5-为什么用元空间代替永久代？" class="headerlink" title="5. 为什么用元空间代替永久代？"></a>5. 为什么用元空间代替永久代？</h3><p>有主观和客观两方面的原因。</p>
<ul>
<li>主观上，使用永久代容易产生内存溢出等问题。</li>
<li>客观上，在 Oracle 收购 BEA 获得了 JRockit 的所有权后，为了和JRockit 虚拟机更好兼容，综合考虑替换了。</li>
</ul>
<h3 id="6-对象的加载过程？"><a href="#6-对象的加载过程？" class="headerlink" title="6. 对象的加载过程？"></a>6. 对象的加载过程？</h3><p>容易和类的加载过程混淆。</p>
<ol>
<li>首先查看类是否加载、解析或初始化过。如果没有，则先执行类的加载过程。</li>
<li>类检查完成后，JVM将为新的对象分配内存。</li>
<li>内存分配完成后，JVM将分配到的内存空间初始化为0</li>
<li>接下来初始化对象头，里面包含了该对象时哪个类的实例、如何找到元数据链接、对象的哈希码以及对象的GC分代年龄等信息。</li>
</ol>
<h3 id="7-类的加载过程"><a href="#7-类的加载过程" class="headerlink" title="7. 类的加载过程"></a>7. 类的加载过程</h3><ol>
<li>加载。将类通过类加载器从硬盘里的.class文件加载到内存中</li>
<li>链接。链接包括三个步骤。<ul>
<li>验证：验证语法是否正确</li>
<li>准备：为类变量（静态变量）分配内存，并将其初始化为默认值</li>
<li>解析：此时将符号引用转换为直接引用，符号引用是一种指向类或方法的引用，而直接引用是指向实际内存位置的引用。</li>
</ul>
</li>
<li>初始化：为类变量分配内存，并为其赋值，如果没有赋值则为其默认值。</li>
</ol>
<h3 id="8-什么是指针碰撞？什么是空闲列表？"><a href="#8-什么是指针碰撞？什么是空闲列表？" class="headerlink" title="8. 什么是指针碰撞？什么是空闲列表？"></a>8. 什么是指针碰撞？什么是空闲列表？</h3><p>指针碰撞和空闲列表都是分配内存的方式。</p>
<ul>
<li><strong>指针碰撞：</strong>在内存中有一个指针，指针两侧分别是已分配区域和未分配区域，当有新的对象要分配时，指针向未分配区域移动相应距离。</li>
<li><strong>空闲列表：</strong>内存中已分配区域和未分配区域是不规整的，由一个表来记录每块区域的相关信息，在需要分配时根据记录表查找合适的区域进行分配，分配完成后再更新记录表。</li>
</ul>
<p>两种方式的选择由Java堆是否规整决定，而Java堆是否规整由选择的垃圾回收器是否具有压缩整理能力决定。</p>
<h3 id="9-JVM-里-new-对象时，堆会发生抢占吗？JVM-是怎么设计来保证线程安全的？"><a href="#9-JVM-里-new-对象时，堆会发生抢占吗？JVM-是怎么设计来保证线程安全的？" class="headerlink" title="9. JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？"></a>9. JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？</h3><p>会发生抢占，假如内存正在给一个对象分配时，指针移动需要修改还没来得及移动，此时另一个线程进来，也需要分配内存，这样就会产生冲突，此时有两个解决办法：</p>
<ul>
<li>采用CAS算法保证原子性。</li>
<li>事先为每个线程分配一小段缓存区域（本地线程缓冲区），当有新的线程进来时，先分配到缓冲区，如果缓冲区满了或者放不下，再锁定内存区域同步分配内存区域。</li>
</ul>
<h3 id="10-对象的内存布局是怎样的？"><a href="#10-对象的内存布局是怎样的？" class="headerlink" title="10. 对象的内存布局是怎样的？"></a>10. 对象的内存布局是怎样的？</h3><p>对象主要有对象头、实例数据、对齐填充三部分。</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-12.png" alt="对象的存储布局" style="zoom:67%;">

<ul>
<li><strong>对象头：</strong><ul>
<li>类型指针：表示对象代表哪个类。</li>
</ul>
</li>
<li><strong>实例数据：</strong>用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。</li>
<li><strong>对齐填充：</strong>没有特别含义，相当于占位符。</li>
</ul>
<h3 id="11-内存溢出和内存泄漏是什么意思？"><a href="#11-内存溢出和内存泄漏是什么意思？" class="headerlink" title="11. 内存溢出和内存泄漏是什么意思？"></a>11. 内存溢出和内存泄漏是什么意思？</h3><p>内存泄漏指内存没有被正确释放，使内存被白白占用。</p>
<p>内存溢出指内存超出可用内存限制，而溢出。</p>
<h3 id="12-能手写内存溢出的例子吗？"><a href="#12-能手写内存溢出的例子吗？" class="headerlink" title="12. 能手写内存溢出的例子吗？"></a>12. 能手写内存溢出的例子吗？</h3><ul>
<li><strong>堆溢出：</strong>堆溢出只要不断创建不可被回收的静态变量、静态对象即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"> */</span><br><span class="line">public class HeapOOM &#123;</span><br><span class="line">    static class OOMObject &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            list.add(new OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>虚拟机栈溢出：</strong>虚拟机栈存储的是线程，所以不断创建线程早晚会溢出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * vm参数：-Xss2M</span><br><span class="line"> */</span><br><span class="line">public class JavaVMStackOOM &#123;</span><br><span class="line">    private void dontStop() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void stackLeakByThread() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">        JavaVMStackOOM oom = new JavaVMStackOOM();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-内存泄漏可能由哪些原因造成？"><a href="#13-内存泄漏可能由哪些原因造成？" class="headerlink" title="*13. 内存泄漏可能由哪些原因造成？"></a>*13. 内存泄漏可能由哪些原因造成？</h3><ul>
<li><strong>静态集合类：</strong>静态集合类生命周期和JVM一样，所以一直不会被释放</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class OOM &#123;</span><br><span class="line"> static List list = new ArrayList();</span><br><span class="line"> public void oomTests()&#123;</span><br><span class="line">   Object obj = new Object();</span><br><span class="line">   list.add(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>单例模式：</strong>和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。</li>
<li><strong>数据连接、IO、Socket 等连接：</strong>创建的连接不再使用时，需要调用 <strong>close</strong> 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Connection conn = null;</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    conn = DriverManager.getConnection(&quot;url&quot;, &quot;&quot;, &quot;&quot;);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    ResultSet rs = stmt.executeQuery(&quot;....&quot;);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;finally &#123;</span><br><span class="line">    //不关闭连接</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>变量不合理的作用域：</strong>一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Simple &#123;</span><br><span class="line">    Object object;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        object = new Object();</span><br><span class="line">        //...其他代码</span><br><span class="line">        //由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放</span><br><span class="line">        object = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在《Effective Java》第七条 消除过期的对象引用。在栈弹出操作时，如果是非Java这种没有垃圾回收机制的语言，如果不将其置为空等，就容易发生内存泄漏，因为栈内部还维护着对这些对象的过期引用。所谓过期引用，就是永远不会再被解除的引用。</p>
</blockquote>
<ul>
<li><strong>hash值改变：</strong>假如在HashMap中的某个值，hash改变后，用相同的key将找不到这个值，从而无法删除。<strong>这也是为什么 String 类型被设置成了不可变类型的原因。</strong></li>
</ul>
<blockquote>
<p>String在创建时是会缓存Hash值的，如果改变了就不是其本身了，所以设置成了不可变类型。</p>
</blockquote>
<ul>
<li><strong>ThreadLocal使用不当：</strong>ThreadLocal 的弱引用导致内存泄漏</li>
</ul>
<h3 id="14-解释一下ThreadLocal-的弱引用导致内存泄漏？"><a href="#14-解释一下ThreadLocal-的弱引用导致内存泄漏？" class="headerlink" title="14. 解释一下ThreadLocal 的弱引用导致内存泄漏？"></a>14. 解释一下ThreadLocal 的弱引用导致内存泄漏？</h3><p>ThreadLocal 是 Java 中一种线程级别的数据隔离技术，它可以让每个线程都拥有一份独立的数据副本，从而避免了多个线程之间的数据冲突问题。但是在使用 ThreadLocal 时，如果不注意它的生命周期管理，就可能会导致内存泄漏问题，其中之一就是弱引用导致的内存泄漏。</p>
<p>ThreadLocal 内部维护了一个 Map，用于存储每个线程的数据副本。Map 的 key 是 ThreadLocal 对象的弱引用，value 是对应线程的数据副本。当 ThreadLocal 对象没有被外部强引用时，它就有可能被垃圾回收器回收。但是由于 Map 中的 key 是弱引用，垃圾回收器在回收 ThreadLocal 对象时并不会主动清理对应的 Entry，这就可能导致 Map 中出现 key 为 null 的 Entry，而这些 Entry 对应的 value 就无法被访问，但却一直占用着内存，从而造成内存泄漏。</p>
<p>为了避免这种内存泄漏问题，我们可以通过显式地调用 ThreadLocal 的 remove() 方法来清除当前线程的数据副本，或者在定义 ThreadLocal 变量时使用匿名内部类的方式重写它的 initialValue() 方法，使其返回一个弱引用对象，从而让 ThreadLocal 对象本身成为一个弱引用。这样当 ThreadLocal 对象被垃圾回收时，对应的 Entry 也会被自动清理，避免了内存泄漏问题。</p>
<h3 id="15-如何判断对象仍然存活？"><a href="#15-如何判断对象仍然存活？" class="headerlink" title="15. 如何判断对象仍然存活？"></a>15. 如何判断对象仍然存活？</h3><p>一般有两种算法：引用计数发和可达性分析法。</p>
<p><strong>引用计数法：</strong>简而言之，就是在对象中添加一个引用计数器，当有对象引用时，计数器+1，引用失效时-1，当计数器为0时，则可判断为对象死亡。</p>
<p><strong>可达性分析法：</strong>在JVM中主流的垃圾回收器采用的就是本方法，该方法就是将一系列称为 <code>GC Root</code> 的对象作为搜索起始点，由这个起始点出发向下搜索，搜索过的路径称为引用链，当一个对象到  <code>GC Root</code> 没有任何引用链时，则证明此对象是不可用的。</p>
<p>例如object5、object6、object7虽然互有关联，但它们到GC Roots是不可达的，所以它们将会被判定为可回收对象。</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-18.png" alt="GC Root" style="zoom: 67%;">

<h3 id="16-可作为GC-Root的对象有哪些？"><a href="#16-可作为GC-Root的对象有哪些？" class="headerlink" title="16. 可作为GC Root的对象有哪些？"></a>16. 可作为GC Root的对象有哪些？</h3><ul>
<li>方法区中类静态属性的引用的对象</li>
<li>本地方法栈JNI引用的对象</li>
<li>虚拟机栈的引用的对象</li>
<li>方法区中常量对象引用的对象</li>
</ul>
<h3 id="17-对象有哪些引用？"><a href="#17-对象有哪些引用？" class="headerlink" title="17. 对象有哪些引用？"></a>17. 对象有哪些引用？</h3><p>强引用、软引用、弱引用、虚引用</p>
<h3 id="18-finalize-方法了解吗？有什么作用？"><a href="#18-finalize-方法了解吗？有什么作用？" class="headerlink" title="18. finalize()方法了解吗？有什么作用？"></a>18. finalize()方法了解吗？有什么作用？</h3><p>这个方法用的不多。打个比喻，垃圾回收有点像秋后问斩，而 <code>finalize()</code> 有点像刀下留人。</p>
<p>在垃圾回收时，对象在进行可达性分析后发现没有与 <code>GC Root</code> 关联，则会被第一次标记。之后进行第二次筛选，看是否有必要执行 <code>finalize()</code>——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this 关键字）赋值给某个类变量或者对象的成员变量， ，如果没有，则进行回收。</p>
<h3 id="19-Java的堆分区？"><a href="#19-Java的堆分区？" class="headerlink" title="19. Java的堆分区？"></a>19. Java的堆分区？</h3><p>堆分为新生代和老年代。新生代又分伊甸园区、幸存者1区、幸存者2区，比例为8：1：1。</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-21.png" alt="Java堆内存划分" style="zoom:67%;">

<h3 id="20-介绍下垃圾回收算法？"><a href="#20-介绍下垃圾回收算法？" class="headerlink" title="20. 介绍下垃圾回收算法？"></a>20. 介绍下垃圾回收算法？</h3><ul>
<li><p><strong>标记-清除：</strong>这种算法较简单，就是标记需要回收的对象，之后执行清理操作。但是也存在着两个缺点</p>
<ul>
<li>效率会降低：随着对象和需要清理的对象越来越多，执行效率会降低</li>
<li>空间碎片化问题</li>
</ul>
</li>
<li><p><strong>标记-复制：</strong>本算法则是先将内存区域分为两块，每次只使用一块，等到一块使用完后，将还存活的对象复制到另一块上面，然后把使用过的需要清理的对象一次性清理。</p>
<ul>
<li>本算法缺点就是空间利用率不高，但是由于新生代存活对象不多，每次复制的也只是少量对象，所以采用这个算法。</li>
</ul>
</li>
<li><p><strong>标记-整理：</strong>顾名思义，每次清理完成后，便将还存活的对象向某一端移动。</p>
<ul>
<li>这种方式在老年代使用较多。</li>
</ul>
</li>
</ul>
<h3 id="21-介绍一下新生代内存划分及垃圾回收"><a href="#21-介绍一下新生代内存划分及垃圾回收" class="headerlink" title="21. 介绍一下新生代内存划分及垃圾回收?"></a>21. 介绍一下新生代内存划分及垃圾回收?</h3><p>新生代分伊甸园区、幸存者1区、幸存者2区，比例为8：1：1。每次分配内存时，只使用一块伊甸园区和一块幸存者区，当进行垃圾回收时，便将所有的存活区块复制到另一个未使用的幸存者区，之后再进行垃圾回收。</p>
<h3 id="22-Minor-GC-Young-GC、Major-GC-Old-GC、Mixed-GC、Full-GC-都是什么意思？"><a href="#22-Minor-GC-Young-GC、Major-GC-Old-GC、Mixed-GC、Full-GC-都是什么意思？" class="headerlink" title="22. Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC 都是什么意思？"></a>22. Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC 都是什么意思？</h3><p><strong>部分收集</strong>（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：</p>
<ul>
<li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前<strong>只有</strong>CMS 收集器会有单独收集老年代的行为。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。</li>
</ul>
<p><strong>整堆收集</strong>（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</p>
<h3 id="23-Young-GC会在什么时候发生？"><a href="#23-Young-GC会在什么时候发生？" class="headerlink" title="23. Young GC会在什么时候发生？"></a>23. Young GC会在什么时候发生？</h3><p>新创建的对象优先在新生代 Eden 区进行分配，如果 Eden 区没有足够的空间时，就会触发 Young GC 来清理新生代。</p>
<h3 id="24-什么时候触发Full-FC？"><a href="#24-什么时候触发Full-FC？" class="headerlink" title="24. 什么时候触发Full FC？"></a>24. 什么时候触发Full FC？</h3><ul>
<li>当 <code>老年代目前连续的可用空间大小 &lt; 新生代以往历次Young GC后升入老年代对象大小总和的平均大小  </code></li>
<li>当Young GC后，<code>没有被回收需要升入老年的对象大小 &gt; 老年代可用空间大小</code></li>
<li>当老年代空间使用率过高达到一定比例的时</li>
<li>当To区放不下从From区和eden区拷贝的内容时，或新生代达到阈值需要升到老年代的对象，而老年代放不下时</li>
<li>当调用 <code>System.gc()</code>时</li>
<li>另外，假如方法区还由永久代实现，如果永久代空间不足也会Full GC</li>
</ul>
<h3 id="25-对象在什么情况下会进入老年代？"><a href="#25-对象在什么情况下会进入老年代？" class="headerlink" title="25. 对象在什么情况下会进入老年代？"></a>25. 对象在什么情况下会进入老年代？</h3><ul>
<li>长期存活的对象，在每次Young GC后，会有一个标记移区年龄，当移区年龄大于15（默认，可设置）时，则会进入老年代。</li>
<li>当新生代相同年龄的对象大小总和大于幸存者区空间大小的一半时，大于等于该年龄的都会进入老年代。</li>
<li>当新生代内对象连续占用的空间过大时（可设置参数），会进入老年代。</li>
<li>在Yuong GC后假如新生代还有大量对象存在，到幸存者区无法容纳时，将会进入老年代</li>
</ul>
<h3 id="26-常见的垃圾回收器有哪些？"><a href="#26-常见的垃圾回收器有哪些？" class="headerlink" title="26. 常见的垃圾回收器有哪些？"></a>26. 常见的垃圾回收器有哪些？</h3><ul>
<li>serial收集器：单线程执行，在执行时，需要暂停其他工作线程</li>
<li>ParNew收集器：多线程执行，实际上就是serial的多线程版本</li>
<li>serial Old收集器：属于serial老年版本，单线程执行，采用标记-整理算法</li>
<li>Parallel Old收集器：属于Parallel 老年版本，多线程执行，采用标记-整理算法</li>
<li><strong>CMS 收集器：在收集过程中可以与用户线程并发操作，CMS牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。</strong></li>
<li><strong>Garbage First 收集器：Garbage First（简称 G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于 Region 的内存布局形式。</strong></li>
</ul>
<h3 id="27-什么是Stop-The-World-什么是-OopMap-？什么是安全点？"><a href="#27-什么是Stop-The-World-什么是-OopMap-？什么是安全点？" class="headerlink" title="27. 什么是Stop The World ? 什么是 OopMap ？什么是安全点？"></a>27. 什么是Stop The World ? 什么是 OopMap ？什么是安全点？</h3><p>在垃圾回收的过程中，会涉及到对象的移动。而为了保证对象引用更新的正确性，需要暂停所有的用户线程，像这样的停顿称为 <code>Stop The World</code> 。</p>
<p>在HotSpot中，有个数据结构叫OopMap，它记录了对象偏移量等计算出来。在即时编译的过程中，会在特定的位置上生成OopMap，这些特定的位置就叫安全点。</p>
<p>特定位置可以是：</p>
<ol>
<li>循环的末尾</li>
<li>方法临返回前</li>
<li>可能抛出异常的位置</li>
</ol>
<p>用户程序执行时并不是能够随便停下来的，而是在安全点才能停下来进行垃圾回收。</p>
<h3 id="28-说一下-CMS-收集器的垃圾收集过程？"><a href="#28-说一下-CMS-收集器的垃圾收集过程？" class="headerlink" title="28. 说一下 CMS 收集器的垃圾收集过程？"></a>28. 说一下 CMS 收集器的垃圾收集过程？</h3><ul>
<li><strong>初始标记：</strong>单线程执行，需要 <code>Stop The World</code> ，标记GC Root能直达的对象 </li>
<li><strong>并发标记：</strong>无停顿、根据初始标记的对象，遍历整个对象图</li>
<li><strong>重新标记：</strong>多线程执行，需要 <code>Stop The World</code> ，根据上一步标记需要清除的对象</li>
<li><strong>并发清除：</strong>无停顿，和用户线程同时运行，清除掉所有标记的对象和死亡的对象</li>
</ul>
<h3 id="29-说一下-G1收集器的垃圾收集过程？"><a href="#29-说一下-G1收集器的垃圾收集过程？" class="headerlink" title="29. 说一下 G1收集器的垃圾收集过程？"></a>29. 说一下 G1收集器的垃圾收集过程？</h3><p>G1收集器是垃圾收集器的一个颠覆性产物，开创了局部收集的设计思路和基于Region的内存布局形式。</p>
<p>G1虽然也遵循分代回收的设计，但是其划分方式和其他不同。其他收集器是划分新生代、老年代和持久代。但是G1回收器将连续的Java堆分成多个大小相等的区域（Region），每个区域都可以是Eden区、Survivor区和老年代，收集器可以对扮演不同角色的区域采取不同的回收策略。</p>
<p>这样避免回收整个堆，而是根据若干个Region集进行收集，同时维护一个优先级列表，跟踪各个Region的回收价值，优先收集价值高的Region。</p>
<p>G1收集器运行大致可以划分成四个步骤：</p>
<ul>
<li><strong>初始标记：</strong>标记GC Root可直达的对象，Stop The World执行</li>
<li><strong>并发标记：</strong>根据GC Root可直达的对象，寻找整个堆内要回收的对象，和用户线程并发执行</li>
<li><strong>最终标记：</strong>Stop The World执行，标记上一个阶段产生的垃圾</li>
<li><strong>筛选回收：</strong>Stop The World执行，选择多个Region构成回收集，把存活的对象复制到空的Region中，再把旧的Region全部回收</li>
</ul>
<h3 id="30-有了CMS，为什么还需要G1？"><a href="#30-有了CMS，为什么还需要G1？" class="headerlink" title="30. 有了CMS，为什么还需要G1？"></a>30. 有了CMS，为什么还需要G1？</h3><p>CMS的优点就是——并发收集、低停顿。同时也有缺点：</p>
<ul>
<li>会产生较多的内存碎片。</li>
<li>CMS并发能力比较依赖CPU的性能，并且并发收集阶段用户程序还在运行，可能会影响用户程序的性能。</li>
<li>并发收集时，用户线程仍在运行，会产生所谓的“浮动垃圾”，如果“浮动垃圾”不在此阶段清除，就要到下一阶段，可能会引发再次 Full GC，影响性能。</li>
</ul>
<p>而G1主要解决了内存碎片过多的问题。</p>
<h3 id="31-对象一定分配在堆中吗？有没有了解逃逸分析技术？"><a href="#31-对象一定分配在堆中吗？有没有了解逃逸分析技术？" class="headerlink" title="**31. 对象一定分配在堆中吗？有没有了解逃逸分析技术？"></a>**31. 对象一定分配在堆中吗？有没有了解逃逸分析技术？</h3><p>不一定。随着JIT发展不断对代码进行优化，其中有一部分优化的目的是减少内存堆的分配压力，其中一项技术叫做逃逸分析。</p>
<p>逃逸分析，通俗讲，就是对象被new出来以后，它可能被外部调用，如果是作为参数传递到了外部，则称为方法逃逸。</p>
<img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-37.png" alt="逃逸" style="zoom: 67%;">

<p>除此之外，如果对象还有可能被外部线程访问到，例如赋值给可以在其它线程中访问的实例变量，这种就被称为线程逃逸。</p>
<p><strong>逃逸分析的好处：</strong></p>
<ul>
<li><strong>栈上分配：</strong>如果确定一个对象不会逃逸到线程之外，那么久可以考虑将这个对象在栈上分配，对象占用的内存随着栈帧出栈而销毁，这样一来，垃圾收集的压力就降低很多。</li>
<li><strong>同步消除：</strong>由于线程同步是一个较为耗时的工作，假如一个对象不会逃逸出当前线程，无法被其他线程访问，则可以不进行同步。</li>
<li><strong>标量替换：</strong>如果一个数据是基本数据类型，不可拆分，它就被称之为标量。把一个 Java 对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么可以不创建对象，直接用创建若干个成员变量代替，可以让对象的成员变量在栈上分配和读写。</li>
</ul>
<h3 id="32-一个类的加载过程是怎样的？"><a href="#32-一个类的加载过程是怎样的？" class="headerlink" title="32. 一个类的加载过程是怎样的？"></a>32. 一个类的加载过程是怎样的？</h3><ul>
<li>首先根据全限定类名获取此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转换为方法区运行时数据结构。</li>
<li>在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类各种数据的访问入口。</li>
</ul>
<h3 id="33-类加载器有哪些？"><a href="#33-类加载器有哪些？" class="headerlink" title="33. 类加载器有哪些？"></a>33. 类加载器有哪些？</h3><ul>
<li><strong>启动类（引导类）加载器：</strong>用来加载java核心类库。</li>
<li><strong>扩展类加载器：</strong>它用来加载 Java 的扩展库。</li>
<li><strong>系统类加载器：</strong>它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。</li>
<li><strong>用户自定义类加载器：</strong>用户通过继承 java.lang.ClassLoader 类的方式自行实现的类加载器。</li>
</ul>
<h3 id="34-什么是双亲委派机制？"><a href="#34-什么是双亲委派机制？" class="headerlink" title="34. 什么是双亲委派机制？"></a>34. 什么是双亲委派机制？</h3><p>如果一个类加载器收到了类的加载请求，一般不会自己先去尝试加载这个类，而是委派给父类，一层层向上委派，当父类表示无法加载时，子加载器才会尝试自己去完成加载。</p>
<h3 id="35-为什么要使用双亲委派机制？"><a href="#35-为什么要使用双亲委派机制？" class="headerlink" title="35. 为什么要使用双亲委派机制？"></a>35. 为什么要使用双亲委派机制？</h3><p>为了保证系统的稳定有序。</p>
<p>比如用户自己写了一个名为java.lang.Object类，放在程序的ClassPath中，如果由各个类加载器自行去加载的话，那么系统中就会出现多个不同的Object类。</p>
<h3 id="36-如何自己实现一个热部署功能？"><a href="#36-如何自己实现一个热部署功能？" class="headerlink" title="36. 如何自己实现一个热部署功能？"></a>36. 如何自己实现一个热部署功能？</h3><p>一个类加载首先通过 Java 编译器，将 Java 文件编译成 class 字节码，类加载器读取 class 字节码，再将类转化为实例，对实例 newInstance 就可以生成对象。</p>
<p>类加载器 ClassLoader 功能，也就是将 class 字节码转换到类的实例。在 Java 应用中，所有的实例都是由类加载器，加载而来。</p>
<p>一般在系统中，类的加载都是由系统自带的类加载器完成，而且对于同一个全限定名的 java 类（如 com.csiar.soc.HelloWorld），只能被加载一次，而且无法被卸载。</p>
<p>既然在类加载器中，Java 类只能被加载一次，并且无法卸载。那么我们可以把类加载器去掉并自定义类加载器，重写 ClassLoader 的 findClass 方法（此处可以看下源码，各个类加载器都继承 ClassLoader 类，并重写了findClass方法）</p>
<p>这样实现步骤大致就是：</p>
<ol>
<li>销毁原来的类加载器</li>
<li>更新class类文件</li>
<li>自定义类加载器并重写findClass方法去加载更新后的文件</li>
</ol>
<h3 id="37-Tomcat-的类加载机制了解吗？"><a href="#37-Tomcat-的类加载机制了解吗？" class="headerlink" title="37. Tomcat 的类加载机制了解吗？"></a>37. Tomcat 的类加载机制了解吗？</h3><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-48.png" alt="Tomcat类加载器" style="zoom: 50%;">

<p>Tomcat破坏了双亲委派机制。这是因为Tomcat中可能会部署多个应用，如果多个应用依赖的某一个Jar版本不同，这样使用双亲委派机制，无法加载多个相同的类，因为双亲委派机制就是保证系统的稳定有序，让其加载相同的类。</p>
<p>所以Tomcat提供了隔离机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。每一个 WebAppClassLoader 负责加载本身的目录下的 class 文件，加载不到时再交 CommonClassLoader 加载，这和双亲委派刚好相反。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/11/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Java并发编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-14 16:33:09" itemprop="dateCreated datePublished" datetime="2022-11-14T16:33:09+08:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-14 21:53:53" itemprop="dateModified" datetime="2023-02-14T21:53:53+08:00">2023-02-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/11/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-进程和线程有什么区别？"><a href="#1-进程和线程有什么区别？" class="headerlink" title="1. 进程和线程有什么区别？"></a>1. 进程和线程有什么区别？</h3><ul>
<li>进程是系统进行资源分配和调度的最小单位。</li>
<li>线程是CPU进行调度的最小单位，一个进程可以包含多个线程。</li>
</ul>
<p>比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。</p>
<h3 id="2-进程创建有哪些方式？"><a href="#2-进程创建有哪些方式？" class="headerlink" title="*2. 进程创建有哪些方式？"></a>*2. 进程创建有哪些方式？</h3><ul>
<li>继承Runnable接口，重写run()方法（推荐）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableTask implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Runnable!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RunnableTask task = new RunnableTask();</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承Thread类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static class MyThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;This is child thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的start()方法和主线程是交替执行的，通过调用Thread类的 start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到CPU时间片，就开始执行run()方法。</p>
</blockquote>
<p>上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，可以实现Callable接口</p>
<ul>
<li>实现Callable接口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class CallerTask implements Callable&lt;String&gt; &#123;</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;Hello,i am running!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FutureTask&lt;String&gt; task=new FutureTask&lt;String&gt;(new CallerTask());</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            String result=task.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-什么是CAS算法？"><a href="#3-什么是CAS算法？" class="headerlink" title="3. 什么是CAS算法？"></a>3. 什么是CAS算法？</h3><p>CAS（compare and swap，比较并且交换）算法是通过非阻塞方式避免多线程安全的一种方式，属于乐观锁相关的技术。</p>
<p>简单来说，它维护了三个变量，旧的预期值A、当前内存值V、即将更新的值B，通过while循环不断获取内存中的数值比较并更新。</p>
<p>同时，CAS也存在着一些问题：</p>
<ol>
<li>ABA问题。当且仅当内存值V等于旧的预期值A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。那么如果先将预期值A给成B，再改回A，那CAS操作就会误认为A的值从来没有被改变过，这时其他线程的CAS操作仍然能够成功，但是很明显是个漏洞，因为预期值A的值变化过了。</li>
</ol>
<blockquote>
<p>在Java并发包中，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性，即在变量前面添加版本号，每次变量更新的时候都把版本号+1，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p>
</blockquote>
<ol>
<li>CPU消耗过高的问题，while循环时间过长会极大消耗CPU的性能。</li>
</ol>
<blockquote>
<p>当某一方法比如：getAndAddInt()执行时，如果CAS失败，会一直进行尝试。如果CAS长时间尝试但是一直不成功，可能会给CPU带来很大的开销。</p>
</blockquote>
<ol start="3">
<li>只能保证一个共享变量的原子操作。</li>
</ol>
<blockquote>
<p>当操作1个共享变量时，我们可以使用循环CAS的方式来保证原子操作，但是操作多个共享变量时，循环CAS就无法保证操作的原子性，这个时候就需要用锁来保证原子性。</p>
<p>在多线程环境中，其他线程可能在循环CAS进行更新操作之前修改了其他共享变量的值，从而导致循环CAS的更新操作失效。</p>
</blockquote>
<h3 id="4-Thread-sleep-0-会发生什么？"><a href="#4-Thread-sleep-0-会发生什么？" class="headerlink" title="4. Thread.sleep(0)会发生什么？"></a>4. Thread.sleep(0)会发生什么？</h3><p>首先，sleep()指定毫秒数后，是不一定会在指定的毫秒数后立即执行的，关键至于是否分配到了CPU时间片。</p>
<p>这里，就需要区分Windows和Unix操作系统了。Unix操作系统使用的是时间片算法，Windows操作系统使用的是抢占式算法。<strong>我们现在基于Unix操作系统来讨论。</strong></p>
<p>假如我们调用Thread.sleep(1000)，代表在未来1000毫秒内不参与时间片的竞争，但是在1000毫秒后，如果有优先级更高的线程，那么我们这个休眠了1000毫秒的线程依然不会执行。</p>
<p>而Thread.sleep(0)的作用看上去只是在0毫秒内不参与时间片的竞争，好像写不写没有什么区别，其实不是这样的。Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。<strong>这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。</strong></p>
<blockquote>
<p>所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。</p>
<p>但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。</p>
</blockquote>
<h3 id="5-线程有哪些常用的调度方法？"><a href="#5-线程有哪些常用的调度方法？" class="headerlink" title="5. 线程有哪些常用的调度方法？"></a>5. 线程有哪些常用的调度方法？</h3><p>等待：wait()、wait(long timeout)、join()</p>
<p>通知：notify()、notifyAll()</p>
<p>让出优先权：yield()</p>
<p>中断：interrupt()、interrupted()、isinterrupted()</p>
<p>休眠：sleep()</p>
<blockquote>
<p>假设有两个线程 <code>threadA</code> 和 <code>threadB</code>。如果从 <code>threadA</code> 调用 <code>threadB.join()</code>，<code>threadA</code> 将等待 <code>threadB</code> 完成后再继续执行。</p>
<p>如果调用 <code>join</code> 的线程在等待另一个线程完成时被中断，则 <code>join</code> 方法可能会引发 <code>InterruptedException</code>。</p>
</blockquote>
<blockquote>
<p>thread.yield()表示线程主动放弃CPU，它用于暂时暂停当前线程的执行，并允许其他线程运行。它会被移动到等待运行的线程队列的末尾，其他线程将有机会运行。</p>
<p>“thread.yield()”仅在多线程环境中有效，其行为是平台相关的。不能保证在线程调用”thread.yield()”后立即运行其他线程。实际行为可能取决于操作系统使用的调度程序和其他线程在队列中的优先级。</p>
</blockquote>
<blockquote>
<p>wait()：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回:</p>
<p>（1） 线程A调用了共享对象 notify()或者 notifyAll()方法；</p>
<p><strong>（2）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。</strong></p>
</blockquote>
<h3 id="6-线程有哪几种状态？"><a href="#6-线程有哪几种状态？" class="headerlink" title="*6. 线程有哪几种状态？"></a>*6. 线程有哪几种状态？</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>初始状态：线程被创建，但还没有调用start()方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态：表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态：表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<h3 id="7-什么是守护线程？"><a href="#7-什么是守护线程？" class="headerlink" title="7. 什么是守护线程？"></a>7. 什么是守护线程？</h3><p>线程一般分用户线程和守护线程。</p>
<p>在JVM启动时会调用main函数，main函数所在线程就是用户线程。但是在JVM内部其实还存在其他很多线程，比如垃圾回收线程。在JVM退出后，用户线程会退出，但是守护线程不一定。</p>
<h3 id="8-线程间有哪些通信方式？"><a href="#8-线程间有哪些通信方式？" class="headerlink" title="8. 线程间有哪些通信方式？"></a>8. 线程间有哪些通信方式？</h3><ol>
<li>全局变量：线程可以访问全局变量并对其进行读写操作。</li>
<li>管道（pipe）：管道是一种特殊的文件，它允许不相关进程间的数据交换。</li>
<li>信号量（semaphore）：信号量是一种控制多个线程同时访问共享资源的方法。</li>
<li>消息队列（message queue）：消息队列允许线程通过发送和接收消息来通信。</li>
<li>共享内存（shared memory）：共享内存是一段可供多个线程访问的内存。</li>
<li>互斥量（mutex）：互斥量是一种同步机制，用于防止多个线程同时对共享资源进行访问。</li>
<li>条件变量（condition variable）：条件变量是一种同步机制，用于控制线程的执行顺序。</li>
</ol>
<p>这些通信方式在不同的操作系统和编程语言中可能会有所差异，请以具体环境为准。</p>
<p>在Java中方式如下：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-10.png" alt="线程间通信方式"></p>
<h3 id="9-什么是ThreadLocal？"><a href="#9-什么是ThreadLocal？" class="headerlink" title="9. 什么是ThreadLocal？"></a>9. 什么是ThreadLocal？</h3><p>ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-11.png" alt="ThreadLocal线程副本"></p>
<ul>
<li>创建</li>
</ul>
<p>创建了一个ThreadLocal变量localVariable，任何一个线程都能并发访问localVariable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static ThreadLocal&lt;String&gt; localVariable = new ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>写入</li>
</ul>
<p>线程可以在任何地方使用localVariable，写入变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localVariable.set(&quot;鄙人三某”);</span><br></pre></td></tr></table></figure>

<ul>
<li>读取</li>
</ul>
<p>线程在任何地方读取的都是它写入的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localVariable.get();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果修改了<code>ThreadLocal</code>的值，它将在本线程内生效。每个线程都有自己的<code>ThreadLocal</code>副本，并且每个线程只能修改它自己的副本。因此，当您修改了线程的<code>ThreadLocal</code>值时，不会影响其他线程中的<code>ThreadLocal</code>值。</p>
<p>例如，如果使用<code>ThreadLocal</code>来存储当前用户的名称，并在多个线程中处理请求，则每个线程都有自己的副本，存储了当前处理请求的用户的名称。如果某个线程修改了它的<code>ThreadLocal</code>值，则不会影响其他线程的<code>ThreadLocal</code>值。</p>
</blockquote>
<h3 id="10-使用ThreadLocal举例？"><a href="#10-使用ThreadLocal举例？" class="headerlink" title="10. 使用ThreadLocal举例？"></a>10. 使用ThreadLocal举例？</h3><p>可以用来做用户信息上下文的存储。</p>
<p>我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接口，都会在请求头中携带一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？</p>
<p>一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？</p>
<p>这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取出ThreadLocal中存的用户数据。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-12.png" alt="ThreadLoca存放用户上下文"></p>
<p>很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。</p>
<p>我们常用的数据库连接池也用到了ThreadLocal：</p>
<ul>
<li>数据库连接池的连接交给ThreadLocal进行管理，保证当前线程的操作都是同一个Connnection。</li>
</ul>
<blockquote>
<p>ThreadLocal 内存泄露是怎么回事？：<a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/sidebar/sanfene/javathread.html#_13-threadlocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B">https://tobebetterjavaer.com/sidebar/sanfene/javathread.html#_13-threadlocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B</a></p>
</blockquote>
<h3 id="11-Java中父子线程如何共享数据？"><a href="#11-Java中父子线程如何共享数据？" class="headerlink" title="11. Java中父子线程如何共享数据？"></a>11. Java中父子线程如何共享数据？</h3><p>父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？</p>
<p>这时候可以用到另外一个类——<code>InheritableThreadLocal </code>。</p>
<p>使用起来很简单，在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class InheritableThreadLocalTest &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final ThreadLocal threadLocal = new InheritableThreadLocal();</span><br><span class="line">        // 主线程</span><br><span class="line">        threadLocal.set(&quot;不擅技术&quot;);</span><br><span class="line">        //子线程</span><br><span class="line">        Thread t = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                System.out.println(&quot;鄙人三某 ，&quot; + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：在Thread类里还有另外一个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span><br></pre></td></tr></table></figure>

<p>在Thread.init的时候，如果父线程的<code>inheritableThreadLocals</code>不为空，就把它赋给当前线程（子线程）的<code>inheritableThreadLocals </code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)</span><br><span class="line">    this.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure>



<h3 id="12-volatile关键字的作用？"><a href="#12-volatile关键字的作用？" class="headerlink" title="12. volatile关键字的作用？"></a>12. volatile关键字的作用？</h3><p>volatile有两个作用，保证<strong>可见性</strong>和<strong>有序性</strong>。</p>
<p><strong>可见性：</strong></p>
<p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。</p>
<p>关键字volatile可以用来修饰字段（成员变量），volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p>
<p>例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-26.png" alt="volatile内存可见性"></p>
<p><strong>有序性：</strong></p>
<p>重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。</p>
<h3 id="13-简单介绍下synchronized？"><a href="#13-简单介绍下synchronized？" class="headerlink" title="*13. 简单介绍下synchronized？"></a>*13. 简单介绍下synchronized？</h3><p>Synchronized是用来同步代码，使其在多线程环境下，保证原子性的。</p>
<p>Synchronized有三种用法，一种用于实例方法，一种用于静态代码块，一种用于静态方法。</p>
<ul>
<li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized void method() &#123;</span><br><span class="line">  //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>修饰静态方法</strong>：也就是给当前类加锁，会作用于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。</p>
<p>如果⼀个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调⽤这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized void staic method() &#123;</span><br><span class="line"> //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。 synchronized(类.class) 表示进⼊同步代码前要获得 当前 <strong>class</strong> 的锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(this) &#123;</span><br><span class="line"> //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-Monitor是什么？"><a href="#14-Monitor是什么？" class="headerlink" title="14. Monitor是什么？"></a>14. Monitor是什么？</h3><p>Monitor是一种同步机制，在Java虚拟机（HotSpot）中，Monitor由ObjectMonitor实现的，可以叫内部锁或者Monitor锁。</p>
<h3 id="15-除了原子性，synchronized可见性，有序性，可重入性怎么实现？"><a href="#15-除了原子性，synchronized可见性，有序性，可重入性怎么实现？" class="headerlink" title="15. 除了原子性，synchronized可见性，有序性，可重入性怎么实现？"></a>15. 除了原子性，synchronized可见性，有序性，可重入性怎么实现？</h3><ul>
<li>可见性：</li>
</ul>
<p>在加锁前，将清空线程本地内存中共享变量的值，从而使用共享变量时需要从共享内存中读取。</p>
<p>synchronized的可见性是保证在一个线程访问共享内存时，不让其他线程同时访问，并且在线程修改完某个变量后，将修改后的值，同步刷回到共享内存。</p>
<ul>
<li>有序性：</li>
</ul>
<p>synchronized的有序性是保证在一条线程访问时，禁止另一条线程进入。因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是并不会禁止底层的指令重排。</p>
<ul>
<li>可重入性：</li>
</ul>
<p>synchronized的可重入性是指<strong>允许一个线程二次请求自己持有对象锁的临界资源</strong>，是通过其本身的一个计数器保证的。当一条线程获取到锁时，count计数器加1，线程执行完成后则减1，直到被清零释放锁。</p>
<h3 id="16-as-if-serial又是什么？单线程的程序一定是顺序的吗？"><a href="#16-as-if-serial又是什么？单线程的程序一定是顺序的吗？" class="headerlink" title="16. as-if-serial又是什么？单线程的程序一定是顺序的吗？"></a>16. as-if-serial又是什么？单线程的程序一定是顺序的吗？</h3><p>as-if-serial是指：不管底层指令如何重排序，程序的执行结果不能被改变。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。如果不存在数据依赖关系，则可能被重排序。看以下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;   // A</span><br><span class="line">double r = 1.0;   // B </span><br><span class="line">double area = pi * r * r;   // C</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，C依赖于A和B，但是A和B之前不存在依赖关系。因此，执行顺序可能是A-B-C或B-A-C。</p>
<h3 id="17-什么是指令重排？"><a href="#17-什么是指令重排？" class="headerlink" title="17. 什么是指令重排？"></a>17. 什么是指令重排？</h3><p>指令重排可以分三种情况：</p>
<ol>
<li>编译器优化的重排序：在语句执行时，如果不存在依赖关系，则可以进行重排序。</li>
<li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，使得加载和存储看上去是乱序执行。</li>
<li>指令并行的重排序：现代处理器采用指令并行技术，使得多条指令可以并行执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
</ol>
<h3 id="18-锁的状态有哪些？Synchronized锁是如何升级的？"><a href="#18-锁的状态有哪些？Synchronized锁是如何升级的？" class="headerlink" title="18. 锁的状态有哪些？Synchronized锁是如何升级的？"></a>18. 锁的状态有哪些？Synchronized锁是如何升级的？</h3><p>状态有无锁、偏向锁、轻量级锁、重量级锁。升级是从 无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。</p>
<blockquote>
<p>在JDK1.6以前Synchronized实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong>。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化。</p>
</blockquote>
<p>Java对象头里，有一块结构，叫<code>Mark Word</code>标记字段，这块结构会随着锁的状态变化而变化。</p>
<p>64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-34.png" alt="Mark Word变化"></p>
<h3 id="19-介绍一下各种锁状态？"><a href="#19-介绍一下各种锁状态？" class="headerlink" title="19. 介绍一下各种锁状态？"></a>19. 介绍一下各种锁状态？</h3><p><strong>偏向锁：</strong>偏向锁是在单线程环境下使用的，是防止CAS过度消耗资源。引入偏向锁是为了在多线程竞争的情况下尽量减少不必要的轻量级 锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令。（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所 以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。</p>
<blockquote>
<p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线 程多次获得，因此有了偏向锁。</p>
</blockquote>
<p><strong>轻量级锁：</strong>它的本意是在没有多线程竞争的前提下，减少传统的重量 级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，<strong>轻量级锁所适应的场 景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀 为重量级锁。</strong></p>
<blockquote>
<p><strong>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进 一步提高性能。</strong></p>
</blockquote>
<p><strong>重量级锁：</strong>Synchronized依赖于对象内部的Monitor锁实现。但是这个Monitor锁本质是依赖于底层操作系统的Mutex Lock实现，而线程从用户态切换到内核态开销巨大，这就是为什么重量级锁耗费资源的原因。</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，而是自旋，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>追求吞吐量。同步块执行速度较长。</td>
</tr>
</tbody></table>
<h3 id="20-介绍一下锁的其他优化？"><a href="#20-介绍一下锁的其他优化？" class="headerlink" title="20. 介绍一下锁的其他优化？"></a>20. 介绍一下锁的其他优化？</h3><p><strong>适应性自旋：</strong>在轻量级锁获取不到CPU时，是会通过自旋不断获取的，然而这是比较耗费CPU的，因此做了相关优化。比如某一次自旋获取CPU成功了，那么下一次自旋次数便会增加；如果获取失败了，下一次便会减少。</p>
<p><strong>锁粗化：</strong>当连续几段代码有加锁、解锁操作时，将其合并在一起操作。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StringBufferTest &#123;</span><br><span class="line">    StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">    public void append()&#123;</span><br><span class="line">        stringBuffer.append(&quot;a&quot;);</span><br><span class="line">        stringBuffer.append(&quot;b&quot;);</span><br><span class="line">        stringBuffer.append(&quot;c&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<p><strong>锁消除：</strong>锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。</p>
<h3 id="21-ConcurrentHashMap中的分段锁思想？"><a href="#21-ConcurrentHashMap中的分段锁思想？" class="headerlink" title="21. ConcurrentHashMap中的分段锁思想？"></a>21. ConcurrentHashMap中的分段锁思想？</h3><p>分段锁其实是一种思想，而ConcurrentHashMap则是这种思想的最佳实践。</p>
<p>与ConcurrentHashMap相似的有HashTable，但是因为效率低下而被弃用，其效率低下的主要原因就是众多线程竞争同一把锁。</p>
<p>而ConcurrentHashMap则允许容器中有多个锁，每把锁锁一部分数据，这样就提高了并发时的效率。<strong>首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/554581/201703/554581-20170329093553826-1781572140.png" alt="img"></p>
<p>Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。</p>
<h3 id="22-什么是可重入锁？"><a href="#22-什么是可重入锁？" class="headerlink" title="22. 什么是可重入锁？"></a>22. 什么是可重入锁？</h3><p>可重入锁（Reentrant Lock）是一种常用的同步机制，允许同一线程多次获取锁。也就是说，如果一个线程已经获得了锁，它在释放该锁之前可以再次获取该锁。这是一种递归锁，用于保护复杂的代码块，其中一个线程可以在不释放锁的情况下进入该代码块多次。</p>
<p>可重入锁在多线程环境下非常有用，因为它允许线程在获得锁后再次请求锁而不会发生死锁，并且提高了代码的可读性和可维护性。</p>
<p>例如，在 Java 中，可重入锁通常实现为 java.util.concurrent.locks.ReentrantLock 类。</p>
<h3 id="23-说说Synchronized和ReentrantLock的区别？"><a href="#23-说说Synchronized和ReentrantLock的区别？" class="headerlink" title="*23. 说说Synchronized和ReentrantLock的区别？"></a>*23. 说说Synchronized和ReentrantLock的区别？</h3><ul>
<li><p><strong>锁的实现：</strong> synchronized是Java语言的关键字，基于JVM实现。而ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）</p>
</li>
<li><p><strong>性能：</strong> 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。</p>
</li>
<li><p>功能特点：</p>
<p>ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。</p>
<ul>
<li>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制</li>
<li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li>
<li>synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。</li>
<li>ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-38.png" alt="synchronized和ReentrantLock的区别"></p>
<h3 id="24-什么是AQS？"><a href="#24-什么是AQS？" class="headerlink" title="24. 什么是AQS？"></a>24. 什么是AQS？</h3><p>AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。</p>
<blockquote>
<p>AQS内容较多，暂不过多关注。</p>
</blockquote>
<h3 id="25-简单介绍下ReentrantLock？"><a href="#25-简单介绍下ReentrantLock？" class="headerlink" title="25. 简单介绍下ReentrantLock？"></a>25. <strong>简单介绍下ReentrantLock</strong>？</h3><p>ReentrantLock是可重入独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。</p>
<p>举例看其加锁操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    private int counter = 0;</span><br><span class="line">    private ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    public void incrementCounter() &#123;</span><br><span class="line">        lock.lock(); // 加锁</span><br><span class="line">        try &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock(); // 释放锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getCounter() &#123;</span><br><span class="line">        return counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>new ReentrantLock() </code>构造函数默认创建的是非公平锁 NonfairSync。</p>
<h3 id="26-Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？"><a href="#26-Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？" class="headerlink" title="26. Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？"></a>26. Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？</h3><ul>
<li>使用原子操作类，例如AtomicInteger，实现i++原子操作</li>
<li>使用juc包下的ReentrantLock()，对i++加锁</li>
<li>使用Synchronized，对i++加锁</li>
</ul>
<h3 id="27-原子操作类有哪些？"><a href="#27-原子操作类有哪些？" class="headerlink" title="27. 原子操作类有哪些？"></a>27. 原子操作类有哪些？</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-46.png" alt="原子操作类"></p>
<h3 id="28-AtomicInteger的原理？"><a href="#28-AtomicInteger的原理？" class="headerlink" title="28. AtomicInteger的原理？"></a>28. AtomicInteger的原理？</h3><p>原理就是基于CAS的。</p>
<h3 id="29-什么是线程死锁？如何避免？"><a href="#29-什么是线程死锁？如何避免？" class="headerlink" title="***29. 什么是线程死锁？如何避免？"></a>***29. 什么是线程死锁？如何避免？</h3><p>死锁是指两个线程同时竞争同一个资源，而造成相互等待的现象。</p>
<p>线程死锁的四个条件：互斥条件、请求与保持条件、不可剥夺条件、环路等待条件。</p>
<ul>
<li><strong>互斥条件：</strong>指一个线程对已经获取到的资源排他性使用，当一个线程持有当前资源时，直至其释放，其他线程只能等待。直到占有资源的线程释放资源。</li>
<li><strong>请求与保持条件：</strong>当一个线程持有一个资源时，又请求另一个资源，而另一个资源被占用，从而一直等待造成阻塞，当前线程也不释放资源。</li>
<li><strong>不可剥夺条件：</strong>当一个线程持有一个资源时，其他线程不可剥夺其资源，直到自身使用完成后自己释放。</li>
<li><strong>环路等待条件：</strong>一个线程集合中的线程，形成了环路等待。</li>
</ul>
<p>避免死锁需要<strong>至少</strong>破坏以上四个条件的其中一个：</p>
<ul>
<li>对于互斥条件，不可以破坏，因为加锁就是为了互斥。</li>
<li>对于请求与保持条件，可以通过一次性申请全部资源来破坏。</li>
<li>对于不可剥夺条件，在请求遇到阻塞时，可以通过释放自身的资源来破坏。</li>
<li>对于环路等待条件，可以通过给线程分配优先级，使其有顺序的执行来破坏。</li>
</ul>
<h3 id="30-CountDownLatch（倒计数器）了解吗？"><a href="#30-CountDownLatch（倒计数器）了解吗？" class="headerlink" title="30. CountDownLatch（倒计数器）了解吗？"></a>30. CountDownLatch（倒计数器）了解吗？</h3><p><strong>场景1：协调子线程结束动作：等待所有子线程运行结束</strong></p>
<p>例如，我们很多人喜欢玩的王者荣耀，得等所有人都点击确认之后，才能到选英雄阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    CountDownLatch countDownLatch = new CountDownLatch(5);</span><br><span class="line"></span><br><span class="line">    Thread 大乔 = new Thread(countDownLatch::countDown);</span><br><span class="line">    Thread 兰陵王 = new Thread(countDownLatch::countDown);</span><br><span class="line">    Thread 安其拉 = new Thread(countDownLatch::countDown);</span><br><span class="line">    Thread 哪吒 = new Thread(countDownLatch::countDown);</span><br><span class="line">    Thread 铠 = new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 稍等，上个卫生间，马上到...</span><br><span class="line">            Thread.sleep(1500);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125; catch (InterruptedException ignored) &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    大乔.start();</span><br><span class="line">    兰陵王.start();</span><br><span class="line">    安其拉.start();</span><br><span class="line">    哪吒.start();</span><br><span class="line">    铠.start();</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(&quot;所有玩家已经就位！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>new CountDownLatch(5)</code>用户创建初始的latch数量，各玩家通过<code>countDownLatch.countDown()</code>完成状态确认，主线程通过<code>countDownLatch.await()</code>等待。</p>
<p><strong>场景2. 协调子线程开始动作：统一各线程动作开始的时机</strong></p>
<p>王者游戏中也有类似的场景，游戏开始时，各玩家的初始状态必须一致。不能有的玩家都出完装了，有的才降生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">    Thread 大乔 = new Thread(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 兰陵王 = new Thread(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 安其拉 = new Thread(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 哪吒 = new Thread(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 铠 = new Thread(() -&gt; waitToFight(countDownLatch));</span><br><span class="line"></span><br><span class="line">    大乔.start();</span><br><span class="line">    兰陵王.start();</span><br><span class="line">    安其拉.start();</span><br><span class="line">    哪吒.start();</span><br><span class="line">    铠.start();</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">    System.out.println(&quot;敌方还有5秒达到战场，全军出击！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void waitToFight(CountDownLatch countDownLatch) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        countDownLatch.await(); // 在此等待信号再继续</span><br><span class="line">        System.out.println(&quot;收到，发起进攻！&quot;);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个场景中，仍然用五个线程代表大乔、兰陵王、安其拉、哪吒和铠等五个玩家。需要注意的是，各玩家虽然都调用了<code>start()</code>线程，但是它们在运行时都在等待<code>countDownLatch</code>的信号，在信号未收到前，它们不会往下执行。</p>
<h3 id="31-什么是线程池？"><a href="#31-什么是线程池？" class="headerlink" title="31. 什么是线程池？"></a>31. 什么是线程池？</h3><p>线程池，简单说就是一个拥有很多线程的容器。合理使用线程池有三个好处：</p>
<ol>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ol>
<h3 id="32-实际使用线程池的例子？"><a href="#32-实际使用线程池的例子？" class="headerlink" title="32. 实际使用线程池的例子？"></a>32. 实际使用线程池的例子？</h3><p>用户注册时，防止同一时刻用户注册量过大，使用了多线程。</p>
<h3 id="33-线程池的工作流程？"><a href="#33-线程池的工作流程？" class="headerlink" title="**33. 线程池的工作流程？"></a>**33. 线程池的工作流程？</h3><ol>
<li>当线程池创建时，是没有线程的，任务队列通过参数的形式传入。</li>
<li>当ThreadPoolExecutor调用 execute() 方法添加一个任务时，线程池会做如下判断：</li>
</ol>
<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>
<li>如果队列满了，但是线程数小于最大线程数，那么还是要创建非核心线程立刻运行这个任务；</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。</li>
</ul>
<ol start="3">
<li>当一个线程完成任务后，它会从队列中取下一个任务来执行。</li>
<li>当一个线程闲置时，此时若线程数大于corePoolSize，那么这个线程则会被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>
</ol>
<h3 id="34-线程池的主要参数有哪些？"><a href="#34-线程池的主要参数有哪些？" class="headerlink" title="34. 线程池的主要参数有哪些？"></a>34. 线程池的主要参数有哪些？</h3><ul>
<li><strong>corePoolSize：</strong>核心线程数。如果线程数小于核心线程数，那么新增一个任务便会创建一个新的线程来处理。如果线程数等于核心线程数，那么新增的任务会放到任务队列中。</li>
<li><strong>maximumSize：</strong>最大线程数。如果任务队列满了还有新的线程，并且线程总数小于最大线程数，那么会创建新的线程来处理任务。</li>
<li><strong>keepAliveTime：</strong>非核心线程存活时间。</li>
<li><strong>unit：</strong>非核心线程存活时间单位</li>
<li><strong>workQueue：</strong>工作队列。当核心线程满了，队列还没满的时候，任务会先进入队列中。</li>
<li><strong>threadFactory：</strong>创建线程使用的工厂</li>
<li><strong>handler：</strong>拒绝策略</li>
</ul>
<h3 id="35-线程池拒绝策略有哪些？"><a href="#35-线程池拒绝策略有哪些？" class="headerlink" title="*35. 线程池拒绝策略有哪些？"></a>*35. 线程池拒绝策略有哪些？</h3><ul>
<li><strong>AbortPolicy：直接抛出RejectedExecutionException异常。</strong></li>
<li><strong>CallerRunsPolicy：用调用者所在的线程来执行任务。</strong></li>
<li><strong>DiscardOldestPolicy：丢弃最老的任务</strong>。</li>
<li><strong>DiscardPolicy：直接丢弃任务。</strong></li>
</ul>
<p>下面是一个配置线程池拒绝策略的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = new ThreadPoolExecutor(10,100,60,TimeUnit.SECONDS,</span><br><span class="line">    new ArrayBlockingQueue&lt;&gt;(200),</span><br><span class="line">    new ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>

<p>如果要实现自己的拒绝策略，则可以实现<code>RejectedExecutionHandler</code>接口。</p>
<h3 id="36-线程池有哪几种工作队列？"><a href="#36-线程池有哪几种工作队列？" class="headerlink" title="36. 线程池有哪几种工作队列？"></a>36. 线程池有哪几种工作队列？</h3><ul>
<li><strong>ArrayBlockingQueue：</strong>是一个有界阻塞队列，按FIFO排序。</li>
<li><strong>LinkedBlockingQueue：</strong>是可以设置容量的链表结构的阻塞队列，按FIFO进行排序。如果不对容量进行设置，则是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。吞吐量高于ArrayBlockingQueue，newFixedThreadPool线程池使用的是该队列。</li>
<li><strong>DelayQueue：</strong>是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排列，否则根据插入的先后顺序排列。newScheduleThreadPool线程池使用了该队列。</li>
<li><strong>PriorityBlockingQueue：</strong>具有优先级的无阻塞队列。</li>
<li><strong>SynchronousQueue：</strong>是一个不存储元素的阻塞队列，当一个线程进行插入操作时，必须有另一个线程进行移除操作，否则该插入操作将被一直阻塞。newCacheThreadPool使用了该队列。</li>
</ul>
<h3 id="37-常见的线程池有哪些？"><a href="#37-常见的线程池有哪些？" class="headerlink" title="***37. 常见的线程池有哪些？"></a>***37. 常见的线程池有哪些？</h3><p>常见的线程池有以下四种：</p>
<ul>
<li>newFixedThreadPool：固定线程数目的线程池。</li>
<li>newSingleThreadPool：单线程的线程池。</li>
<li>newCacheThreadPool：可缓存的线程池。</li>
<li>newScheduleThreadPool：定时及周期执行的线程池。</li>
</ul>
<h3 id="38-四种线程池的原理和适用场景？"><a href="#38-四种线程池的原理和适用场景？" class="headerlink" title="**38. 四种线程池的原理和适用场景？"></a>**38. 四种线程池的原理和适用场景？</h3><h5 id="newSingleThreadExecutor："><a href="#newSingleThreadExecutor：" class="headerlink" title="newSingleThreadExecutor："></a>newSingleThreadExecutor：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池特点</strong></p>
<ul>
<li>核心线程数为1</li>
<li>最大线程数也为1</li>
<li>阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM</li>
<li>keepAliveTime为0</li>
</ul>
<p><strong>工作流程：</strong></p>
<ul>
<li>提交任务</li>
<li>线程池中是否有一条线程</li>
<li>如果有，则进入阻塞队列，没有则执行，执行完再取下一个</li>
</ul>
<h5 id="newFixedThreadPool："><a href="#newFixedThreadPool：" class="headerlink" title="newFixedThreadPool："></a>newFixedThreadPool：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池特点</strong></p>
<ul>
<li>核心线程数和最大线程数一样，自定义</li>
<li>阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM</li>
<li>keepAliveTime为0</li>
</ul>
<p><strong>工作流程：</strong></p>
<ul>
<li>提交任务</li>
<li>如果线程数少于核心线程，创建核心线程执行任务</li>
<li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li>
<li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p>
<h5 id="newScheduleThreadPool："><a href="#newScheduleThreadPool：" class="headerlink" title="newScheduleThreadPool："></a>newScheduleThreadPool：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池特点</strong></p>
<ul>
<li>最大线程数为Integer.MAX_VALUE，也有OOM的风险</li>
<li>阻塞队列是DelayedWorkQueue</li>
<li>keepAliveTime为0</li>
<li>scheduleAtFixedRate() ：按某种速率周期执行</li>
<li>scheduleWithFixedDelay()：在某个延迟后执行</li>
</ul>
<p><strong>工作机制</strong></p>
<ul>
<li>线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。</li>
<li>线程执行这个ScheduledFutureTask。</li>
<li>线程修改ScheduledFutureTask的time变量为下次将要被执行的时间。</li>
<li>线程把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add()）。</li>
</ul>
<h5 id="newCacheThreadPool："><a href="#newCacheThreadPool：" class="headerlink" title="newCacheThreadPool："></a>newCacheThreadPool：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池特点：</strong></p>
<ul>
<li>核心线程数为0</li>
<li>最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM</li>
<li>阻塞队列是SynchronousQueue</li>
<li>非核心线程空闲存活时间为60秒</li>
</ul>
<p>工作流程：</p>
<ul>
<li>提交任务</li>
<li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li>
<li>判断是否有空闲线程，如果有，就去取出任务执行。</li>
<li>如果没有空闲线程，就新建一个线程执行。</li>
<li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li>
</ul>
<p><strong>适用场景</strong></p>
<p>用于并发执行大量短期的小任务。</p>
<h3 id="39-线程池提交execute和submit有什么区别？"><a href="#39-线程池提交execute和submit有什么区别？" class="headerlink" title="39. 线程池提交execute和submit有什么区别？"></a>39. 线程池提交execute和submit有什么区别？</h3><ol>
<li>execute 用于提交不需要返回值的任务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub &#125; </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    Object s = future.get(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">    <span class="comment">// 处理中断异常 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123; </span><br><span class="line">    <span class="comment">// 处理无法执行任务异常 </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="comment">// 关闭线程池 executor.shutdown();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="40-线程池的线程数应该怎么配置？"><a href="#40-线程池的线程数应该怎么配置？" class="headerlink" title="40. 线程池的线程数应该怎么配置？"></a>40. 线程池的线程数应该怎么配置？</h3><p>一般的经验，不同类型线程池的参数配置：</p>
<ol>
<li>计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在<strong>页缺失</strong>(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>

<ol>
<li>IO密集型：线程数适当大一点，机器的CPU核心数*2。</li>
<li>混合型：可以考虑根绝情况将它拆分成CPU密集型和IO密集型任务，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。</li>
</ol>
<p>当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。</p>
<h3 id="41-如何关闭线程池？"><a href="#41-如何关闭线程池？" class="headerlink" title="41. 如何关闭线程池？"></a>41. 如何关闭线程池？</h3><p>可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>
<p><strong>shutdown() 将线程池状态置为shutdown,并不会立即停止</strong>：</p>
<ol>
<li>停止接收外部submit的任务</li>
<li>内部正在跑的任务和队列里等待的任务，会执行完</li>
<li>等到第二步完成后，才真正停止</li>
</ol>
<p><strong>shutdownNow() 将线程池状态置为stop。一般会立即停止，事实上不一定</strong>：</p>
<ol>
<li>和shutdown()一样，先停止接收外部提交的任务</li>
<li>忽略队列里等待的任务</li>
<li>尝试将正在跑的任务interrupt中断</li>
<li>返回未执行的任务列表</li>
</ol>
<p>shutdown 和shutdownnow简单来说区别如下：</p>
<ul>
<li>shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。</li>
<li>shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。</li>
</ul>
<h3 id="42-线程池有哪些状态"><a href="#42-线程池有哪些状态" class="headerlink" title="42. 线程池有哪些状态"></a>42. 线程池有哪些状态</h3><p>RUNNING、SHUTDOWM、STOP、TIDYING、TERMINATED</p>
<p>线程池各个状态切换如图所示：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-78.png" alt="线程池状态切换图"></p>
<h3 id="43-你能设计实现一个线程池吗？"><a href="#43-你能设计实现一个线程池吗？" class="headerlink" title="***43.  你能设计实现一个线程池吗？"></a>***43.  你能设计实现一个线程池吗？</h3><ul>
<li>线程池中有N个工作线程</li>
<li>把任务提交给线程池运行</li>
<li>如果线程池已满，把任务放入队列</li>
<li>最后当有空闲时，获取队列中任务来执行</li>
</ul>
<blockquote>
<p>代码参考Cubox的 “一个简单线程池的实现”</p>
</blockquote>
<h3 id="44-单机线程池执行断电了应该怎么处理？"><a href="#44-单机线程池执行断电了应该怎么处理？" class="headerlink" title="44. 单机线程池执行断电了应该怎么处理？"></a>44. 单机线程池执行断电了应该怎么处理？</h3><p>可以对任务队列和线程池做持久化处理，等待恢复供电后根据回溯日志做出相关处理。</p>
<h3 id="45-简单介绍下Fork-Join框架？"><a href="#45-简单介绍下Fork-Join框架？" class="headerlink" title="45. 简单介绍下Fork/Join框架？"></a>45. 简单介绍下Fork/Join框架？</h3><p>Fork/Join框架是Java7提供的一个用于并行执行任务的框架，Fork/Join框架采用的是分而治之的思想，当有许多任务时，分割成许多小任务，将小任务放到不同的任务队列中，创建各自的线程处理这些任务。当有线程先完成任务时，它去其它线程的队列里窃取一个任务来执行，这种方式叫做工作窃取。</p>
<p>减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/11/04/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/04/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Java集合框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-04 10:57:27" itemprop="dateCreated datePublished" datetime="2022-11-04T10:57:27+08:00">2022-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-14 21:54:10" itemprop="dateModified" datetime="2023-02-14T21:54:10+08:00">2023-02-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/11/04/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/04/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-快速失败-fail-fast-和安全失败-fail-safe"><a href="#1-快速失败-fail-fast-和安全失败-fail-safe" class="headerlink" title="1. 快速失败(fail-fast)和安全失败(fail-safe)"></a>1. 快速失败(fail-fast)和安全失败(fail-safe)</h3><p><strong>快速失败：</strong>是Java集合支持的一种快速的失败检测机制，不能在并发情况下使用</p>
<p>原理：在遍历过程中，如果集合内元素发生过修改，则<code>modCount</code>将被改变，而每次遍历将检测<code>modCount</code>的值，如果发生变化，将抛出异常。</p>
<p>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。</p>
<p><strong>安全失败：</strong>在遍历时，不是直接在集合上进行遍历的，而是实现拷贝原有集合内容，在拷贝的集合上进行遍历的。</p>
<p>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>
<p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类。</p>
<h3 id="2-有哪些实现ArrayList线程安全的方法？"><a href="#2-有哪些实现ArrayList线程安全的方法？" class="headerlink" title="2. 有哪些实现ArrayList线程安全的方法？"></a>2. 有哪些实现ArrayList线程安全的方法？</h3><ul>
<li>使用<code>CopyOnWriteArrayList</code>代替。</li>
<li>通过同步机制控制ArrayList的读写。</li>
<li>Vector：Vector是一个线程安全的List,但是它的线程安全实现方式是对所有操作都加上了synchronized关键字，这种方式严重影响效率.所以并不推荐使用Vector。</li>
<li>synchronizedList：示例如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;String&gt;());</span><br><span class="line">list.add(&quot;1&quot;);</span><br><span class="line">list.add(&quot;2&quot;);</span><br><span class="line">list.add(&quot;3&quot;);</span><br><span class="line"></span><br><span class="line">synchronized (list) &#123;</span><br><span class="line">    Iterator i = list.iterator(); // Must be in synchronized block</span><br><span class="line">    while (i.hasNext()) &#123;</span><br><span class="line">        //foo(i.next());</span><br><span class="line">        System.out.println(i.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-CopyOnWriteArrayList的原理"><a href="#3-CopyOnWriteArrayList的原理" class="headerlink" title="3. CopyOnWriteArrayList的原理"></a>3. CopyOnWriteArrayList的原理</h3><p>CopyOnWriteArrayList就是线程安全版本的ArrayList。CopyOnWriteArrayList采用了一种读写分离的并发策略。CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。</p>
<h3 id="4-HashMap的put流程"><a href="#4-HashMap的put流程" class="headerlink" title="4. HashMap的put流程"></a>4. HashMap的put流程</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-13.jpg" alt="HashMap插入数据流程图"></p>
<h3 id="5-HashMap查找操作"><a href="#5-HashMap查找操作" class="headerlink" title="5. HashMap查找操作"></a>5. HashMap查找操作</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-14.png" alt="HashMap查找流程图"></p>
<ol>
<li><p>使用扰动函数，获取新的哈希值</p>
</li>
<li><p>计算数组下标，获取节点</p>
</li>
<li><p>当前节点和key匹配，直接返回</p>
</li>
<li><p>否则，当前节点是否为树节点，查找红黑树</p>
</li>
<li><p>否则，遍历链表查找</p>
</li>
</ol>
<h3 id="6-HashMap的哈希-扰动函数是怎么设计的"><a href="#6-HashMap的哈希-扰动函数是怎么设计的" class="headerlink" title="6. HashMap的哈希/扰动函数是怎么设计的?"></a>6. HashMap的哈希/扰动函数是怎么设计的?</h3><p>HashMap的哈希函数是先拿到 key 的hashcode，是一个32位的int类型的数值，然后让hashcode的高16位和低16位进行异或操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        // key的hashCode和key的hashCode右移16位做异或运算</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>让hashcode的高16位和低16位进行异或操作，目的是为了降低哈希碰撞的概率。</p>
</blockquote>
<h3 id="7-为什么哈希-扰动函数能降hash碰撞？"><a href="#7-为什么哈希-扰动函数能降hash碰撞？" class="headerlink" title="*7. 为什么哈希/扰动函数能降hash碰撞？"></a>*7. 为什么哈希/扰动函数能降hash碰撞？</h3><p>因为<code>key.hashCode()</code> 函数调用的是 key 键值类型自带的哈希函数，返回的是int散列值，而int值的范围是随<strong>编译器</strong>的位数变化的，在32位和64位编译器中，范围是 <code>-2^32 - 1 —— 2^32 -1</code> ，这样的映射空间范围太大，内存根本存不下。所以需要对数组长度取模运算，得到的余数用来访问数组下标。</p>
<p>哈希/扰动函数降低hash碰撞，是通过自身的高16位和低16位进行异或操作，混合原始哈希码的高位和低位，以此来加大低位的随机性，从而降低随机性。</p>
<blockquote>
<p>关于详细说明，访问 <a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_14-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%88%E5%B8%8C-%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E8%83%BD%E9%99%8Dhash%E7%A2%B0%E6%92%9E">https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_14-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%88%E5%B8%8C-%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E8%83%BD%E9%99%8Dhash%E7%A2%B0%E6%92%9E</a></p>
</blockquote>
<h3 id="8-为什么HashMap的容量是2的倍数呢？"><a href="#8-为什么HashMap的容量是2的倍数呢？" class="headerlink" title="8. 为什么HashMap的容量是2的倍数呢？"></a>8. 为什么HashMap的容量是2的倍数呢？</h3><ul>
<li>为了方便哈希取余，这样做可以方便位运算，效率也比 % 取余高。</li>
<li>在扩容的时候，因为扩容的是2的倍数，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞。</li>
</ul>
<h3 id="9-为什么HashMap链表转换成红黑树的阈值为8？"><a href="#9-为什么HashMap链表转换成红黑树的阈值为8？" class="headerlink" title="9. 为什么HashMap链表转换成红黑树的阈值为8？"></a>9. 为什么HashMap链表转换成红黑树的阈值为8？</h3><p>因为和统计学相关，节点个数为8的情况，发生概率小。</p>
<p>至于红黑树回转成链表设置为6是因为，如果设置为8，那么如果发生碰撞，节点的增减恰好在8附近，那么链表和红黑树会不断相互转换，影响效率。</p>
<h3 id="10-HashMap为什么扩容因子是0-75"><a href="#10-HashMap为什么扩容因子是0-75" class="headerlink" title="10. HashMap为什么扩容因子是0.75"></a>10. HashMap为什么扩容因子是0.75</h3><p>这是一种折中的考虑设置。</p>
<p>如果扩容因子比较大，为1，那么空间利用率高了，但是时间成本就高了。</p>
<p>如果扩容因子比较小，为0.5，那么空间利用率就低了。</p>
<h3 id="11-HashMap的扩容机制详解"><a href="#11-HashMap的扩容机制详解" class="headerlink" title="11. HashMap的扩容机制详解"></a>11. HashMap的扩容机制详解</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_21-%E9%82%A3%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97">https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_21-%E9%82%A3%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97</a></p>
</blockquote>
<h3 id="12-JDK1-8对HashMap做了哪些优化？"><a href="#12-JDK1-8对HashMap做了哪些优化？" class="headerlink" title="12. JDK1.8对HashMap做了哪些优化？"></a>12. JDK1.8对HashMap做了哪些优化？</h3><ul>
<li>数据结构由 <code>数组 + 链表</code> 改成 <code>数组 + 链表 + 红黑树</code> ，时间复杂度由 o(n) 下降到 o(logn)</li>
<li>链表由头插法改成尾插法。因为头插法在扩容时链表会发生反转，多线程环境下容易形成环。</li>
<li>扩容rehash。1.7时需要重新hash计算位置，1.8则不用，新的位置不变或者使用索引+新增容量大小。</li>
</ul>
<h3 id="13-手动实现一个HashMap"><a href="#13-手动实现一个HashMap" class="headerlink" title="13. 手动实现一个HashMap"></a>13. 手动实现一个HashMap</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_23-%E4%BD%A0%E8%83%BD%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAhashmap%E5%90%97">https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_23-%E4%BD%A0%E8%83%BD%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAhashmap%E5%90%97</a></p>
</blockquote>
<h3 id="14-HashMap在多线程环境下会出现哪些问题？"><a href="#14-HashMap在多线程环境下会出现哪些问题？" class="headerlink" title="14. HashMap在多线程环境下会出现哪些问题？"></a>14. HashMap在多线程环境下会出现哪些问题？</h3><ul>
<li>同时有get和put的时候，可能出现get为空。如果在put的时候，出现了扩容时，会导致rehash（1.7时重新计算位置，1.8时可能使用索引+新增容量）。</li>
<li>在1.7时，链表的头插法可能在多线程环境下出现环形链表。</li>
<li>同时put可能导致元素缺失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在 JDK 1.7 和 JDK 1.8 中都存在。</li>
</ul>
<h3 id="15-如何解决HashMap线程不安全的问题？"><a href="#15-如何解决HashMap线程不安全的问题？" class="headerlink" title="15. 如何解决HashMap线程不安全的问题？"></a>15. 如何解决HashMap线程不安全的问题？</h3><ul>
<li>使用ConcurrentHashMap，是通过加synchronized 实现的，粒度比较粗。</li>
<li>Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Map map=Collections.synchronizedMap(new HashMap());</span><br></pre></td></tr></table></figure>

<ul>
<li>ConcurrentHashMap 在jdk1.7中使用分段锁，在jdk1.8中使用CAS+synchronized</li>
</ul>
<blockquote>
<p>详解ConcurrentHashMap 在1.7和1.8的区别的原理：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_55611144/article/details/126223849">https://blog.csdn.net/m0_55611144/article/details/126223849</a></p>
<p><a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_26-%E8%83%BD%E5%85%B7%E4%BD%93%E8%AF%B4%E4%B8%80%E4%B8%8Bconcurrenthashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97">https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_26-%E8%83%BD%E5%85%B7%E4%BD%93%E8%AF%B4%E4%B8%80%E4%B8%8Bconcurrenthashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97</a></p>
</blockquote>
<h3 id="16-HashMap-内部节点是有序的吗？"><a href="#16-HashMap-内部节点是有序的吗？" class="headerlink" title="16. HashMap 内部节点是有序的吗？"></a>16. HashMap 内部节点是有序的吗？</h3><p>无序的。如果要有序，可以使用TreeMap或LinkedHashMap。    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/10/26/JavaSE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/26/JavaSE/" class="post-title-link" itemprop="url">JavaSE</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-26 10:56:15" itemprop="dateCreated datePublished" datetime="2022-10-26T10:56:15+08:00">2022-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-14 21:53:45" itemprop="dateModified" datetime="2023-02-14T21:53:45+08:00">2023-02-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/10/26/JavaSE/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/26/JavaSE/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-JVM、JDK-和-JRE-有什么区别"><a href="#1-JVM、JDK-和-JRE-有什么区别" class="headerlink" title="1. JVM、JDK 和 JRE 有什么区别"></a>1. JVM、JDK 和 JRE 有什么区别</h3><p>JVM是Java虚拟机，Java程序运行在JVM上。而正是因为JVM，使得Java具有了跨平台性。</p>
<p>JRE是Java运⾏时环境，包含在JDK内，它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。</p>
<p>JDK提供了开发Java程序所需的一系列类包、环境等，它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<h3 id="2-为什么说Java语言“编译与解释并存”？"><a href="#2-为什么说Java语言“编译与解释并存”？" class="headerlink" title="2. 为什么说Java语言“编译与解释并存”？"></a>2. 为什么说Java语言“编译与解释并存”？</h3><p>高级编程语言按照程序的执行方式分为<strong>编译型</strong>和<strong>解释型</strong>两种。</p>
<p>说Java是编译型是因为，Java语言是经过编译器编译成字节码后在JVM上运行的。</p>
<p>说Java是解释型是因为，字节码需要在JVM上经过解释成操作系统能识别的语言（机器码），再由操作系统去执行。</p>
<h3 id="3-Java-有哪些数据类型？"><a href="#3-Java-有哪些数据类型？" class="headerlink" title="3. Java 有哪些数据类型？"></a>3. Java 有哪些数据类型？</h3><p>Java的数据类型分为<strong>基本数据类型</strong>和<strong>引用类型</strong>。</p>
<p>基本数据类型有：int，long，float，byte，short，double，char，boolean</p>
<p>引用类型有：class、interface、数组</p>
<p><strong>引申：为什么Java里有基本数据类型和引用数据类型？</strong></p>
<pre><code>     存储方式：引用类型在堆里而基本类型在栈里。栈空间小且连续，存取速度比较快；在堆中则需要new，对基本数据类型来说空间浪费率太高；
 
 传值方式：基本类型是在方法中定义的非全局基本数据类型变量，调用方法时作为参数是按数值传递的；引用数据类型变量，调用方法时作为参数是按引用地址传递的；
</code></pre>
<blockquote>
<p>如果不声明，默认小数为double类型，所以如果要用float的话，必须进行强转</p>
<p>例如：float a=1.3; 会编译报错，正确的写法 float a = (float)1.3;或者float a = 1.3f;（f或F都可以不区分大小写）</p>
</blockquote>
<h3 id="4-详解装箱和拆箱"><a href="#4-详解装箱和拆箱" class="headerlink" title="4. 详解装箱和拆箱"></a>4. 详解装箱和拆箱</h3><h3 id="5-抽象类-abstract-class-和接口-interface-有什么区别？"><a href="#5-抽象类-abstract-class-和接口-interface-有什么区别？" class="headerlink" title="5. 抽象类(abstract class)和接口(interface)有什么区别？"></a>5. 抽象类(abstract class)和接口(interface)有什么区别？</h3><ol>
<li>接口的方法默认是 public ，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>
<li>⼀个类可以实现多个接口，但只能实现⼀个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li>
<li>从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，而接口是对行为的抽象，是⼀种行为的规范。</li>
<li>抽象类和接口都不能实例化。</li>
</ol>
<blockquote>
<p>总结⼀下 jdk7~jdk9 Java 中接⼝的变化：</p>
<ol>
<li>在 jdk 7 或更早版本中，接⼝⾥⾯只能有常量变量和抽象⽅法。这些接⼝⽅法必须由选择实现接⼝的类实现。</li>
<li>jdk 8 的时候接⼝可以有默认⽅法和静态⽅法功能。</li>
<li>jdk 9 在接⼝中引⼊了私有⽅法和私有静态⽅法。</li>
</ol>
</blockquote>
<h3 id="6-final关键字的作用"><a href="#6-final关键字的作用" class="headerlink" title="6. final关键字的作用"></a>6. final关键字的作用</h3><p>final关键字表示不可变，可以修饰类、属性和方法。</p>
<p>被final修饰的类不可继承。</p>
<p>被final修饰的属性不可变，<strong>被 final 修饰的变量必须被显式第指定初始值，还得注意的是，这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变。</strong></p>
<p>被final修饰的方法不可被重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">System.out.println(sb);  <span class="comment">//abcd</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 上面的例子则说明了变量不可变的含义是指引用不可变。</p>
</blockquote>
<h3 id="7-重写和重载的区别"><a href="#7-重写和重载的区别" class="headerlink" title="7. 重写和重载的区别"></a>7. 重写和重载的区别</h3><p><strong>重载</strong>：</p>
<p>方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。<strong>重载Overloading是一个类中多态性的一种表现。</strong></p>
<p><strong>重写：</strong></p>
<p>1）参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</p>
<p>2）返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。</p>
<p>3）访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</p>
<p>4）重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：</p>
<p>父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int doSomething() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 输入参数不同，意味着方法签名不同，重载的体现</span><br><span class="line">public int doSomething(List&lt;String&gt; strs) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// return类型不一样，编译不能通过</span><br><span class="line">public short doSomething() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-final、finally、finalize-的区别？"><a href="#8-final、finally、finalize-的区别？" class="headerlink" title="8. final、finally、finalize 的区别？"></a>8. final、finally、finalize 的区别？</h3><p>final：见第6点。</p>
<p>finally：是和try、catch结合使用的。finally包含的代码块，一定会被执行。</p>
<p>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。</p>
<h3 id="9-和-equals-的区别？"><a href="#9-和-equals-的区别？" class="headerlink" title="9. ==和 equals 的区别？"></a>9. ==和 equals 的区别？</h3><p>对于基本数据类型，==比较的是他们的值，而基本数据类型没有equals方法。</p>
<p>对于引用类型，==比较的是他们的地址。<strong>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</strong></p>
<p><strong>诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</strong></p>
<h3 id="10-为什么重写-equals-时必须重写-hashCode-方法？"><a href="#10-为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="10. 为什么重写 equals 时必须重写 hashCode 方法？"></a>10. 为什么重写 equals 时必须重写 hashCode 方法？</h3><p>因为如果两个对象相等，那么他们的hash值一定相等，对两个对象分别调⽤ equals 方法都返回 true。反之如果两个对象hash值相等，他们不一定相等。因此，<strong>equals</strong> 方法被覆盖过，则 <strong>hashCode</strong> 方法也必须被覆盖。</p>
<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode() ，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>
<h3 id="11-Java-是值传递，还是引用传递？"><a href="#11-Java-是值传递，还是引用传递？" class="headerlink" title="11. Java 是值传递，还是引用传递？"></a>11. Java 是值传递，还是引用传递？</h3><p>Java 语言是<strong>值传递</strong>。JVM 的内存分为堆和栈，其中栈中存储了基本数据类型和引用数据类型实例的地址，也就是对象地址。</p>
<p>而对象所占的空间是在堆中开辟的，所以传递的时候可以理解为把变量存储的对象地址给传递过去，因此引用类型也是值传递。</p>
<h3 id="12-Java如何实现浅拷贝和深拷贝？"><a href="#12-Java如何实现浅拷贝和深拷贝？" class="headerlink" title="12. Java如何实现浅拷贝和深拷贝？"></a>12. Java如何实现浅拷贝和深拷贝？</h3><p>浅拷贝：Object 类提供的 clone()方法可以非常简单地实现对象的浅拷贝。</p>
<p>深拷贝：</p>
<ul>
<li>重写克隆方法：重写克隆方法，引用类型变量单独克隆，这里可能会涉及多层递归。</li>
<li>序列化：可以先将原对象序列化，再反序列化成拷贝对象。</li>
</ul>
<h3 id="13-Java创建对象有哪些方式？"><a href="#13-Java创建对象有哪些方式？" class="headerlink" title="13. Java创建对象有哪些方式？"></a>13. Java创建对象有哪些方式？</h3><ul>
<li>new 创建新对象</li>
<li>通过反射机制</li>
<li>采用 clone 机制</li>
<li>通过序列化机制</li>
</ul>
<h3 id="14-String-不是不可变类吗？字符串拼接是如何实现的？"><a href="#14-String-不是不可变类吗？字符串拼接是如何实现的？" class="headerlink" title="14. String 不是不可变类吗？字符串拼接是如何实现的？"></a>14. String 不是不可变类吗？字符串拼接是如何实现的？</h3><p>在<strong>jdk1.8 之前</strong>，a 和 b 初始化时位于字符串常量池，ab 拼接后的对象位于堆中。经过拼接新生成了 String 对象。如果拼接多次，那么会生成多个中间对象。</p>
<p>内存如下：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-18.png" alt="jdk1.8之前的字符串拼接"></p>
<p>在<strong>Java8 时</strong>JDK 对“+”号拼接进行了优化，上面所写的拼接方式会被优化为基于 StringBuilder 的 append 方法进行处理。Java 会在编译期对“+”号进行处理。</p>
<p><strong>这样看，使用 + 号 和使用 StringBuilder  是没有区别的，在一般情况下是这样，但是在循环里面，建议使用 StringBuilder 。</strong></p>
<p>举个例子，看一段这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s= &quot;&quot; ;</span><br><span class="line">    for(int i=1;i&lt;10;i++)&#123;</span><br><span class="line">    	s+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用jad工具反编译代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">	String s = &quot;&quot;:</span><br><span class="line">	for(int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">		s = (new StringBuilder(String.valueOf(s))).append(i).tostring() ;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.printin(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的做法应该是在循环外层先创建好StringBuilder 对象，然后在循环体内使用append 方法进行处理。</p>
<h3 id="15-什么是序列化？什么是反序列化？Serializable-接口有什么用？"><a href="#15-什么是序列化？什么是反序列化？Serializable-接口有什么用？" class="headerlink" title="15. 什么是序列化？什么是反序列化？Serializable 接口有什么用？"></a>15. 什么是序列化？什么是反序列化？Serializable 接口有什么用？</h3><p>序列化是将Java对象转换为二进制流，反序列化是将二进制流转换为对象。</p>
<p>这个接口只是一个标记，没有具体的作用，但是如果不实现这个接口，在诸如使用Dubbo等RPC调用场景的情况下，会抛出异常。</p>
<h5 id="Dubbo-RPC-方法类都要实现Serializable接口的原因"><a href="#Dubbo-RPC-方法类都要实现Serializable接口的原因" class="headerlink" title="Dubbo RPC 方法类都要实现Serializable接口的原因"></a>Dubbo RPC 方法类都要实现Serializable接口的原因</h5><p>dubbo在使用hessian2协议序列化方式的时候，对象的序列化使用的是JavaSerializer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.com.caucho.hessian.io.SerializerFactory#getDefaultSerializer</span><br><span class="line"></span><br><span class="line">com.alibaba.com.caucho.hessian.io.SerializerFactory#getSerializer</span><br><span class="line"></span><br><span class="line">com.alibaba.com.caucho.hessian.io.Hessian2Output#writeObject</span><br></pre></td></tr></table></figure>

<p>获取默认的序列化方式的时候，会判断该参数是否实现了Serializable接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected Serializer getDefaultSerializer(Class cl) &#123;</span><br><span class="line">    if (_defaultSerializer != null)</span><br><span class="line">        return _defaultSerializer;</span><br><span class="line">    // 判断是否实现了Serializable接口</span><br><span class="line">    if (!Serializable.class.isAssignableFrom(cl)</span><br><span class="line">        &amp;&amp; !_isAllowNonSerializable) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Serialized class &quot; + cl.getName() + &quot; must implement java.io.Serializable&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return new JavaSerializer(cl, _loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-Java-泛型了解么？什么是类型擦除？为什么要类型擦除？介绍一下常用的通配符？"><a href="#16-Java-泛型了解么？什么是类型擦除？为什么要类型擦除？介绍一下常用的通配符？" class="headerlink" title="16. Java 泛型了解么？什么是类型擦除？为什么要类型擦除？介绍一下常用的通配符？"></a>16. Java 泛型了解么？什么是类型擦除？为什么要类型擦除？介绍一下常用的通配符？</h3><p>Java泛型是JDK1.5的特性，<strong>泛型本质上是参数化类型，也就是说操作的数据类型被指定为一个参数。</strong></p>
<p>类型擦除是指在编译时，所有的泛化类型被擦除，转换成实际需要的类型。</p>
<p>需要类型擦除主要是为了向下兼容，因为 JDK5 之前是没有泛型的，为了让 JVM 保持向下兼容，就出了类型擦除这个策略。</p>
<p>常见通配符有K、T、E、V。</p>
<h3 id="17-正向代理和反向代理的区别"><a href="#17-正向代理和反向代理的区别" class="headerlink" title="17. 正向代理和反向代理的区别"></a>17. 正向代理和反向代理的区别</h3><p>网络代理分为正向代理和反向代理，代理其实就是一个中介，最初的时候，只有正向代理，是帮助内网客户端访问外网服务器的，后来出现了反向代理，是把外网客户端的请求转发给内网服务器。<br>其实最简单的区别，正向代理代理的是客户端，反向代理代理的是服务器。正向代理一般是客户端架设的，反向代理一般是服务器架设的。<br>1、代理对象不同。正向代理代理的是客户端，反向代理代理的是服务器。正向代理帮助客户访问其无法访问的服务器资源，反向代理帮助服务器做负载均衡，另外，由于客户端跟真实服务器不直接接触，能起到一定安全防护的作用。<br>2、架设主体不同。正向代理一般是客户端架设的，比如在自己的机器上装一个代理软件，反向代理一般是服务器架设的，通常是在机器集群中部署个反向代理服务器。<br>3、保护对象不同。正向代理保护对象是客户端，反向代理保护对象是原始资源服务器。<br>4、作用目的不同。正向代理主要目的是解决访问限制问题，而反向代理一方面是作为负载均衡，再就是起到安全防护的作用。</p>
<h3 id="18-在Java中，String为什么设置成不可变类型"><a href="#18-在Java中，String为什么设置成不可变类型" class="headerlink" title="18. 在Java中，String为什么设置成不可变类型"></a>18. 在Java中，String为什么设置成不可变类型</h3><p>在Java中，String被设计成不可变类型，是为了提高字符串的安全性和可靠性。具体来说，有以下几个原因：</p>
<ol>
<li>线程安全：由于字符串是不可变的，所以多个线程可以同时访问同一个字符串对象，而不需要担心数据被篡改，从而提高了程序的线程安全性。</li>
<li>缓存哈希值：由于字符串的哈希值在创建时就被缓存起来了，所以不需要每次使用字符串时都重新计算哈希值，从而提高了程序的性能。</li>
<li>安全性：由于字符串是不可变的，所以在使用字符串时不需要担心数据被意外修改，从而提高了程序的安全性。</li>
<li>简化代码：由于字符串是不可变的，所以在使用字符串时可以省去一些代码，比如不需要手动处理字符串的长度、位置等信息，从而使代码更加简洁易懂。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/10/18/%E5%B8%88%E7%94%9F%E5%8F%8C%E9%80%89%E7%B3%BB%E7%BB%9F%E9%92%89%E9%92%89%E7%89%88%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/18/%E5%B8%88%E7%94%9F%E5%8F%8C%E9%80%89%E7%B3%BB%E7%BB%9F%E9%92%89%E9%92%89%E7%89%88%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">师生双选系统钉钉版实现过程总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-18 14:32:41" itemprop="dateCreated datePublished" datetime="2022-10-18T14:32:41+08:00">2022-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-23 17:23:17" itemprop="dateModified" datetime="2023-02-23T17:23:17+08:00">2023-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">项目总结</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/10/18/%E5%B8%88%E7%94%9F%E5%8F%8C%E9%80%89%E7%B3%BB%E7%BB%9F%E9%92%89%E9%92%89%E7%89%88%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/18/%E5%B8%88%E7%94%9F%E5%8F%8C%E9%80%89%E7%B3%BB%E7%BB%9F%E9%92%89%E9%92%89%E7%89%88%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-需求分析"><a href="#一-需求分析" class="headerlink" title="一. 需求分析"></a>一. 需求分析</h2><h4 id="用户提出需求"><a href="#用户提出需求" class="headerlink" title="用户提出需求"></a>用户提出需求</h4><p>本系统是学院老师，希望给即将毕业的本科生，提供一个双选导师的平台，指导论文的编写，并希望该系统能够接入钉钉使用，用户提出的大致需求如下：</p>
<blockquote>
<p>1、导入老师信息（系部，工号，姓名，研究方向，可指导本科生人数）；<br>2、导入学生信息（学号，专业，姓名）；<br>3、学生可以选择本系部的导师（先到先得，满8人后，此导师就不可以再被选择）；<br>4、导师可以点是否同意接收此学生。如果不同意，取消被选，导师名额增加一个，该学生再不能选该导师；<br>5、后台管理员可以设置什么时候开始双选，什么时候截止。</p>
</blockquote>
<h4 id="补充需求"><a href="#补充需求" class="headerlink" title="补充需求"></a>补充需求</h4><p>对于初次需求，用户进行了完善，新增需求点如下：</p>
<blockquote>
<ol>
<li>学生志愿可以填写3个，第一轮一志愿的老师选择确认，第二轮二志愿的老师选择，第三轮三志愿的老师选择。三轮结束后，学生和导师自动匹配。</li>
<li>老师的界面可以显示学生的绩点和100字以内的自荐信。</li>
</ol>
</blockquote>
<h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>在用户提出需求后，一般来说，都是会有不少瑕疵或者没考虑到的功能点的，所以需要开发人员细化需求，对其进一步拆解。</p>
<p>从上面的需求我们可以提炼出三个角色——管理员、学生、导师。而我们对功能点的分析也应该从这三个角色展开分析。</p>
<h5 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h5><p>对于管理员角色，用户希望能够设置双选时间区间，并且能够导入学生和老师信息。</p>
<p>此时，我们对管理员的设置双选时间区间功能点应该拆分为两块，一个是在没有双选时间的时候，新增双选时间；另一块是在数据库中已经存在双选时间的时候，更新双选时间。对于导入学生老师信息功能相对明确。</p>
<p>从上面的需求看，管理员的功能用户只提出了两个功能，但是仔细分析，我们会发现这两个功能显然是不够的。</p>
<p>首先，双选完成后，<strong>双选结果管理员是不是也需要能看到？看到结果是不是也需要一个导出功能？</strong>如果仅仅只是能看，不能导出那这个系统就极大不便了，这也是后期用户肯定会提出来的。</p>
<p>其次，对于用户，管理员是不是需要能够对其进行管理？比如修改某个用户信息，去年的双选学生需要删除，获取今年新增的老师也要加进来等等，因此，<strong>管理员还需要用户管理功能，而不仅仅只是导入功能</strong>。</p>
<p>这样，我们需要在用户提出需求的基础上，新增两个功能点：</p>
<blockquote>
<ol>
<li>双选结果查看并导出；</li>
<li>用户管理。</li>
</ol>
</blockquote>
<h5 id="学生"><a href="#学生" class="headerlink" title="学生"></a>学生</h5><p>从用户的初次需求和补充需求来看，用户提出的功能点是学生能够在系统内选择导师，补充需求提出学生能够填写自荐信。而系统涉及的功能点还包括对学生能够选择的导师进行筛选，这块我们后面分析。</p>
<p>这样，学生角色功能点如下：</p>
<blockquote>
<ol>
<li>选择导师</li>
</ol>
</blockquote>
<h5 id="导师"><a href="#导师" class="headerlink" title="导师"></a>导师</h5><p>从用户的初次需求和补充需求来看，提出的需求较为模糊。用户描述是“导师可以点是否同意接收此学生。如果不同意，取消被选，导师名额增加一个，该学生再不能选该导师”。</p>
<p>作为开发人员，对于前面一句话，其实要分析为：导师同意接收时名额减一，拒绝时流转到下一个流程。而对于学生不能再选择导师，即在学生填写志愿时判断不能有重复导师即可。</p>
<p>这样，导师角色功能点如下：</p>
<blockquote>
<ol>
<li>同意、拒绝接收</li>
<li>查看双选结果</li>
</ol>
</blockquote>
<h4 id="得出流程图"><a href="#得出流程图" class="headerlink" title="得出流程图"></a>得出流程图</h4><p><img src="https://img.hznu.online/blog/%E9%9C%80%E6%B1%82%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h2 id="二-结合钉钉分析"><a href="#二-结合钉钉分析" class="headerlink" title="二. 结合钉钉分析"></a>二. 结合钉钉分析</h2><p>看完上面的分析，应该会角色功能其实不多，应该也很容易可以开发完成，但是这也是很多开发者在开发初期容易产生的错觉。</p>
<blockquote>
<p>所有的编程人员都是乐观主义者。          —-《人月神话》</p>
</blockquote>
<p>我们来结合钉钉梳理一下需求，以及开发过程中我们需要考虑的问题。</p>
<h4 id="应用类型"><a href="#应用类型" class="headerlink" title="应用类型"></a>应用类型</h4><p>在开发初期，我们明确了要做能够接入钉钉的应用。而通过阅读文档会发现，钉钉的应用是分很多种的，每种的功能限制是不一样的，比如有些可以调用钉钉消息通知的接口，而有些不行。同时，不同应用虽然有些功能都可以做到，但是他们调用的API也是不一样的。</p>
<p>钉钉的应用类型如下：</p>
<table>
<thead>
<tr>
<th>应用类型</th>
<th>开发者</th>
<th>使用人员</th>
<th>支持的能力</th>
<th>是否支持上架到钉钉应用广场</th>
</tr>
</thead>
<tbody><tr>
<td>企业内部应用</td>
<td>企业内部开发者或委托的服务商开发者</td>
<td>安装了该应用的企业内部人员</td>
<td>小程序支持移动端H5微应用支持移动端支持PC端机器人</td>
<td>否</td>
</tr>
<tr>
<td>第三方企业应用</td>
<td>产品方案商的开发者</td>
<td>购买开通该三方应用的企业内部人员</td>
<td>小程序支持移动端H5微应用支持移动端支持PC端</td>
<td>是，需要满足上架要求，上架流程请参考<a target="_blank" rel="noopener" href="https://open.dingtalk.com/document/operation-specification/isv-cooperation-guide#topic-2057068">合作全流程指引</a>。</td>
</tr>
<tr>
<td>第三方个人应用</td>
<td>产品方案商的开发者</td>
<td>钉钉的个人用户</td>
<td>小程序支持移动端</td>
<td>否</td>
</tr>
</tbody></table>
<p>进一步阅读各种类型的文档得出，企业内部应用最符合我们的需求，并且可以很方便调用大部分API，因此，类型<strong>我们选择为企业内部应用</strong>。</p>
<h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>权限控制在没有开发经验的用户不会提出的需求点，但是开发人员是需要重点关注的。</p>
<p>既然我们要做的是钉钉小程序，那么权限控制就理应交给钉钉去控制，而我们去获取钉钉的数据，因此，就需要阅读文档，去了解钉钉是如何实现权限控制以及用户如何登录的。</p>
<p>通过阅读企业内部应用免登流程后，我们可以总结出，实现企业内部应用免登，是让企业员工在钉钉内使用企业内部应用时无需输入账号和密码，其登录流程如下：</p>
<ol>
<li><p>获取免登授权码（AuthCode，客户端调用获取）。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://open.dingtalk.com/document/orgapp-client/mini-program-free-login">小程序免登</a></li>
<li><a target="_blank" rel="noopener" href="https://open.dingtalk.com/document/orgapp-client/logon-free-process">微应用免登</a></li>
</ul>
</li>
<li><p>获取AccessToken。</p>
<p>调用接口获取access_token，详情参考<a target="_blank" rel="noopener" href="https://open.dingtalk.com/document/orgapp-server/obtain-orgapp-token">获取企业内部应用的access_token</a>。</p>
</li>
<li><p>获取userid。</p>
<p>调用接口获取用户的userid，详情参考<a target="_blank" rel="noopener" href="https://open.dingtalk.com/document/orgapp-server/obtain-the-userid-of-a-user-by-using-the-log-free">通过免登码获取用户信息</a>。</p>
</li>
<li><p>获取用户详情。</p>
<p>调用接口获取用户详细信息，详情参考<a target="_blank" rel="noopener" href="https://open.dingtalk.com/document/orgapp-server/query-user-details">根据userId获取用户详情</a>。</p>
</li>
</ol>
<h4 id="用户信息管理"><a href="#用户信息管理" class="headerlink" title="用户信息管理"></a>用户信息管理</h4><p>对于用户信息，是开发过程中需要重点关注的问题。用户提出需求是系统管理员能够导入学生和导师信息。如果这里在师生双选系统中，单独做一个导入功能的话，那么就需要用户做一张excel表，核对各种信息后，然后去导入用户信息。</p>
<p>这样做确实不难，目前市面上非常多excel导入导出组件，可以很方便实现。但是，如果采用这种方式的话，做出来的系统是不是钉钉小程序区别不大。</p>
<p>因为这样做，你的用户信息没办法和钉钉交互，而你也没办法使用钉钉的消息通知，待办事项通知等等功能。学生选择完成导师后，导师需要进入应用才能看到学生的双选信息，然后再进行操作，这显然意义不大，也没有充分利用钉钉小程序的特性，我认为这样实现是一个失败的产品。</p>
<p>所以，对于用户管理，我们借助钉钉帮我们实现。但是，如果在原有用户基础上操作的话，容易影响其他功能使用，也不够安全。因此，我们在钉钉管理界面新建一个“师生双选部门”，并新增三个子部门：“导师”、“学生”、“管理员”，如下图所示：</p>
<p><img src="https://img.hznu.online/blog/%E6%96%B0%E5%A2%9E%E5%B8%88%E7%94%9F%E5%8F%8C%E9%80%89%E9%83%A8%E9%97%A8.png"></p>
<p>对于用户信息，从需求看，还需要绩点和招生人数两个信息，因此，我们需要新增拓展字段，并对学生角色隐藏“招生人数”此类敏感信息，如下图所示：</p>
<p><img src="https://img.hznu.online/blog/%E6%8B%93%E5%B1%95%E5%AD%97%E6%AE%B5%E8%AE%BE%E7%BD%AE.png"></p>
<h4 id="API调用权限控制"><a href="#API调用权限控制" class="headerlink" title="API调用权限控制"></a>API调用权限控制</h4><p>对于每个钉钉应用，用户都可以以应用为维度控制调用权限，登录钉钉管理后台–》权限控制即可配置，如下图所示：</p>
<p><img src="https://img.hznu.online/blog/%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE.png"></p>
<h4 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h4><p>前端我选用的框架是Vue、uniapp，组件库使用uview。原因是uview可以很方便打包成各种小程序，既可以当H5使用，也可以稍作修改，接入小程序。</p>
<p>后端则是常见的SpringBoot等。</p>
<h4 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h4><p>真机调试过程相对比较麻烦，需要先使用HBuilderX开发工具，将前端开发完成，可以测试后，打包成钉钉小程序，并导入小程序开发者工具，进行真机调试。此时，需要使电脑和手机在同一个局域网中，同时需要在钉钉小程序应用后台配置应用网关，添加局域网IP。</p>
<p>对此真机调试的缓存数据，由于不能手动删除，因此需要在前端首页mock数据，并调用钉钉或uniapp缓存api加载或删除缓存数据。</p>
<h4 id="OA审批调用"><a href="#OA审批调用" class="headerlink" title="OA审批调用"></a>OA审批调用</h4><p>OA审批调用是在代码实现过程中，工作量稍大的部分。此处也分官方OA审批和自有OA审批，这里不展开讲解两者区别，可进入钉钉开发者文档查看<a target="_blank" rel="noopener" href="https://open.dingtalk.com/document/orgapp-server/workflow-overview">OA审批模块</a>。</p>
<p>通过分析后，我认为自有OA审批对于该需求会好做一些，更方便自己控制和数据调用，所以我采用的是自有OA审批，自己控制该流程。采用自由OA审批分以下几个步骤：</p>
<ol>
<li>构造审批模板，需通过调用API构造。如果存在，则直接返回模板ID使用。</li>
<li>每次审批开始前，需要创建不带流程的审批实例。该实例会在申请人一端的OA审批模块看到，并传入URL，点击跳转查看该实例详情。</li>
<li>创建并拿到审批实例ID后，创建待办事项，待办事项在审批接收人一端的待办事项可以看到。并且传入URL，点击跳转该待办任务详情。</li>
<li>若导师同意接收，待办任务接收，审批实例也结束，结果导入双选结果表；若导师拒绝，则待办任务结束，审批实例不结束，后续流程仍复用该实例。其他流转逻辑则根据需求而流转，在代码内实现。</li>
<li>导师和学生匹配成功后，需要调用钉钉API的消息通知，通知导师和学生匹配成功。</li>
</ol>
<p>通过分析以上逻辑，我们会发现有一块是需要传入URL的，因此，在测试阶段，我们需要做内网穿透，否则每次都需要部署到服务器测试，非常麻烦。钉钉在之前是提供了内网穿透测试工具的，但是在今年7月停止服务，因此，需要寻找另一款工具，这里不推荐使用<a target="_blank" rel="noopener" href="https://ngrok.com/docs/getting-started">ngrok</a>。因为他们在免费版本中强制执行安全页面(浏览器警告)，并且没办法调用后端的Get请求。作为替代方案，目前先使用花生壳看下效果怎样。</p>
<h4 id="师生匹配"><a href="#师生匹配" class="headerlink" title="师生匹配"></a>师生匹配</h4><p>在师生匹配过程中，实际上还是碰到不少问题的。首先我们给予用户需求来分析一下。</p>
<p>在用户的首次需求中，用户提出需求说：导师是先选先得。</p>
<p>在补充需求中，用户提出需求说：学生可以选择三个志愿。</p>
<p>这样其实是有问题的。如果先到先得的话，可能有这种场景：一个学生选择三个志愿导师，一个人就占了三个名额了，其他学生没导师选了。这样其他人要选择导师的话，就要等先选的人流程走完，将名额空出来才可以选。这样的产品显示不够好。</p>
<p>所以，我们要结合用户需求，进行对接修改。在和用户对接后，我们将需求修改成这样：</p>
<blockquote>
<p>不设置先到先得，所有学生都能选所有导师，把选择权给导师。假如有8个招生名额，有10个同学选择该导师，导师接收8个。其他两位同学走二志愿。二志愿没有名额或者拒绝走三志愿，以此类推，直到走到自动匹配阶段。</p>
</blockquote>
<p>这样看似乎没有什么问题了，其实不然。</p>
<p>用上面的分析看，流程是这样的，假如到了导师选择的开放时间，学生进入系统选择导师。这样有些学生可能会先选择导师，有些选的慢一些。假如先选的学生直接开始流程，那么会有什么现象呢？</p>
<p>假如这样的话，我们没办法等到所有学生选择完成后再开始下一流程。因为学生数据都在钉钉内，我们不知道本次有多少学生参加导师选择。</p>
<p>那么有没有办法获取呢，其实也是有的，因为我们是在钉钉新建了一个部门，直接获取部门人数就好了。但是仍然会有一些问题，即使我们获取到所有学生数，假如只有几个学生没有提交双选意向，那么流程还是继续不下去。</p>
<p>所以，我们应该把选择权交给用户。在学生提交双选意向后，不直接开始流程，而是先存在数据库，并将当前提交的用户信息提交让系统管理员看到，由管理员选择是否开始流程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在一个项目开发前期，用户提出的需求往往都不够明确，需要需求人员反复对接完善需求，其实这也是一块非常大而且需求非常多时间的开发过程，在开发过程中也应该得到重视。总而言之，一切要从用户角度出发，用他们的想法，结合程序开发的思维去细化需求，思考问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Huang Rui"
      src="/images/me.jpg">
  <p class="site-author-name" itemprop="name">Huang Rui</p>
  <div class="site-description" itemprop="description">国家地板级演员 GitHub顶级粉丝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/18770171448" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;18770171448" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huang Rui</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">288k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:22</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'ug4QbCcxhey1T327h47wyvvV-gzGzoHsz',
      appKey     : 'lWaydRUD874OBFVlx1cw26gj',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
