<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo32px.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo16px.png">
  <link rel="mask-icon" href="/images/logosvg.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hznu.asia","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="国家地板级演员 GitHub顶级粉丝">
<meta property="og:type" content="website">
<meta property="og:title" content="realhuang">
<meta property="og:url" content="http://hznu.asia/index.html">
<meta property="og:site_name" content="realhuang">
<meta property="og:description" content="国家地板级演员 GitHub顶级粉丝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Huang Rui">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hznu.asia/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>realhuang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="realhuang" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">realhuang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-sitemap fa-fw"></i>留言</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/06/29/%E7%A8%8B%E5%BA%8F%E4%B8%ADError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/29/%E7%A8%8B%E5%BA%8F%E4%B8%ADError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">程序中Error和Exception的区别和处理方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-29 11:23:50 / 修改时间：20:54:17" itemprop="dateCreated datePublished" datetime="2022-06-29T11:23:50+08:00">2022-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/29/%E7%A8%8B%E5%BA%8F%E4%B8%ADError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/29/%E7%A8%8B%E5%BA%8F%E4%B8%ADError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-异常的分类"><a href="#一-异常的分类" class="headerlink" title="一. 异常的分类"></a>一. 异常的分类</h2><p>在 Java 中所有异常类型都是内置类 java.lang.Throwable 类的子类，即 Throwable 位于异常类层次结构的顶层。Throwable 类下有两个异常分支 Exception 和 Error，而Exception分为 ”检查异常（非运行时异常）“ 和 ”不检查异常（运行时异常，RuntimeException）“。如下图所示：</p>
<p><img src="https://img.hznu.asia/%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E5%88%86%E7%B1%BB.png"></p>
<h4 id="1-1-Error-和-Exception-的异同点"><a href="#1-1-Error-和-Exception-的异同点" class="headerlink" title="1.1 Error 和 Exception 的异同点"></a>1.1 Error 和 Exception 的异同点</h4><p><strong>相同点：</strong> </p>
<p>1、Exception 和 Error 都集成了同一个类 Throwable。因为在Java中只有继承了Throwable类的实例才可以被抛出或者捕获。 </p>
<p><strong>不同点：</strong> </p>
<p>1、Error 会导致程序处于非正常的，不可恢复的状态，比如JVM自身的问题，OutOfMemoyError 等。 </p>
<p>２、Exception分为两种：可检查异常和不可检查异常。 在编译阶段显示捕获的异常称为可检查异常，比如IO异常。 在运行时被捕获的异常称为不可检查异常，比如空指针、数组越界。</p>
<h4 id="1-2-检查异常和非检查异常"><a href="#1-2-检查异常和非检查异常" class="headerlink" title="1.2 检查异常和非检查异常"></a>1.2 检查异常和非检查异常</h4><p><strong>检查异常：</strong>没有继承RuntimeException的Exception属于检查异常，这类问题在编译期就可以确定的问题，如<strong>FileNotFoundException、IOException</strong>。编译器对检查异常的处理要求：</p>
<ul>
<li>try..catch捕获。</li>
<li>不断向上抛出，交由jvm来处理。 </li>
</ul>
<p><strong>非检查异常：</strong>继承了RuntimeException的Exception，非检查异常也叫<strong>运行时异常</strong>，这类问题大部分属于逻辑问题，如<strong>数组越界、空指针异常</strong>，只有运行时才能知道的问题，异常在编译时不会检查。通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p>
<h4 id="类比解释"><a href="#类比解释" class="headerlink" title="类比解释"></a>类比解释</h4><p>假如你开车上山，车坏了，你拿出工具箱修一修，修好继续上路（Exception被捕获，从异常中恢复，继续程序的运行），车坏了，你不知道怎么修，打电话告诉修车行，告诉你是什么问题，要车行过来修。（在当前的逻辑背景下，你不知道是怎么样的处理逻辑，把异常抛出去到更高的业务层来处理）。你打电话的时候，要尽量具体，不能只说我车动不了了。那修车行很难定位你的问题。（要补货特定的异常，不能捕获类似Exception的通用异常）。还有一种情况是，你开车上山，山塌了，这你还能修吗？（Error：导致你的运行环境进入不正常的状态，很难恢复）</p>
<h2 id="二-异常处理准则"><a href="#二-异常处理准则" class="headerlink" title="二. 异常处理准则"></a>二. 异常处理准则</h2><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  // 业务代码</span><br><span class="line">  // …</span><br><span class="line">  Thread.sleep(1000L);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">  // Ignore it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码尽管很短，但是已经<strong>违反了两个准则</strong>。</p>
<ol>
<li><strong>尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常，在这里是 Thread.sleep() 抛出的 InterruptedException。</strong></li>
</ol>
<blockquote>
<p>这是因为在日常的开发和合作中，我们读代码的机会往往超过写代码，软件工程是门协作的艺术，所以我们有义务让自己的代码能够直观地体现出尽量多的信息，而泛泛的 Exception 之类，恰恰隐藏了我们的目的。另外，我们也要保证程序不会捕获到我们不希望捕获的异常。比如，你可能更希望 RuntimeException 被扩散出来，而不是被捕获。</p>
<p>进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确程序处理 OutOfMemoryError。</p>
</blockquote>
<ol start="2">
<li><strong>不要生吞（swallow）异常。这是异常处理中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况。</strong></li>
</ol>
<blockquote>
<p>生吞异常，往往是基于假设这段代码可能不会发生，或者感觉忽略异常是无所谓的，但是千万不要在产品代码做这种假设。<strong><em>如果我们不把异常抛出来，或者也没有输出到日志（Logger）之类，程序可能在后续代码以不可控的方式结束</em>。</strong>没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。</p>
</blockquote>
<h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   // 业务代码</span><br><span class="line">   // …</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码作为一段实验代码，它是没有任何问题的，但是在产品代码中，通常都不允许这样处理。</p>
<blockquote>
<p>我们先来看看printStackTrace()的文档，开头就是“Prints this throwable and its backtrace to the standard error stream”。简单说，就是 在命令行打印异常信息在程序中出错的位置及原因。</p>
<p>问题就在这里，在稍微复杂一点的生产系统中，标准出错（STERR）不是个合适的输出选项，因为你很难判断出到底输出到哪里去了。</p>
<p>尤其是对于分布式系统，如果发生异常，无法找到堆栈轨迹（stacktrace），这纯属是为诊断设置障碍。所以，最好使用产品日志，详细地输出到日志系统里。</p>
</blockquote>
<h4 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void readPreferences(String fileName)&#123;</span><br><span class="line">  InputStream in = new FileInputStream(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 fileName 是 null，那么程序就会抛出 NullPointerException，但是由于没有第一时间暴露出问题，堆栈信息可能非常令人费解，往往需要相对复杂的定位。这个 NPE 只是作为例子，实际产品代码中，可能是各种情况，比如获取配置失败之类的。在发现问题的时候，第一时间抛出，能够更加清晰地反映问题。</p>
<p>我们可以修改一下，让问题“throw early”，对应的异常信息就非常直观了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void readPreferences(String filename) &#123;</span><br><span class="line">  Objects.requireNonNull(filename);</span><br><span class="line">  InputStream in = new FileInputStream(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于“catch late”，其实是我们经常苦恼的问题，捕获异常后，需要怎么处理呢？最差的处理方式，就是我前面提到的“生吞异常”，本质上其实是掩盖问题。如果实在不知道如何处理，可以选择保留原有异常的 cause 信息，直接再抛出或者构建新的异常抛出去。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。</p>
<p><strong>所以，catch late，就是尽量晚的处理异常，在越外层处理越好。</strong></p>
<h4 id="关于-Checked-Exception（非运行时异常）"><a href="#关于-Checked-Exception（非运行时异常）" class="headerlink" title="关于 Checked Exception（非运行时异常）"></a>关于 Checked Exception（非运行时异常）</h4><p>业界有一种争论（甚至可以算是某种程度的共识），Java 语言的 Checked Exception 也许是个设计错误，反对者列举了几点：</p>
<ul>
<li>Checked Exception 的假设是我们捕获了异常，然后恢复程序。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception 的使用，已经大大偏离了最初的设计目的。</li>
<li>Checked Exception 不兼容 functional 编程，如果你写过 Lambda/Stream 代码，相信深有体会。</li>
</ul>
<blockquote>
<p>比如对于运行时异常，可以使用 list1.stream().filter(Objects::nonNull).map(); 判断非空</p>
<p>而对于 FileNotFoundException、IOException 等非运行时异常，则无法使用Lambda 和 Stream</p>
</blockquote>
<p>但是，很多人也觉得没有必要矫枉过正，因为确实有一些异常，比如和环境相关的 IO、网络等，其实是存在可恢复性的，而且 Java 已经通过业界的海量实践，证明了其构建高质量软件的能力。</p>
<h2 id="三-性能分析"><a href="#三-性能分析" class="headerlink" title="三. 性能分析"></a>三. 性能分析</h2><ul>
<li>try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，<strong>尽量不要一个大的 try 包住整段的代码</strong>；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</li>
<li><strong>Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作</strong>。如果发生的非常频繁，这个开销可就不能被忽略了。</li>
</ul>
<blockquote>
<p><strong>异常实例的构造十分昂贵。这是由于在构造异常实例时，Java 虚拟机便需要生成该异常的栈轨迹（stack trace）。该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。</strong></p>
</blockquote>
<h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><ol>
<li><strong>NoClassDefFoundError 和 ClassNotFoundException 有什么区别？</strong></li>
</ol>
<p>NoClassDefFoundError 是个Error，是指一个class在编译时存在，在运行时找不到了class文件了；ClassNotFoundException 是个Exception，是使用类似Class.foName()等方法时的checked exception。</p>
<p>类的加载分为显式加载(用字符串为类名加载类，抛出ClassNotFoundException)和隐式加载(不是通过显式方法调用，由引用、实例化或继承导致装入类。通常这种错误在编译阶段会发现，报错为找不到符号。如果编译时能找到这个类，但运行时找不到这个类，就抛出NoClassDefFoundError)</p>
<ol start="2">
<li>throw 和 throws 的区别？</li>
</ol>
<p><strong>throw</strong></p>
<p> 1、throw是语句抛出一个异常，一般是在<strong>代码块的内部</strong>，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常 </p>
<p>2、定义在方法体内 </p>
<p>3、创建的是一个异常对象 </p>
<p>4、确定了发生哪种异常才可以使用 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final String upload(String baseDir, MultipartFile file) throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            return upload(baseDir, file, MimeTypeUtils.DEFAULT_ALLOWED_EXTENSION);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new IOException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>throws</strong> </p>
<p>1、<strong>在方法参数列表后</strong>，throws后可以跟着多个异常名，表示抛出的异常用逗号隔开 </p>
<p>2、<strong>表示向调用该类的位置抛出异常，不在该类解决</strong> </p>
<p>3、可能发生哪种异常 throws用在方法声明后面，跟的是异常类名，throw用在方法体内，跟的是异常对象名。 throws可以跟多个异常类名，用逗号隔开，throw只能抛出一个异常对象名。 throws表示抛出异常，由该方法的调用者来处理，throw表示抛出异常，由方法体内的语句处理。 throws表示出现异常的一种可能性，并不一定会发生这些异常，throw则是抛出了异常，执行throw则一定抛出了某种异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void openFile() throws FileNotFoundException&#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>参考引用：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E9%82%A3%E7%82%B9%E4%BA%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E9%82%A3%E7%82%B9%E4%BA%8B/" class="post-title-link" itemprop="url">计算机网络--运输层那点事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-21 09:52:00" itemprop="dateCreated datePublished" datetime="2022-06-21T09:52:00+08:00">2022-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-29 21:24:34" itemprop="dateModified" datetime="2022-06-29T21:24:34+08:00">2022-06-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E9%82%A3%E7%82%B9%E4%BA%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E9%82%A3%E7%82%B9%E4%BA%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>写在前面：本篇博客是在看完《计算机网络：自顶向下方法》运输层一章写的，但是写着写着感觉东西实在太多，重要的点也很多。因此只挑选一些常见且相对重要的点记录下来。遇到问题，还是建议去翻一翻本章。</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="运输层协议"><a href="#运输层协议" class="headerlink" title="运输层协议"></a>运输层协议</h4><p>​        运输层协议是<strong>在端系统中而不是在路由器</strong>中实现的。</p>
<p>​        在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层报文段实现的方法（可能）是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。然后，在发送端系统中，运输层将这些报文段传递给网络层，网络层将其封装成网络层分组（即数据报）并向目的地发送。</p>
<p>​        注意到下列事实是重要的：网络路由器仅作用于该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。运输层则处理接收到的报文段，使该报文段中的数据为接收应用进程使用</p>
<h4 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h4><blockquote>
<p>​        考虑有两个家庭，一家位于美国东海岸，一家位于美国西海岸，每家有12个孩子。 东海岸家庭的孩子们是西海岸家庭孩子们的堂兄弟姐妹。这两个家庭的孩子们喜欢彼此通信，每个人每星期要互相写一封信，每封信都用单独的信封通过传统的邮政服务传送。</p>
<p>​         因此，每个家庭每星期向另一家发送144封信。（如果他们有电子邮件的话，这些孩子可以 省不少钱！）每一个家庭有个孩子负责收发邮件，西海岸家庭是Ann而东海岸家庭是Bill。 每星期Ann去她的所有兄弟姐妹那里收集信件，并将这些信件交到每天到家门口来的邮政 服务的邮车上。当信件到达西海岸家庭时，Ann也负责将信件分发到她的兄弟姐妹手上。 在东海岸家庭中的Bill也负责类似的工作。</p>
<p>​        在这个例子中，邮政服务为两个家庭间提供逻辑通信，邮政服务将信件从一家送往另 一家，而不是从一个人送往另一个人。在另一方面，Ann和Bill为堂兄弟姐妹之间提供了 逻辑通信，Arm和Bill从兄弟姐妹那里收取信件或到兄弟姐妹那里交付信件。注意到从堂 兄弟姐妹们的角度来看，Ann和Bill就是邮件服务，尽管他们只是端到端交付过程的一部 分（即端系统部分）。在解释运输层和网络层之间的关系时，这个家庭的例子是一个非常 好的类比。</p>
<p><strong>应用层报文 = 信封上的字符</strong> </p>
<p><strong>进程 = 堂兄弟姐妹</strong> </p>
<p><strong>主机（又称为端系统）= 家庭</strong> </p>
<p><strong>运输层协议 = Ann和Bill</strong> </p>
<p><strong>网络层协议 = 邮政服务（包括邮车）</strong></p>
</blockquote>
<h4 id="为什么需要TCP协议"><a href="#为什么需要TCP协议" class="headerlink" title="为什么需要TCP协议"></a>为什么需要TCP协议</h4><p>​        不少人应该听说过TCP/IP协议，并且对此有一定的了解。其中，TCP协议处于运输层，而IP协议处于网络层。</p>
<p>​        其中，IP的服务模型是尽力而为交付服务， 这意味着IP尽它“最大的努力”在通信的主机之间交付报文段，但它并不做任何确保。特别是，它不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性。由于这些原因，IP被称为不可靠服务。由此，就需要TCP来做可靠性传输保障了。</p>
<p>​        TCP协议是运输层中非常重要的一个协议，除了提供可靠性传输之外，TCP还提供拥塞控制等功能，后文会展开讲解。</p>
<h4 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h4><p>​        在接收端，运输层检查这些字段，标识出接收套 接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工 作称为多路分解。</p>
<p>​        在源主机从不同套接字中收集数据块，并为每个数据 块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将报文段传递到网络 层，所有这些工作称为多路复用。</p>
<h4 id="流行应用即下面的运输层协议"><a href="#流行应用即下面的运输层协议" class="headerlink" title="流行应用即下面的运输层协议"></a>流行应用即下面的运输层协议</h4><table>
<thead>
<tr>
<th align="center">应用</th>
<th align="center">应用层协议</th>
<th align="center">下面的运输协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">电子邮件</td>
<td align="center">SMTP</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">远程终端访问</td>
<td align="center">Telnet</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">Web</td>
<td align="center">HTTP</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">文件传输</td>
<td align="center">FTP</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">远程文件服务器</td>
<td align="center">NFS</td>
<td align="center">通常UDP</td>
</tr>
<tr>
<td align="center">流式多媒体</td>
<td align="center">通常专用</td>
<td align="center">UDP或TCP</td>
</tr>
<tr>
<td align="center">因特网电话</td>
<td align="center">通常专用</td>
<td align="center">UDP或TCP</td>
</tr>
<tr>
<td align="center">网络管理</td>
<td align="center">SNMP</td>
<td align="center">通常UDP</td>
</tr>
<tr>
<td align="center">名字转换</td>
<td align="center">DNS</td>
<td align="center">通常UDP</td>
</tr>
</tbody></table>
<h4 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h4><table>
<thead>
<tr>
<th>对比点</th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>一对一</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>使用场景</td>
<td>实用应用（IP电话、视频会议等）</td>
<td>文件传输等</td>
</tr>
</tbody></table>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>TCP和UDP都是运输层常用的协议，两者之间各有优劣</p>
<h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><ol>
<li>TCP为什么要三次握手？</li>
</ol>
<ol start="2">
<li>套接字和报文的区别是什么？</li>
</ol>
<p>​        TCP的分组称为报文段</p>
<ol start="3">
<li>拥塞控制和流量控制服务的区别</li>
</ol>
<h2 id="参考引用："><a href="#参考引用：" class="headerlink" title="参考引用："></a>参考引用：</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/05/13/%E5%90%89%E4%BB%96%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/13/%E5%90%89%E4%BB%96%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">吉他入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-13 18:57:01 / 修改时间：19:27:09" itemprop="dateCreated datePublished" datetime="2022-05-13T18:57:01+08:00">2022-05-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%89%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">吉他</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/13/%E5%90%89%E4%BB%96%E5%85%A5%E9%97%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/13/%E5%90%89%E4%BB%96%E5%85%A5%E9%97%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://img.hznu.asia/%E5%BC%A6%E5%92%8C%E6%89%8B.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/04/27/%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/27/%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">理解进程与线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-27 15:53:20" itemprop="dateCreated datePublished" datetime="2022-04-27T15:53:20+08:00">2022-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-29 19:25:30" itemprop="dateModified" datetime="2022-06-29T19:25:30+08:00">2022-06-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/27/%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/27/%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-进程"><a href="#一-进程" class="headerlink" title="一. 进程"></a>一. 进程</h2><p>进程（Process）是系统进行资源分配和调度的基本单位，是操作系统结构的基础。大白话讲，进程本质上是正在执行的一个程序，并且，<strong>如果一个程序如果运行了两遍，则算作两个进程</strong>。</p>
<p>与每个进程相关的是地址空间，这是从某个最小值的存储位置（通常是0）到某个最大值的存储位置的列表。在这个地址空间中，进程可以读写。该地址空间存放有可执行程序、程序的数据以及程序的堆栈。</p>
<h5 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h5><p>在许多操作系统中，与一个进程有关的所有信息，除了该进程自身的地址空间的内容外，均存放在操作系统的一张表中，称为<strong>进程表</strong>，进程表是数组（或链表）结构，当前存在的进程都要占有其中一项。</p>
<p>所以，一个（挂起的）进程包括：进程的地址空间以及对应的进程表项（其中包括寄存器以及稍后重启该进程所需要的许多其他信息）。</p>
<h4 id="进程的组成："><a href="#进程的组成：" class="headerlink" title="进程的组成："></a>进程的组成：</h4><p><strong>进程是由程序控制块（PCB）、程序段、数据段组成。</strong></p>
<p>操作系统是通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需的各种信息，如进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息。</p>
<p>程序段：程序代码存放的位置。</p>
<p>数据段：程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量就存放在数据段内。</p>
<p><img src="http://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84" alt="http://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84"></p>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>在非常简单的系统中，比如微波炉中的控制器以及类似的系统，因为只为一个应用程序而设计，所以在启动时，所有在之后运行过程中需要的程序便已经存在。但是在更为复杂的操作系统中，需要有一种方式来创建或消耗进程。</p>
<p>主要有四种主要事件会创建进程：</p>
<p>​    1）系统初始化</p>
<p>​    2）正在运行的程序执行了创建进程的系统调用</p>
<p>​    3）用户请求创建一个新进程</p>
<p>​    4）一个批处理作业的初始化</p>
<p>启动操作系统时，通常会创建若干进程，其中有些是前台进程，也就是同用户交互并完成其相关指令的进程。还有些则是后台进程，这些与用户没有关系，比如一个接受电子邮件的进程，其大部分时间处于睡眠状态，但是当电子邮件到达时便被唤醒。这些停留在后台处理的进程称为<strong>守护进程</strong>。在大型系统中有很多守护进程，比如在Unix中，可以用<code>ps</code>指令列出正在运行的进程；在<code>Windows</code>中，则可以使用任务管理器。</p>
<p>在多处理机中，让每个进程在不同的CPU上运行会使整个作业运行得更快。进程创建的方式有许多种，在所有的情形中，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程做的工作是：执行一个用来创建新进程的系统调用，这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定在该进程中运行地程序。</p>
<p>此外，不同的操作系统也有不同的进程创建方式。</p>
<h5 id="Unix操作系统创建进程"><a href="#Unix操作系统创建进程" class="headerlink" title="Unix操作系统创建进程"></a>Unix操作系统创建进程</h5><p>在Unix操作系统中，只有一个系统调用可以创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用fork后，这两个进程（父进程和子进程）拥有相同的内存映像和相同的打开文件。通常，子进程接着执行<code>execve</code>或一个类似的系统调用，用于修改其内存映像并运行一个新的程序。之所以安排两步，是为了在fork后但在<code>execve</code>之前允许该子进程处理其文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。</p>
<h5 id="Windows操作系统创建进程"><a href="#Windows操作系统创建进程" class="headerlink" title="Windows操作系统创建进程"></a>Windows操作系统创建进程</h5><p>在，Windows中，情形正好相反，一个<code>Win32</code>函数调用<code>CreateProcess</code>既处理进程的创建，也负责把正确的程序装入新的进程。除了<code>CreateProcess</code>，Win32中大约有100个其他的函数用于处理进程的管理、同步以及相关的事物。</p>
<h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><p>进程在创建之后，以下行为将引起终止：</p>
<p>​    1）正常退出（自愿的）</p>
<p>​    2）出错退出（自愿的）</p>
<p>​    3）严重错误（非自愿）</p>
<p>​    4）被其他进程杀死（非自愿）</p>
<p>其中第二个原因时<strong>进程发现了错误</strong>，比如用户输入 cc <code>foo.c</code> 编译程序 <code>foo.c</code>，但是该文件不存在，于是编译器退出。</p>
<p>第三个原因时<strong>由进程引起的错误</strong>，比如执行了一条非法指令，或者引用了一段不存在的内存或除数为0等等。</p>
<h4 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h4><h5 id="Unix中的结构"><a href="#Unix中的结构" class="headerlink" title="Unix中的结构"></a>Unix中的结构</h5><p>在Unix中，进程和它的所有子进程以及后裔共同组成了一个进程组。</p>
<p>Unix在初始化自己时，一个称为<code>init</code>的特殊进程出现在启动镜像中，当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录，如果有一个用户登录成功，该登录进程就执行一个<code>shell</code>准备接收命令。所接收的这些命令会启动更多的进程，以此类推。这样，在整个系统中，所有的进程都属于以<code>init</code>为根的一棵树。</p>
<h5 id="Windows中的结构"><a href="#Windows中的结构" class="headerlink" title="Windows中的结构"></a>Windows中的结构</h5><p>相反, Windows中没有进程层次的概念,所有的进程都是地位相同的。唯一类似于进程层次的暗示是在创建进程的时候,父进程得到一个特别的令牌(称为句柄),该句柄可以用来控制子进程。但是,它有权把这个令牌传送给某个其他进程,这样就不存在进程层次了。在UNIX中,进程就不能剥夺其子继承的“继承权”。 </p>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p>进程分三种状态：</p>
<p>​    1）就绪态（该时刻进程实际占用CPU）</p>
<p>​    2）就绪态（可运行，但因为其他进程正在运行而暂时停止）</p>
<p>​    3）阻塞态（除非某种外部事件发生，否则进程不能运行）</p>
<p><img src="https://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p>
<p>前两种状态在逻辑上是类似的。处于这两种状态的进程都可以运行,只是对于第二种状态暂时没有CPU分配给它。第三种状态与前两种状态不同,处于该状态的进程不能运行,即使CPU空闲也不行。</p>
<h4 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h4><p>为了实现进程模型,操作系统维护着一张表格(一个结构数组),即进程表(process table)。每个进程占用一个进程表项 (有些作者称这些表项为进程控制块) 该表项包含了进程状态的重要信息,包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息,以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息,从而保证该进程随后能再次启动,就像从未被中断过一样。 </p>
<p><img src="https://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E8%A1%A8%E5%AD%97%E6%AE%B5.png"></p>
<p>在了解进程表后,就可以对在单个(或每一个) CPU上如何维持多个顺序进程的错觉做更多的阐述。<strong>与每一I/O类关联的是一个称作中断向量(interrupt vector)的位置(靠近内存底部的固定区域)。它包含中断服务程序的人口地址。假设当一个磁盘中断发生时,用户进程3正在运行,则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈,计算机随即跳转到中断向量所指示的地址。这些是硬件完成的所有操作,然后软件,特别是中断服务例程就接管一切剩余的工作。</strong> </p>
<p>其实这个操作，说白了，就是先保存到寄存器，再将一个或多个寄存器压入进程堆栈，再把进程存到进程表中。</p>
<p>所有的中断都从保存寄存器开始,对于当前进程而言,通常是保存在进程表项中。随后,会从堆栈中删除由中断硬件机制存人堆栈的那部分信息,并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。</p>
<h2 id="二-线程"><a href="#二-线程" class="headerlink" title="二. 线程"></a>二. 线程</h2><h4 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h4><p>需要线程的几个理由：</p>
<p>​    1）人们需要多线程的主要原因是,在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程,程序设计模型会变得更简单。</p>
<p>​    2）第二个关于需要多线程的理由是,由于线程比进程更轻量级,所以它们比进程更容易(即更快)创建,也更容易撤销。在许多系统中,创建一个线程较创建一个进程要快10~100倍。在有大量线程需要动态和快速修改时,具有这一特性是很有用的。</p>
<p>​    3）需要多线程的第三个原因涉及性能方面的讨论。若多个线程都是CPU密集型的,那么并不能获得性能上的增强,但是如果存在着大量的计算和大量的I/0处理,拥有多个线程允许这些活动彼此重叠进行,从而会加快应用程序执行的速度。最后,在多CPU系统中,多线程是有益的,在这样的系统中,真正的并行有了实现的可能。</p>
<ul>
<li><p>​    <strong>CPU密集型程序：</strong>程序中进行大量的数据运算处理，花费了绝大部分时间在计算上。最佳线程数 = CPU核心数 + 1，+1 是为防止有线程被阻塞，CPU可以调    用其他线程。</p>
</li>
<li><p>​    <strong>IO密集型程序：</strong>多任务并行处理，程序中大量进行IO操作，对CPU要求并不高，因此执行流个数没有太大要求。</p>
<p>​    最佳线程数  = 1/CPU利用率 = 1 + (I/O耗时) / (CPU耗时)；一般为CPU核心数的两倍。</p>
</li>
</ul>
<h4 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h4><p>在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。 </p>
<p><strong>进程中的不同线程</strong>不像不同进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写或甚至清除另一个线程的堆栈。线程之间是没有保护的，原因是: </p>
<p>1)不可能</p>
<p>2)也没有必要。</p>
<p>这与不同进程是有差别的。不同的进程会来自不同的用户，它们彼此之间可能有敌意，一个进程总是由某个用户所拥有，该用户创建多个线程应该是为了它们之间的合作而不是彼此间争斗。除了共享地址空间之外，所有线程还共享同一个打开文件集、子进程、定时器以及相关信号等，如图212所示。这样,对于三个没有关系的线程而言，应该使用下图第一列的结构，而在三个线程实际完成同一个作业，并彼此积极密切合作的情形中，下图第二列则比较合适。 </p>
<table>
<thead>
<tr>
<th align="center">每个进程中的内容</th>
<th align="center">每个线程中的内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">地址空间<br>全局变量<br>打开文件<br>子进程<br>即将发生的定时器<br>信号与信号处理程序<br>账户信息</td>
<td align="center">程序计数器<br>寄存器<br>堆栈<br>状态</td>
</tr>
</tbody></table>
<p><strong>线程概念试图实现的是：共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。</strong></p>
<h4 id="在用户空间实现线程"><a href="#在用户空间实现线程" class="headerlink" title="在用户空间实现线程"></a>在用户空间实现线程</h4><p><strong>有两种主要的方法实现线程包：在用户空间中和内核中。</strong>这两种方法各有利弊，不过也有混合实现的方式。</p>
<p>在用户空间管理线程时，每个进程需要有其专用的线程表(thread table)，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈、指针、寄存器和状态等。该线程表由运行时系统管理，当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。</p>
<p>当某个线程做了一些会引起在本地阻塞的事情之后,例如,等待进程中另一个线程完成某项工作,它调用一个运行时系统的过程,这个过程检查该线程是否必须进人阻塞状态。如果是,它在线程表中保存该线程的寄存器(即它本身的),查看表中可运行的就绪线程,并把新线程的保存值重新装入机器的寄存器中。</p>
<p>只要堆栈指针和程序计数器一被切换，新的线程就又自动投入运行。如果机器有一条保存所有寄存器的指令和另一条装入全部寄存器的指令，那么整个线程的切换可以在几条指令内完成。进行类似,于这样的线程切换至少比陷入内核要快一个数量级(或许更多)，这是使用用户级线程包的极大的优点。</p>
<h4 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h4><p>内核的线程表保存了每个线程的寄存器、状态和其他信息。这些信息和在用户空间中(在运行时系·统中)的线程是一样的,但是现在保存在内核中。这些信息是传统内核所维护的每个单线程进程信息(即进程状态)的子集。另外,内核还维护了传统的进程表,以便跟踪进程的状态。</p>
<p>由于在内核中创建或撤销线程的代价比较大,某些系统采取“环保”的处理方式,回收其线程。当某个线程被撤销时,就把它标志为不可运行的,但是其内核数据结构没有受到影响。稍后,在必须创建一个新线程时,就重新启动某个旧线程,从而节省了一些开销。在用户级线程中线程回收也是可能的,但是由于其线程管理的代价很小,所以没有必要进行这项工作。 </p>
<p><strong>存在的问题：</strong></p>
<ol>
<li>为什么在内核中创建或撤销线程的代价比较大</li>
</ol>
<p><strong>参考引用：</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/04/23/SpringDataJPA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/23/SpringDataJPA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" class="post-title-link" itemprop="url">SpringDataJPA的前世今生</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-23 13:47:11" itemprop="dateCreated datePublished" datetime="2022-04-23T13:47:11+08:00">2022-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-06 19:47:18" itemprop="dateModified" datetime="2022-05-06T19:47:18+08:00">2022-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringDataJPA/" itemprop="url" rel="index"><span itemprop="name">SpringDataJPA</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/23/SpringDataJPA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/23/SpringDataJPA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前言：</span><br><span class="line">Java 持久层框架访问数据库的方式大致分为两种：一种以 SQL 核心，封装一定程度的 JDBC 操作，比如： MyBatis。</span><br><span class="line">另一种是以 Java 实体类为核心，将实体类的和数据库表之间建立映射关系，也就是我们说的 ORM 框架，如：Hibernate、Spring Data JPA。</span><br></pre></td></tr></table></figure>



<p><strong>在了解<code>Spring Data JPA</code>前，有必要先了解几个概念——<code>JPA</code>、<code>Hibernate</code>和<code>Spring Data JPA</code>。</strong></p>
<h2 id="一-JPA-、Hibernate-和-Spring-Data"><a href="#一-JPA-、Hibernate-和-Spring-Data" class="headerlink" title="一. JPA 、Hibernate 和 Spring Data"></a>一. JPA 、Hibernate 和 Spring Data</h2><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p>​        <code>Spring Data JPA</code>是建立的JPA的基础之上， 那么什么是JPA？</p>
<p>​        我们都知道不同的数据库厂商都有自己的实现类，后来统一规范也就有了数据库驱动，Java在操作数据库的时候，底层使用的其实是<code>JDBC</code>，而<code>JDBC</code>是一组操作不同数据库的规范。我们的Java应用程序，只需要调用<code>JDBC</code>提供的<code>API</code>就可以访问数据库了，而JPA也是类似的道理。</p>
<pre><code>     JPA全称是`Java Persistence API`（Java持久层API），它是Sun公司在JavaEE 5中提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：`Hibernate`。
</code></pre>
<p>​        需要注意的是JPA统一了Java应用程序访问ORM框架的规范。</p>
<p>​        JPA为我们提供了以下规范：</p>
<p>​            1. ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。</p>
<p>​            2. JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发人员不用再写SQL了。</p>
<p>​            3. JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密藕合。</p>
<h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><p>​        Hibernate是Java中的对象关系映射解决方案。对象关系映射或ORM框架是将应用程序数据模型对象映射到关系数据库表的技术。Hibernate 不仅关注于从 Java 类到数据库表的映射，也有 Java 数据类型到 SQL 数据类型的映射。</p>
<h4 id="Hibernate-和-JPA是什么关系呢？"><a href="#Hibernate-和-JPA是什么关系呢？" class="headerlink" title="Hibernate 和 JPA是什么关系呢？"></a><strong>Hibernate 和 JPA是什么关系呢？</strong></h4><p>​        上面我们介绍到JPA是Java EE 5规范中提出的Java持久化接口，而Hibernate是一个ORM框架。</p>
<h4 id="JPA和Hibernate的关系："><a href="#JPA和Hibernate的关系：" class="headerlink" title="JPA和Hibernate的关系："></a><strong>JPA和Hibernate的关系：</strong></h4><p>​        • JPA是一个规范，<strong>而不是框架</strong></p>
<p>​        • Hibernate是JPA的一种实现，<strong>是一个框架</strong></p>
<h3 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><h4 id="Spring-Data是什么？"><a href="#Spring-Data是什么？" class="headerlink" title="Spring Data是什么？"></a><strong>Spring Data是什么？</strong></h4><p>​        Spring Data是Spring 社区的一个子项目，主要用于简化数据（关系型&amp;非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。</p>
<p>​        • 它提供很多模板操作</p>
<p>​                – Spring Data Elasticsearch</p>
<p>​                – Spring Data MongoDB</p>
<p>​                – Spring Data Redis</p>
<p>​                – Spring Data Solr</p>
<p>​        • 强大的 Repository 和定制的数据储存对象的抽象映射</p>
<p>​        • 对数据访问对象的支持</p>
<p>​        <code>Spring Data JPA</code>是在实现了JPA规范的基础上封装的一套 JPA 应用框架，虽然ORM框架都实现了JPA规范，但是在不同的ORM框架之间切换仍然需要编写不同的代码，而使用<code>Spring Data JPA</code>能够方便大家在不同的ORM框架之间进行切换而不需要更改代码。<code>Spring Data JPA</code>旨在通过将统一ORM框架的访问持久层的操作，来提高开发的效率。</p>
<h4 id="Spring-Data-JPA和Hibernate的关系"><a href="#Spring-Data-JPA和Hibernate的关系" class="headerlink" title="Spring Data JPA和Hibernate的关系"></a>Spring Data JPA和Hibernate的关系</h4><p>​        <code>Hibernate</code>其实是JPA的一种实现，而<code>Spring Data JPA</code>是一个JPA数据访问抽象。<strong>也就是说Spring Data JPA不是一个实现或JPA提供的程序，它只是一个抽象层，主要用于减少为各种持久层存储实现数据访问层所需的样板代码量。但是它还是需要JPA提供实现程序，其实Spring Data JPA底层就是使用的 Hibernate实现。</strong></p>
<p><em><strong>总结就是：</strong></em></p>
<p><em><strong>• Hibernate是 JPA的一种实现，是一个框架</strong></em></p>
<p><em><strong>• Spring Data JPA是一种 JPA的抽象层，底层依赖 Hibernate</strong></em></p>
<p><img src="http://img.hznu.asia/202008270940571879.png" alt="http://img.hznu.asia/202008270940571879.png"></p>
<h2 id="二-ORM思想简介"><a href="#二-ORM思想简介" class="headerlink" title="二. ORM思想简介"></a>二. ORM思想简介</h2><p>​        前文提到， Spring Data JPA 底层是Hibernate ，而Hibernate 又是基于ORM思想的框架，因此，这里有必要对ORM做一个简单的介绍，以便理解后文。</p>
<p><strong>在探究什么是<code>ORM</code>之前，首先需要搞清楚几个概念：持久化和持久层。</strong></p>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>​        即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、<code>XML</code>中等等。</p>
<p>​        <code>Hibernate ORM</code>关心的是帮助应用程序实现持久性。持久性仅仅意味着我们希望应用程序的数据比应用程序进程的寿命更长。用<code>Java</code>术语来说，我们希望一些对象的状态超出<code>JVM</code>所能管控的范围，以便稍后可以使用相同的状态。</p>
<h4 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h4><p>​        即专注于实现数据持久化应用领域的某个特定系统的一个<strong>逻辑层面</strong>，将数据使用者和数据实体相关联。</p>
<h4 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h4><p>​        <code>ORM</code>即对象-关系映射（Object Relational Mapping），指的是在单个组件中负责所有实体域对象的持久化，封装数据库访问细节。它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的<code>SQL</code>语句打交道，只要像平时操作对象一样操作它就可以了 。</p>
<p>​        它是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。</p>
<p>​        <strong>采用 <code>ORM</code>框架后，应用程序不再直接访问底层数据库，而是以面向对象的方式来操作持久化对象，而<code>ORM</code>则将这些面向对象的操作转换成底层的 SQL 操作。</strong></p>
<p><img src="http://img.hznu.asia/A6970EEE-7490-4300-B50C-D3E368AFFAD5.png"></p>
<h4 id="常用的ORM中间件"><a href="#常用的ORM中间件" class="headerlink" title="常用的ORM中间件"></a>常用的ORM中间件</h4><p>​        开发<code>ORM</code>中间件需要十分专业的知识，因此一般在企业应用开发过程中都使用第三方提供的<code>ORM</code>中间件。下面列出了一些常用的<code>ORM</code>软件可供参考使用：</p>
<table>
<thead>
<tr>
<th align="center">ORM软件</th>
<th align="center">URL</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hibernate</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.hibernate.org/">http://www.hibernate.org/</a></td>
</tr>
<tr>
<td align="center">Mybatis</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.mybatis.org/">http://www.mybatis.org/</a></td>
</tr>
<tr>
<td align="center">Torque</td>
<td align="center"><a target="_blank" rel="noopener" href="http://db.apache.org/torque/">http://db.apache.org/torque/</a></td>
</tr>
<tr>
<td align="center">JRelationalFramework</td>
<td align="center"><a target="_blank" rel="noopener" href="http://jrf.sourceforge.net/">http://jrf.sourceforge.net</a></td>
</tr>
</tbody></table>
<p>​        <strong>不管是哪类<code>ORM</code>产品，首先需要保证的就是不能渗透到应用中，应用的上层组件应该和<code>ORM</code>中间件保持独立。</strong></p>
<p>​        有些<code>ORM</code>中间件要求在实体域对象中引入它们的类和接口，这会影响实体域对象的可移植性，如果日后想改用其他的<code>ORM</code>中间件，必须改写实体域对象的程序代码。另外,即使<code>ORM</code>中间件没有渗透到实体域对象中,应用程序中负责处理业务逻辑的过程域对象必须通过ORM中间件的API去访问数据库。每个<code>ORM</code>软件都有各自的<code>API</code>，如果一个应用程序起初使用了<code> Hibernate</code>,日后如果要改为使用<code>MyBatis</code>,就必须重新编写访问 <code>ORM</code> 中间件的代码。</p>
<p>​        为了削弱应用程序对特定<code>ORM</code>中间件的依赖性,<code>Oracle</code> 公司制定了统一的Java对象持久化 <code>API</code>(<code>Java Persistence API</code>,<code>JPA</code>)。<code>JPA</code>成为了各种<code> ORM</code>框架的标准<code>API</code>。<code>JPA</code>充分吸收了现有的包括<code>Hibernate</code>在内的<code>ORM</code>软件的优点,具有易于使用和伸缩性强的优势。应用程序可通过<code>JPA</code>来对实体域对象进行持久化。</p>
<h2 id="三-半自动ORM与全自动ORM框架"><a href="#三-半自动ORM与全自动ORM框架" class="headerlink" title="三. 半自动ORM与全自动ORM框架"></a>三. 半自动ORM与全自动ORM框架</h2><p>​        目前主流的持久层开发框架都是基于ORM思想的，但是ORM框架也有全自动化和半自动化之分。笔者认为，两者没有优劣之分，两者都有其适用的使用场景，对这两者都有一个较为深刻的理解也是很有必要的。</p>
<p>​        目前，主流的全自动ORM框架为Hibernate ，半自动ORM框架为Mybatis，那么，全自动和半自动的区别是什么呢？</p>
<h4 id="为什么说-Mybatis是半自动-ORM框架，而-Hibenate是全自动-ORM框架？"><a href="#为什么说-Mybatis是半自动-ORM框架，而-Hibenate是全自动-ORM框架？" class="headerlink" title="为什么说 Mybatis是半自动 ORM框架，而 Hibenate是全自动 ORM框架？"></a>为什么说 <code>Mybatis</code>是半自动 ORM框架，而 <code>Hibenate</code>是全自动 ORM框架？</h4><p>​        我们先来看看在持久层框架出现以前我们是如何对数据库进行操作的？</p>
<p>​        毋庸置疑，我们都使用 JDBC(Java Database Connectivity) 对数据库进行操作。操作步骤如下：</p>
<p>​        1. 加载驱动程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(driverClass)</span><br><span class="line">//加载MySql驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</span><br></pre></td></tr></table></figure>


<p>​        2. 获取数据库连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/imooc&quot;, &quot;root&quot;, &quot;root&quot;);</span><br></pre></td></tr></table></figure>

<pre><code>      3.  创建 `Statement` / `PerparedStatement` 对象
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn.createStatement();</span><br><span class="line">conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure>

<p>​    4. 操作数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.executeQuery(&quot;...&quot;);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>关闭连接</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>



<h5 id="Mybatis的实现机制"><a href="#Mybatis的实现机制" class="headerlink" title="Mybatis的实现机制"></a>Mybatis的实现机制</h5><p>1、读取 Mybatis的全局配置文件 mybatis-config.xml</p>
<p>2、创建 SqlSessionFactory会话工厂</p>
<p>3、创建 SqlSession会话</p>
<p>4、执行查询操作</p>
<p>mybatis-config.xml文件中包括一系列配置信息，其中包括标签 <mapper>，此标签配置了映射节点，映射节点内部定义了SQL语句。</mapper></p>
<p><strong>Mybatis将 SQL的定义工作独立出来，让用户自定义，而 SQL的解析，执行等工作交由 Mybatis处理执行。</strong></p>
<h5 id="Hibenate-的实现机制"><a href="#Hibenate-的实现机制" class="headerlink" title="Hibenate 的实现机制"></a>Hibenate 的实现机制</h5><p>1、构建 Configuration实例，初始化该实例中的变量</p>
<p>2、加载 hibenate.cfg.xml 文件到内存</p>
<p>3、通过 hibenate.cfg.xml 文件中的 mapping 节点配置并加载 xxx.hbm.xml 文件至内存</p>
<p>4、利用 Configuration实例构建 SessionFactory 实例</p>
<p>5、由SessionFactory 实例构建 session实例</p>
<p>6、由 session实例创建事务操作接口 Transaction 实例</p>
<p>7、执行查询操作</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><strong>传统的 JDBC是手工的，需要程序员加载驱动、建立连接、创建 Statement 对象、定义SQL语句、处理返回结果、关闭连接等操作。</strong></p>
<p><strong>Hibernate 是自动化的，内部封装了JDBC，并且还将 SQL 语句封装了，理念是即使开发人员不懂SQL语言也可以进行开发工作，向应用程序提供调用接口，直接调用即可。</strong></p>
<p><strong>Mybatis 是半自动化的，是介于 JDBC和 Hibernate之间的持久层框架，也是对 JDBC 进行了封装，不过将SQL的定义工作独立了出来交给用户实现，负责完成剩下的SQL解析，处理等工作。</strong></p>
<h2 id="四-Spring-Data-JPA-的前世今生"><a href="#四-Spring-Data-JPA-的前世今生" class="headerlink" title="四. Spring Data JPA 的前世今生"></a>四. Spring Data JPA 的前世今生</h2><p>由于如今EJB很少使用，许多人对此完全没有概念，因此在了解Spring Data JPA发展史之前，有必要对EJB做一个稍微详细一点的介绍，从而能对为什么如今更流行Hibernate和Spring Data JPA有一个更为清晰的认识。</p>
<h4 id="EJB-的演变史"><a href="#EJB-的演变史" class="headerlink" title="EJB 的演变史"></a>EJB 的演变史</h4><p>​        EJB (Enterprise Java Beans) 是基于分布式事务处理的企业级应用程序的组件。Sun公司发布的文档中对EJB的定义是：<strong>EJB是用于开发和部署多层结构的、分布式的、面向对象的Java应用系统的跨平台的构件体系结构</strong>。</p>
<p>​        由于 IBM 和 Sun Microsystems 等EJB提倡者力推其前景，起初一些大公司纷纷采用EJB部署他们的系统。然而随后各种问题便接踵而至，对 EJB 的恶评短时间内激增。</p>
<p>​        在实际运用中被发现，如果使用EJB来封装业务逻辑会带来性能上的下降。这是因为，<strong>最早的EJB规范只允许客户端通过特定协议</strong>（如<code>CORBA</code>进行远程方法调用）<strong>来调用</strong>，即使大部分实际应用根本就不需要分布式计算。直到EJB 2.0才引入了本地接口，以支持可以开发不通过网络就能直接本地调用的EJB系统。</p>
<p>​        尽管如此，EJB的广泛普及仍然为其复杂度所制约。尽管已经有一些高质量的集成开发工具可以协助开发人员通过自动编码解决一部分重复作业，但这并不能降低学习此项技术的难度。另一方面，“草根阶层”的编程爱好者们发起了一场旨在使用 “轻量级”技术以代替复杂的EJB的运动。这些技术包括<code>Hibernate</code>（用于提供数据持久化和对象-关系映射）及<code>Spring</code>框架（用于封装业务逻辑）。</p>
<p>​        EJB规范起初的一个主要价值—对分布式应用进行事务管理—在随后的实践中被一致认为几乎没能派上用场。对于企业级应用来说，Spring和Hibernate等简化框架更加实用。因此，EJB 3.0规范（JSR 220）为了迎合这个趋势相比于其之前的版本进行了一次激进的大跳跃。</p>
<p>​        <strong>受到Spring 影响，EJB 3.0也使用所谓的“传统简单Java对象POJO”；同时，支持依赖注入来简化全异系统的集成与配置。</strong></p>
<p>​        <strong>Hibernate的创始人Gavin King参与了这一新版规范的制订，并对EJB大加提倡。Hibernate的许多特性也被引入到Java持久化API当中，从而取代原来的实体bean。EJB 3.0规范大幅采用Java注解（annotation）来对代码进行元数据修饰，从而消减了此前EJB编程的冗杂性。</strong></p>
<p>​        <strong>相应地，EJB 3.0几乎成为了一个全新的API，与此前的数版可谓毫无相似度可言</strong>。    </p>
<p>​        在技术不断演变过程中，出现过众多璀璨的“新星”，而每一个产品的诞生也都和时代的需要有关。其实，在Hibernate和EJB演变的过程中，两者之间也有众多联系。</p>
<h4 id="EJB-和-Hibernate-的爱恨情仇"><a href="#EJB-和-Hibernate-的爱恨情仇" class="headerlink" title="EJB 和 Hibernate 的爱恨情仇"></a>EJB 和 Hibernate 的爱恨情仇</h4><p>​        在Java世界，Hibernate是最引人关注的一个话题。从Gavin King加入EJB3.0，负责制订EJB3.0的持久层规范；到Gavin King非正式退出JDO，并且充满个人情绪的攻击JDO2.0规范；到《Hibernate in Action》的发行；再到Hibernate3 Alpha的发布；最后再到最近JBoss 3.0 PR的发布(使用Hibernate3实现Entity Bean)。可以说这其中的每一步都引起业界的关注。</p>
<p>​        自从Gavin King加入JBoss之后，Hibernate已经由一个民间的开源软件走上了兼容EJB EntityBean的道路。Gavin King在EJB3.0 EG中充当了一个非常重要的角色，只要对比一下EJB3.0的EntityBean和Hibernate3，真相就会大白，<strong>虽然API接口不同，但是 EntityBean的设计理念完全来自于Hibernate。</strong></p>
<p>​        虽然EJB3.0的EntityBean在相当程度上来源于Hibernate，但是毕竟是不同的API接口，因此Hibernate和EJB3.0 EntityBean究竟是怎样的一种关系，是很多人心中的疑问。</p>
<p>​        2004年10月8日JBoss发布的EJB3.0 PR揭开了答案。Gavin King对Hibernate3进行了简单的封装，将EJB 3.0 EntityBean API调用转换为内部Hibernate3自己的API，从而实现EJB3.0 EntityBean的兼容。</p>
<p>​        EJB3.0不承诺脱离容器调用，如果你想使用EJB3.0，则必须运行在某个EJB Vendor提供的容器内，例如你使用JBoss提供的容器，那么你调用的是EntityBean API，这些调用请求会被转换为Hibernate API的调用请求。<strong>这意味着Hibernate实际上提供了两套API：一套是Hibernate原生API；另一套是兼容EJB3.0 EntityBean API。</strong></p>
<p>​        对于那些需要分布式调用支持，需要EJB容器的开发人员来说，他们选择后一套API；对于不需要EJB容器的开发人员来说，他们选择前一套 API。这就是Hibernate既定的发展策略，也是奠定其如今地位地关键。</p>
<p>​        Spring Data JPA演变成如今的样子是一个漫长的过程。在了解完什么是EJB以及其与Hibernate的关联后，要完全了解Spring Data JPA的形成过程，还得从技术架构的演变谈起。</p>
<h4 id="技术架构的演变"><a href="#技术架构的演变" class="headerlink" title="技术架构的演变"></a>技术架构的演变</h4><p>第一种：Session Bean ⇿ Entity Bean ⇿ DB        (EJB架构)<br>                                         ↓</p>
<p>第二种：Session Bean ⇿ DAO ⇿  JDBC ⇿ DB   （JDBC架构）<br>                                         ↓</p>
<p>第三种：Session Bean ⇿ DAO ⇿ Hibernate ⇿ DB   （Hibernate 架构）</p>
<p>首先我们对上面3个架构来简单分析下：<br><strong>1、内存消耗：</strong></p>
<p>​        采用JDBC的第二种架构是最省内存的，Hibernate的第三种架构次之，EJB的第一种架构最差。 </p>
<p><strong>2、运行效率：</strong></p>
<p>​        如果JDBC的代码写的非常优化，那么JDBC架构运行效率最高，但是实际项目中，这一点几乎做不到，这需要程序员非常精通JDBC，运用Batch语句批量处理，调整PreapredStatement的Batch Size和Fetch Size等参数，以及在必要的情况下采用结果集cache等等，<strong>而一般情况下程序员是做不到这一点的。</strong></p>
<p>​        因此Hibernate架构表现出最快的运行效率。</p>
<p>​        EJB的架构效率会差的很远，EJB效率低的一大原因就是通过RMI调用，RMI是一种Java的远程调用方法调用技术，要通过TCP/IP，比本地函数调用的开销要慢很多，此外entity bean效率低的还有更主要的原因，就是由于entity bean的结构造成的。由于使用entity bean每查找一行数据要进行两次数据库操作（一次是找出主键，另一次是通过主键找出数据），因此使数据库访问的效率大打折扣。 </p>
<p><strong>3、开发效率：</strong></p>
<p>​        在有JBuilder（一款Java可视化开发工具）支持下以及简单的项目，EJB架构开发效率最高，JDBC次之，Hibernate最差。但是在大的项目，特别是持久层关系映射很复杂的情况下，Hibernate效率很高，JDBC次之，而EJB架构由于其使用复杂性等原因很可能会失败。</p>
<p>​        从上面的结构演变来看，变化都是集中在Session Bean至DB之间的，而中间无非是从 Entity Bean 到 JDBC 再到 Hibernate ，这几种都是集中在对数据库的操作上，当然EJB不仅仅只是数据库操作，但是EJB 在各个方面都不占优势。因此，我们再来<strong>对这三种涉及的数据库相关操作展开分析</strong>，来对技术为什么会演变成如今的样子一探究竟。</p>
<p>​        (1) JDBC：多数Java开发人员是用JDBC来和数据库进行通信，它可以通过DAO模式进行改善和提高。但这种方式在大型应用程序中不容易操作使用，且维护起来相当困难。 </p>
<p>​        (2) EJB： EJB通常是在数据持久技术上的第二个选择，它是通过Entity Beans来对数据进行持久化。首先就需要购买一个价位合理的EJB容器一J2EE应用服务器，也可以采用开源项目的免费EJB容器，比如JBOSS。但是很多商业EJB容器的性能和技术支持不太好，在EJB中实现JDBC也比较复杂。 </p>
<p>​        (3)  Hibernate： Hibernate这种持久框架在某些方面有很大的不同，它不需要任何容器，提供简单易用的API。作为一个良好的ORM ，它有如下特点： </p>
<p>​                1. 透明地提供对象与关系数据库的映射，以统一的接口方式支持多种数据源，可以方便地进行切换。 </p>
<p>​                2. 缓存机制，缓存机制和锁定策略使针对数据库操作大大减少，提高系统运行效率地同时降低了对数据库的直接冲击。 </p>
<p>​                3. 开源免费的License，开源免费的特性使得使用人员可以自主研究源代码，并能够对系统提出建议或直接对源代码加以改进。 </p>
<p>​                4. 轻量级封装，避免引入过多复杂的问题，方便调试，减轻程序员的负担。 </p>
<p>​                5. 具有可移植性，基于JPA规范开发，使其无需手写SQL便可实现众多数据库相关操作并具有可移植性。 </p>
<p>​                ……</p>
<p>​        从上面可以看出，Hibernate相较于EJB和JDBC的结构来说，拥有众多优势，这也是如今Hibernate相较于其他两种架构更流行的原因。</p>
<h4 id="Hibernate-兼容-JPA"><a href="#Hibernate-兼容-JPA" class="headerlink" title="Hibernate 兼容 JPA"></a>Hibernate 兼容 JPA</h4><p>​        JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。</p>
<p>​        前面提到，JPA是Java EE 5规范中提出的Java持久化接口，而Hibernate是一个ORM框架，Hibernate是 JPA的一种实现。JPA是需要框架来实现其功能的，Hibernate就是JPA实现框架中很强的一个，应该说是目前最主流的一个框架。从功能上来说，JPA就是Hibernate功能的一个子集。</p>
<p>​        Hibernate 从3.2开始，就开始兼容JPA。Hibernate3.2获得了Sun TCK的JPA(Java Persistence API) 兼容认证。只要熟悉Hibernate或者其他ORM框架，在使用JPA时会发现其实非常容易上手。</p>
<h4 id="Spring-Data-JPA问世"><a href="#Spring-Data-JPA问世" class="headerlink" title="Spring Data JPA问世"></a>Spring Data JPA问世</h4><p>​        Hibernate 在 3.2 的时候提供了 JPA 的实现，其余的 JPA 的供应商还有诸如 OpenJPA、 Toplink等；Spring 在做持久化这一块的工作，开发了 Spring-data-xxx 这一系列包，如： Spring-data-jpa， Spring-data-redis， Spring-data-mongodb 等等，这些都是 Spring 提供的基于 JPA 和其他一些 NOSQL 的 Repository。</p>
<p>​        <strong>Spring Data JPA 是在 JPA 规范的基础下提供了 Repository 层的实现，但是使用哪一款 ORM 需要你自己去决定；相比我们更为熟悉的 Hibernate 和 MyBatis， Spring Data JPA 可以看做更高层次的抽象。</strong></p>
<h4 id="再看什么是Spring-Data-JPA"><a href="#再看什么是Spring-Data-JPA" class="headerlink" title="再看什么是Spring Data JPA"></a>再看什么是Spring Data JPA</h4><p><strong>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展。Spring Data JPA让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现。</strong></p>
<h2 id="五-Spring-Data-JPA的简单使用"><a href="#五-Spring-Data-JPA的简单使用" class="headerlink" title="五. Spring Data JPA的简单使用"></a>五. Spring Data JPA的简单使用</h2><h3 id="Spring-Data-JPA基本概念介绍"><a href="#Spring-Data-JPA基本概念介绍" class="headerlink" title="Spring Data JPA基本概念介绍"></a>Spring Data JPA基本概念介绍</h3><h4 id="实体类和数据库表的映射配置"><a href="#实体类和数据库表的映射配置" class="headerlink" title="实体类和数据库表的映射配置"></a>实体类和数据库表的映射配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*		* 所有的注解都是使用JPA的规范提供的注解，</span><br><span class="line"> *		* 所以在导入注解包的时候，一定要导入javax.persistence下的</span><br><span class="line"> */</span><br><span class="line">@Entity //声明实体类</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@Table(name=&quot;cst_customer&quot;) //建立实体类和表的映射关系</span><br><span class="line">public class Customer &#123;</span><br><span class="line">	</span><br><span class="line">	@Id//声明当前私有属性为主键</span><br><span class="line">	@GeneratedValue(strategy=GenerationType.IDENTITY) //配置主键的生成策略</span><br><span class="line">	@Column(name=&quot;cust_id&quot;) //指定和表中cust_id字段的映射关系</span><br><span class="line">	private Long custId;</span><br><span class="line">	</span><br><span class="line">	@Column(name=&quot;cust_name&quot;) //指定和表中cust_name字段的映射关系</span><br><span class="line">	private String custName;</span><br><span class="line">	</span><br><span class="line">	@Column(name=&quot;cust_source&quot;)//指定和表中cust_source字段的映射关系</span><br><span class="line">	private String custSource;</span><br><span class="line">	</span><br><span class="line">	@Column(name=&quot;cust_industry&quot;)//指定和表中cust_industry字段的映射关系</span><br><span class="line">	private String custIndustry;</span><br><span class="line">	</span><br><span class="line">	@Column(name=&quot;cust_level&quot;)//指定和表中cust_level字段的映射关系</span><br><span class="line">	private String custLevel;</span><br><span class="line">	</span><br><span class="line">	@Column(name=&quot;cust_address&quot;)//指定和表中cust_address字段的映射关系</span><br><span class="line">	private String custAddress;</span><br><span class="line">	</span><br><span class="line">	@Column(name=&quot;cust_phone&quot;)//指定和表中cust_phone字段的映射关系</span><br><span class="line">	private String custPhone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="常用注解说明"><a href="#常用注解说明" class="headerlink" title="常用注解说明"></a>常用注解说明</h4><blockquote>
<p>@Entity</p>
<p>​      作用：指定当前类是实体类。</p>
<p>​    @Table</p>
<p>​      作用：指定实体类和表之间的对应关系。</p>
<p>​      属性：</p>
<p>​        name：指定数据库表的名称</p>
<p>​    @Id</p>
<p>​      作用：指定当前字段是主键。</p>
<p>​    @GeneratedValue</p>
<p>​      作用：指定主键的生成方式。。</p>
<p>​      属性：</p>
<p>​        strategy ：指定主键生成策略。</p>
<p>​    @Column</p>
<p>​      作用：指定实体类属性和数据库表之间的对应关系</p>
<p>​      属性：</p>
<p>​        name：指定数据库表的列名称。</p>
<p>​        unique：是否唯一 </p>
<p>​        nullable：是否可以为空 </p>
<p>​        inserttable：是否可以插入 </p>
<p>​        updateable：是否可以更新 </p>
<p>​        columnDefinition: 定义建表时创建此列的DDL </p>
<p>​        secondaryTable: 从表名。如果此列不建在主表上（默认建在主表），该属性定义该列所在从表的名字搭建开发环境（主键所在的表是主表。 外键所在的表是从表）</p>
</blockquote>
<h5 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h5><p>通过annotation（注解）来映射hibernate实体的,基于annotation的hibernate主键标识为@Id, 其生成规则由@GeneratedValue设定的.这里的@id和@GeneratedValue都是JPA的标准用法。</p>
<p>JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO。</p>
<p>具体说明如下：</p>
<p>**IDENTITY: **主键由数据库自动生成（主要是自动增长型）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Id  </span><br><span class="line">@GeneratedValue(strategy = GenerationType.IDENTITY) </span><br><span class="line">private Long custId;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p><strong>SEQUENCE</strong>：根据底层数据库的序列来生成主键，条件是数据库支持序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	@Id  </span><br><span class="line">   @GeneratedValue(strategy = GenerationType.SEQUENCE,generator=&quot;payablemoney_seq&quot;)  </span><br><span class="line">   @SequenceGenerator(name=&quot;payablemoney_seq&quot;, sequenceName=&quot;seq_payment&quot;)  </span><br><span class="line">private Long custId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //@SequenceGenerator源码中的定义</span><br><span class="line">   @Target(&#123;TYPE, METHOD, FIELD&#125;)   </span><br><span class="line">   @Retention(RUNTIME)  </span><br><span class="line">   public @interface SequenceGenerator &#123;  </span><br><span class="line">      //表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中</span><br><span class="line">      String name();  </span><br><span class="line">      //属性表示生成策略用到的数据库序列名称。</span><br><span class="line">      String sequenceName() default &quot;&quot;;  </span><br><span class="line">      //表示主键初识值，默认为0</span><br><span class="line">      int initialValue() default 0;  </span><br><span class="line">      //表示每次主键值增加的大小，例如设置1，则表示每次插入新记录后自动加1，默认为50</span><br><span class="line">      int allocationSize() default 50;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>AUTO</strong>：主键由程序控制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Id  </span><br><span class="line">  @GeneratedValue(strategy = GenerationType.AUTO)  </span><br><span class="line">  private Long custId;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>TABLE</strong>：使用一个特定的数据库表格来保存主键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Id  </span><br><span class="line">   @GeneratedValue(strategy = GenerationType.TABLE, generator=&quot;payablemoney_gen&quot;)  </span><br><span class="line">   @TableGenerator(name = &quot;pk_gen&quot;,  </span><br><span class="line">       table=&quot;tb_generator&quot;,  </span><br><span class="line">       pkColumnName=&quot;gen_name&quot;,  </span><br><span class="line">       valueColumnName=&quot;gen_value&quot;,  </span><br><span class="line">       pkColumnValue=&quot;PAYABLEMOENY_PK&quot;,  </span><br><span class="line">       allocationSize=1  </span><br><span class="line">   ) </span><br><span class="line">private Long custId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//@TableGenerator的定义：</span><br><span class="line">   @Target(&#123;TYPE, METHOD, FIELD&#125;)    </span><br><span class="line">   @Retention(RUNTIME)  </span><br><span class="line">   public @interface TableGenerator &#123;  </span><br><span class="line">     //表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中</span><br><span class="line">     String name();  </span><br><span class="line">     //表示表生成策略所持久化的表名，例如，这里表使用的是数据库中的“tb_generator”。</span><br><span class="line">     String table() default &quot;&quot;;  </span><br><span class="line">     //catalog和schema具体指定表所在的目录名或是数据库名</span><br><span class="line">     String catalog() default &quot;&quot;;  </span><br><span class="line">     String schema() default &quot;&quot;;  </span><br><span class="line">     //属性的值表示在持久化表中，该主键生成策略所对应键值的名称。例如在“tb_generator”中将“gen_name”作为主键的键值</span><br><span class="line">     String pkColumnName() default &quot;&quot;;  </span><br><span class="line">     //属性的值表示在持久化表中，该主键当前所生成的值，它的值将会随着每次创建累加。例如，在“tb_generator”中将“gen_value”作为主键的值 </span><br><span class="line">     String valueColumnName() default &quot;&quot;;  </span><br><span class="line">     //属性的值表示在持久化表中，该生成策略所对应的主键。例如在“tb_generator”表中，将“gen_name”的值为“CUSTOMER_PK”。 </span><br><span class="line">     String pkColumnValue() default &quot;&quot;;  </span><br><span class="line">     //表示主键初识值，默认为0。 </span><br><span class="line">     int initialValue() default 0;  </span><br><span class="line">     //表示每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50。</span><br><span class="line">     int allocationSize() default 50;  </span><br><span class="line">     UniqueConstraint[] uniqueConstraints() default &#123;&#125;;  </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   //这里应用表tb_generator，定义为 ：</span><br><span class="line">   CREATE TABLE  tb_generator (  </span><br><span class="line">     id NUMBER NOT NULL,  </span><br><span class="line">     gen_name VARCHAR2(255) NOT NULL,  </span><br><span class="line">     gen_value NUMBER NOT NULL,  </span><br><span class="line">     PRIMARY KEY(id)  </span><br><span class="line">   )</span><br></pre></td></tr></table></figure>



<h4 id="Spring-Data-JPA完整体验"><a href="#Spring-Data-JPA完整体验" class="headerlink" title="Spring Data JPA完整体验"></a>Spring Data JPA完整体验</h4><p>由于现在大多数时候，都会结合SpringBoot等框架来进行开发，因此本例采用和SpringBoot结合使用的场景来讲解。</p>
<p>首先在maven中引入依赖包（若使用gradle可自行在官网查询）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>​        先看一个简单的例子，实现增删查改的功能；从例子中我们可以发现，可以通过方法名称的定义，就可以达到 SQL 的效果:</p>
<p>比如 findByName(String name) 就相当于 select * from user where name = ?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface UserCrudRepository extends CrudRepository&lt;User, String&gt;&#123;    </span><br><span class="line">	User findOne(String userid);    </span><br><span class="line">	List&lt;User&gt; findByName(String name);    </span><br><span class="line">	List&lt;User&gt; findByNameAndAgeLessThan(String name, int age);    </span><br><span class="line">	void deleteByNameAndAgeLessThan(String name, int age);    </span><br><span class="line">	List&lt;User&gt; findDistinctByName(String name);    </span><br><span class="line">	List&lt;User&gt; findByNameIgnoreCase(String name);    </span><br><span class="line">	User findFirstByOrderByUseridDesc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h4><p>Spring Date JPA提供了几个接口：</p>
<ul>
<li>Repository：最顶层的接口，是一个空的接口，目的是为了统一所有Repository的类型，且能让组件扫描的时候自动识别。</li>
<li>CrudRepository：是Repository的子接口，提供CRUD的功能。</li>
<li>PagingAndSortingRepository ：是CrudRepository的子接口，添加分页和排序的功能。</li>
<li>JpaRepository ：是PagingAndSortingRepository的子接口，增加了批量操作等功能。</li>
</ul>
<h4 id="完整体验"><a href="#完整体验" class="headerlink" title="完整体验"></a>完整体验</h4><h5 id="yml配置项"><a href="#yml配置项" class="headerlink" title="yml配置项"></a>yml配置项</h5><p>首先如本节开头所述，在maven中引入依赖，然后在application.yml中编写如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring：</span><br><span class="line">	jpa:</span><br><span class="line">    show-sql: true </span><br><span class="line">    database: mysql</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update // 每次运行程序，没有表格会新建表格，表内有数据 不会清空，只会更新</span><br><span class="line">    open-in-view: false</span><br></pre></td></tr></table></figure>



<p>创建三个实体类：Intent（意图）、Question（问题）、Answer（答案），其中 Intent 和 Question 为一对多关系， Intent 和 Answer 也为一对多关系。</p>
<h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;intent&quot;)</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line">public class Intent &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy= GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;id&quot;, length = 11)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;intentName&quot;, length = 500, nullable = false)</span><br><span class="line">    private String intentName;</span><br><span class="line"></span><br><span class="line">    @OneToMany(targetEntity = Question.class,fetch=FetchType.EAGER,cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JsonIgnoreProperties(value = &#123;&quot;intent&quot;&#125;)</span><br><span class="line">    private Set&lt;Question&gt; questionList = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @OneToMany(targetEntity = Answer.class,fetch=FetchType.EAGER,cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JsonIgnoreProperties(value = &#123;&quot;intent&quot;&#125;)</span><br><span class="line">    private Set&lt;Answer&gt; answerList = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;create_time&quot;, nullable = false)</span><br><span class="line">    @CreatedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;update_time&quot;, nullable = false)</span><br><span class="line">    @LastModifiedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;deleted&quot;, insertable = false, columnDefinition=&quot;int default 0&quot;)</span><br><span class="line">    private Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;answer&quot;)</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line">public class Answer implements Serializable &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy= GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;id&quot;, length = 11)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;answer&quot;, length = 1000, nullable = false)</span><br><span class="line">    private String answer;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JoinColumn(name = &quot;intent_id&quot;, referencedColumnName = &quot;id&quot;)</span><br><span class="line">    private Intent intent;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;create_time&quot;, nullable = false)</span><br><span class="line">    @CreatedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;update_time&quot;, nullable = false)</span><br><span class="line">    @LastModifiedDate</span><br><span class="line">    @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;deleted&quot;, length = 1, columnDefinition=&quot;tinyint default 0&quot;, insertable = false)</span><br><span class="line">    private Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;question&quot;)</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line">public class Question implements Serializable &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy= GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;id&quot;, length = 11)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;question&quot;, length = 500, nullable = false)</span><br><span class="line">    private String question;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JoinColumn(name = &quot;intent_id&quot;, referencedColumnName = &quot;id&quot;)</span><br><span class="line">    private Intent intent;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;create_time&quot;, nullable = false)</span><br><span class="line">    @CreatedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;update_time&quot;, nullable = false)</span><br><span class="line">    @LastModifiedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;deleted&quot;, length = 1, columnDefinition=&quot;tinyint default 0&quot;, insertable = false)</span><br><span class="line">    private Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在编写完实体类后，并在数据库创建名为“chat”的数据库后，启动项目，数据库将会按照实体类映射关系自动创建数据库表。</p>
<h5 id="持久层-1"><a href="#持久层-1" class="headerlink" title="持久层"></a>持久层</h5><p>编写持久层接口，并继承 JpaRepository 和 JpaSpecificationExecutor。如果只需要基本的一些操作，也可以只继承 JpaRepository ，视使用场景而定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IntentDao extends JpaRepository&lt;Intent, Integer&gt;, JpaSpecificationExecutor &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h5><p>在service中，利用 Spring 的依赖注入获取 <code>IntentDao</code>后，对其进行增、删、改、查操作。</p>
<h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface IntentService &#123;</span><br><span class="line">    Page&lt;Intent&gt; list(Integer page, Integer size);</span><br><span class="line"></span><br><span class="line">    Intent insert(Intent intent);</span><br><span class="line"></span><br><span class="line">    Intent update(Intent intent);</span><br><span class="line"></span><br><span class="line">    Intent delete(Intent intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class IntentServiceImpl implements IntentService &#123;</span><br><span class="line">    private IntentDao intentDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public IntentServiceImpl(IntentDao intentDao) &#123;</span><br><span class="line">        this.intentDao = intentDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Page&lt;Intent&gt; list(Integer page, Integer size) &#123;</span><br><span class="line">        Specification specification = new Specification&lt;Intent&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Predicate toPredicate(Root root, CriteriaQuery query, CriteriaBuilder criteriaBuilder) &#123;</span><br><span class="line">                return criteriaBuilder.notEqual(root.get(&quot;deleted&quot;).as(Integer.class), &quot;1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        return  intentDao.findAll(specification, PageRequest.of(page, size));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Intent insert(Intent intent) &#123;</span><br><span class="line">        return intentDao.save(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Intent update(Intent intent) &#123;</span><br><span class="line">        return intentDao.save(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Intent delete(Intent intent) &#123; // 注意：这里删除使用的是逻辑删除，若为物理删除，则使用 intentDao.delete(intent);</span><br><span class="line">        intent.setDeleted(1);</span><br><span class="line">        return intentDao.save(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/intent&quot;)</span><br><span class="line">public class IntentController &#123;</span><br><span class="line">    private IntentService intentService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public IntentController(IntentService intentService) &#123;</span><br><span class="line">        this.intentService = intentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;list&quot;)</span><br><span class="line">    public Response list(@RequestParam(&quot;page&quot;) Integer page,</span><br><span class="line">                             @RequestParam(&quot;size&quot;) Integer size) &#123;</span><br><span class="line">        return Response.success(intentService.list(page, size));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;create&quot;)</span><br><span class="line">    public Response create(@RequestBody Intent intent) &#123;</span><br><span class="line">        return Response.success(intentService.insert(intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;update&quot;)</span><br><span class="line">    public Response update(@RequestBody Intent intent) &#123;</span><br><span class="line">        return Response.success(intentService.update(intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;delete&quot;)</span><br><span class="line">    public Response delete(@RequestBody Intent intent) &#123;</span><br><span class="line">        return Response.success(intentService.delete(intent));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableJpaAuditing // 此注解作用是开启自动数据字段填充功能，比如 create_time 等字段在创建时直接插入系统当前时间</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ChatApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ChatApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是关于Spring Data JPA的完成示例</p>
<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h2><p>从时间线来看：</p>
<ol>
<li> Hibernate 的团队开发了 Hibernate</li>
<li>制订 J2EE 规范的团队邀请 Hibernate 的核心团队在 Hibernate 基础上制订了 JPA （Java Persistent API）标准。<strong>从功能上看，JPA 是 Hibernate 的子集。</strong></li>
<li>Spring 的团队使用 Spring 对 JPA 做了封装，就是 Spring Data JPA 了。</li>
</ol>
<p>​        总之，JPA 是一个 API 标准，除了 Hibernate 外，还有其它厂商的实现，例如 Eclipse 的 TopLink。<strong>Spring Data Jpa 是个对 JPA 的封装，帮助程序员以 Spring 的方式来使用 JPA。</strong></p>
<p>参考文献：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ORM%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ORM%E6%80%9D%E6%83%B3/" class="post-title-link" itemprop="url">深入理解ORM思想</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-26 14:34:02" itemprop="dateCreated datePublished" datetime="2022-03-26T14:34:02+08:00">2022-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-23 17:02:48" itemprop="dateModified" datetime="2022-04-23T17:02:48+08:00">2022-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringDataJPA/" itemprop="url" rel="index"><span itemprop="name">SpringDataJPA</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ORM%E6%80%9D%E6%83%B3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ORM%E6%80%9D%E6%83%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ORM简介"><a href="#ORM简介" class="headerlink" title="ORM简介"></a>ORM简介</h3><p>​        <code>ORM</code>即对象-关系映射（Object Relational Mapping），指的是在单个组件中负责所有实体域对象的持久化，封装数据库访问细节。它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的<code>SQL</code>语句打交道，只要像平时操作对象一样操作它就可以了 。</p>
<p>​        <strong>在探究什么是<code>ORM</code>之前，首先需要搞清楚几个概念：持久化和持久层。</strong></p>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>​        即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、<code>XML</code>中等等。</p>
<p>​        <code>Hibernate ORM</code>关心的是帮助应用程序实现持久性。持久性仅仅意味着我们希望应用程序的数据比应用程序进程的寿命更长。用<code>Java</code>术语来说，我们希望(一些)对象的状态超出<code>JVM</code>所能管控的范围，以便稍后可以使用相同的状态。</p>
<h4 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h4><p>​        即专注于实现数据持久化应用领域的某个特定系统的一个<strong>逻辑层面</strong>，将数据使用者和数据实体相关联。</p>
<h3 id="ORM是一种思想"><a href="#ORM是一种思想" class="headerlink" title="ORM是一种思想"></a>ORM是一种思想</h3><p>​        在了解完以上几个概念后，我们有必要深入了解一下到底什么才是<code>ORM</code>。正如标题所说，<code>ORM</code>我认为其实是一种面向对象编程演变过程中，形成的一种编程思想。</p>
<h4 id="究竟什么是面向对象"><a href="#究竟什么是面向对象" class="headerlink" title="究竟什么是面向对象"></a>究竟什么是面向对象</h4><p>​        一个优秀的软件架构，是要基于面向对象设计的深入理解与运用的，那么，究竟什么才是面向对象呢？很多人碰到这个问题，通常会甩出三个词——继承、封装、多态，我碰到许多人都会这么回答，当然这没有错，但总让我感觉这个回答有点生疏。另一种常见的回答则是“面向对象是一种对真实世界进行建模的方式”，似乎好像比上一种更容易理解一点，但是也只能算是避重就轻，“对真实世界的建模”到底要如何进行？我们为什么要这么做？这么做有什么好处？许多人问到这便会陷入困境，不知如何回答。</p>
<p>​        那让我们先详细了解一下生疏而又神秘的三个特性——继承、封装、多态。这十分有利于我们去理解<code>ORM</code>思想。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>​        所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​        所谓继承，是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>​        就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
<p>​        面向对象的三大特性，其中一个非常重要的用处就是使得程序可复用性极高，它使得我们的软件体系架构得到解耦。其实这些思想和操作系统也有着很大的关联，比如在<code>UNIX</code>操作系统中，IO设备是被设计成插件形式的，简单说就是：程序和设备无关。而这又可以引申出另一种编程模式：依赖反转。</p>
<h4 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h4><p>​        设想一下，假如有一个main函数，控制着A、B、C三个函数，而A、B、C分别控制着A1、A2、A3，B1、B2、B3，C1、C2、C3函数。这样，main函数要调用其他模块，就必须看到其他模块所在的模块，每个函数的调用方就必须引用被调用方所在的模块，<strong>这样就导致系统行为决定控制流，而控制流决定着源代码的依赖关系。</strong></p>
<p>​        再设想一下，有一个main函数、一个A接口、一个A接口的实现类，函数的调用是通过源代码级别的接口来实现的，此时的依赖关系方向和控制流是相反的，我们在称之为<code>依赖反转</code> 。</p>
<p>​        通过这种方法，软件工程师可以完全控制采用了面向对象编程方式中的所有源代码依赖关系，而不再收到系统控制流的限制。不管哪个模块调用或者被调用，软件工程师都可以随意更改源代码依赖关系。</p>
<h4 id="回到问题"><a href="#回到问题" class="headerlink" title="回到问题"></a>回到问题</h4><p>​        <strong>那么我们回到最开始的问题，究竟什么才是面向对象编程呢？其实在笔者看过的许多经典作品中，很多人对此都有不同的说法和意见，但是对于软件工程师而言：面向对象编程就是以多态的手段对源代码中的依赖关系加以控制和约束，让高层代码对低层代码达到解耦的目的，实现相对独立的编程开发工作，这也是目前主流的软件体系架构思想。</strong></p>
<p>​        了解以上内容后，我们回到主题：什么是<code>ORM</code>思想？它和面向对象有什么关系？为什么需要<code>ORM</code>？</p>
<p>​        在目前的企业应用系统设计中，<code>MVC</code>，即 Model（模型）- View（视图）- Control（控制）为主要的系统架构模式。<code>MVC</code> 中的 Model 包含了复杂的业务逻辑和数据逻辑，以及数据存取机制（如<code> JDBC</code>的连接、<code>SQL</code>生成和<code>Statement</code>创建、还有<code>ResultSet</code>结果集的读取等）等。</p>
<p>​        将这些复杂的业务逻辑和数据逻辑分离，以将系统的紧耦 合关系转化为松耦合关系（即解耦合），是降低系统耦合度迫切要做的，也是持久化要做的工作。</p>
<p><code>MVC</code> 模式实现了架构上将表现层（即View）和数据处理层（即Model）分离的解耦合，而持久化的设计则实现了数据处理层内部的业务逻辑和数据逻辑分离的解耦合。 而 <code>ORM </code>作为持久化设计中的最重要也最复杂的技术，也是目前业界热点技术。</p>
<p>​        简单来说，按通常的系统设计，使用<code> JDBC</code> 操作数据库，业务处理逻辑和数据存取逻辑是混杂在一起的。<br>​        一般基本都是如下几个步骤：<br>​            1、建立数据库连接，获得<code>Connection</code>对象。<br>​            2、根据用户的输入组装查询<code> SQL</code> 语句。<br>​            3、根据<code> SQL</code> 语句建立<code> Statement</code> 对象 或者<code>PreparedStatement</code>对象。<br>​            4、用<code>Connection</code>对象执行<code> SQL</code>语句，获得结果集<code> ResultSet</code> 对象。<br>​            5、然后一条一条读取结果集 <code>ResultSet</code> 对象中的数据。<br>​            6、根据读取到的数据，按特定的业务逻辑进行计算。<br>​            7、根据计算得到的结果再组装更新<code> SQL</code> 语句。<br>​            8、再使用 <code>Connection</code> 对象执行更新 <code>SQL</code> 语句，以更新数据库中的数据。<br>​            9、最后依次关闭各个<code>Statement</code>对象和 <code>Connection</code> 对象。</p>
<p>​        由上可看出代码逻辑非常复杂，这还不包括某条语句执行失败的处理逻辑。其中的业务处理逻辑和数据存取逻辑完全混杂在一块。</p>
<p>而一个完整的系统要包含成 千上万个这样重复的而又混杂的处理过程，假如要对其中某些业务逻辑或者一些相关联的业务流程做修改，要改动的代码量将不可想象。</p>
<p>​        另一方面，假如要换数据库产品或者运行环境也可能是个不可能完成的任务。而用户的运行环境和要求却千差万别，我们不可能为每一个用户每一种运行环境设计一套一样的系统。</p>
<p>​        所以就要将一样的处理代码即业务逻辑和可能不一样的处理即数据存取逻辑分离开来，另一方面，关系型数据库中的数据基本都是以一行行的数据进行存取的，而程序 运行却是一个个对象进行处理，而目前大部分数据库驱动技术（如<code>ADO.NET</code>、<code>JDBC</code>、<code>ODBC</code>等等）均是以行集的结果集一条条进行处理的。</p>
<p>​        所以为解决这一困难，就出现<code> ORM</code> 这一个对象和数据之间映射技术。</p>
<p>​        举例来说，比如要完成一个购物打折促销的程序，用 <code>ORM</code> 思想将如下实现：</p>
<p>​        业务逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Double calcAmount(String customerid, double amount) &#123;</span><br><span class="line">  // 根据客户ID获得客户记录</span><br><span class="line">  Customer customer = CustomerManager.getCustomer(custmerid); </span><br><span class="line">  // 根据客户等级获得打折规则</span><br><span class="line">  Promotion promotion = PromotionManager.getPromotion(customer.getLevel()); </span><br><span class="line">  // 累积客户总消费额，并保存累计结果</span><br><span class="line">  customer.setSumAmount(customer.getSumAmount().add(amount); </span><br><span class="line">  CustomerManager.save(customer); </span><br><span class="line">  // 返回打折后的金额</span><br><span class="line">  return amount.multiply(protomtion.getRatio()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这样代码就非常清晰了，而且与数据存取逻辑完全分离。设计业务逻辑代码的时候完全不需要考虑数据库<code>JDBC</code>的那些千篇一律的操作，而将它交给 <code>CustomerManager</code> 和 <code>PromotionManager</code> 两个类去完成。这就是一个简单的 <code>ORM</code> 设计，实际的 <code>ORM</code> 实现框架比这个要复杂的多。</p>
<h3 id="常用的ORM中间件"><a href="#常用的ORM中间件" class="headerlink" title="常用的ORM中间件"></a>常用的ORM中间件</h3><p>​        开发<code>ORM</code>中间件需要十分专业的知识，因此一般在企业应用开发过程中都使用第三方提供的<code>ORM</code>中间件。下面列出了一些常用的<code>ORM</code>软件可供参考使用：</p>
<table>
<thead>
<tr>
<th align="center">ORM软件</th>
<th align="center">URL</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hibernate</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.hibernate.org/">http://www.hibernate.org/</a></td>
</tr>
<tr>
<td align="center">Mybatis</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.mybatis.org/">http://www.mybatis.org/</a></td>
</tr>
<tr>
<td align="center">Torque</td>
<td align="center"><a target="_blank" rel="noopener" href="http://db.apache.org/torque/">http://db.apache.org/torque/</a></td>
</tr>
<tr>
<td align="center">JRelationalFramework</td>
<td align="center"><a target="_blank" rel="noopener" href="http://jrf.sourceforge.net/">http://jrf.sourceforge.net</a></td>
</tr>
</tbody></table>
<p>​        不管是哪类<code>ORM</code>产品，首先需要保证的就是不能渗透到应用中，应用的上层组件应该和<code>ORM</code>中间件保持独立。有些<code>ORM</code>中间件要求在实体域对象中引入它们的类和接口，这会影响实体域对象的可移植性，如果日后想改用其他的<code>ORM</code>中间件，必须改写实体域对象的程序代码。</p>
<p>​        另外,即使<code>ORM</code>中间件没有渗透到实体域对象中,应用程序中负责处理业务逻辑的过程域对象必须通过ORM中间件的API去访问数据库。</p>
<p>​        每个<code>ORM</code>软件都有各自的<code>API</code>，如果一个应用程序起初使用了<code> Hibernate</code>,日后如果要改为使用<code>MyBatis</code>,就必须重新编写访问 <code>ORM</code> 中间件的代码。为了削弱应用程序对特定<code>ORM</code>中间件的依赖性,<code>Oracle</code> 公司制定了统一的Java对象持久化 <code>API</code>(<code>Java Persistence API</code>,<code>JPA</code>)。<code>JPA</code>成为了各种<code> ORM</code>架的标准<code>API</code>。</p>
<p>​        <code>JPA</code>充分吸收了现有的包括<code>Hibernate</code>在内的<code>ORM</code>软件的优点,具有易于使用和伸缩性强的优势。应用程序可通过<code>JPA</code>来对实体域对象进行持久化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/03/06/MySQL%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/MySQL%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">MySQL如何选择合适的数据类型和索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-06 16:36:28" itemprop="dateCreated datePublished" datetime="2022-03-06T16:36:28+08:00">2022-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-18 15:47:16" itemprop="dateModified" datetime="2022-04-18T15:47:16+08:00">2022-04-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/06/MySQL%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/06/MySQL%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h2><h4 id="时间类型选择"><a href="#时间类型选择" class="headerlink" title="时间类型选择"></a>时间类型选择</h4><table>
<thead>
<tr>
<th align="center">日期和时间类型</th>
<th align="center">字节</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATE</td>
<td align="center">4</td>
<td align="center">1000-01-01</td>
<td align="center">9999-12-31</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="center">8</td>
<td align="center">1000-01-01 00:00:00</td>
<td align="center">9999-12-31 23:59:59</td>
</tr>
<tr>
<td align="center">TIMESTAMP</td>
<td align="center">4</td>
<td align="center">19700101080001</td>
<td align="center">2038年某个时刻</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">3</td>
<td align="center">-838：59：59</td>
<td align="center">838：59：59</td>
</tr>
<tr>
<td align="center">YEAR</td>
<td align="center">1</td>
<td align="center">1901</td>
<td align="center">2155</td>
</tr>
</tbody></table>
<p>其中，<code>TimeStamp</code>有一个重要的特点，就是和时区相关。当插入日期时，会先转换为本地时区后存储，后续需要取出时，也需要根据所在地时区进行转换显示。这样，不同时区的用户看到的同一个日期可能是不一样的。</p>
<h4 id="CHAR和VARCHAR"><a href="#CHAR和VARCHAR" class="headerlink" title="CHAR和VARCHAR"></a><code>CHAR</code>和<code>VARCHAR</code></h4><table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">CHAR(4)</th>
<th align="center">存储需求</th>
<th align="center">VARCHAR(4)</th>
<th align="center">存储需求</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“</td>
<td align="center">‘  ‘</td>
<td align="center">4个字节</td>
<td align="center">“</td>
<td align="center">1个字节</td>
</tr>
<tr>
<td align="center">‘ab’</td>
<td align="center">‘ab ‘</td>
<td align="center">4个字节</td>
<td align="center">‘ab ‘</td>
<td align="center">3个字节</td>
</tr>
<tr>
<td align="center">‘abcd’</td>
<td align="center">‘abcd’</td>
<td align="center">4个字节</td>
<td align="center">‘abcd’</td>
<td align="center">5个字节</td>
</tr>
<tr>
<td align="center">‘abcdefgh’</td>
<td align="center">‘abcd’</td>
<td align="center">4个字节</td>
<td align="center">‘abcd’</td>
<td align="center">5个字节</td>
</tr>
</tbody></table>
<blockquote>
<p>注：上图中最后一行只适用于<code>MySQL</code>的非严格模式，如果在严格模式，超过列长度的值将不会保存并出现错误提示。</p>
</blockquote>
<p><code>VARCHAR(4)</code>列显示的存储需求比实际字符长度多1，因为<code>VACHAR</code>要用1~2个字节要记录字节长度，低于255字节时使用一个，高于使用两个。（一个字节存储8位无符号数,储存的数值范围为0-255）</p>
<p>而不同的存储引擎对于两者的使用原则也有所不同：（个人认为造成使用原则不同的原因主要是两个存储方式不同，两种存储引擎都是基于<code>B+树</code>数据结构存储表数据的，但是区别在于<code>InnoDB</code>存储引擎中的<code>B+树</code>即存储了索引又存储了所有数据，而<code>MyISAM</code>中的<code>B+树</code>中只存储了数据的索引的Key值得地址，实际的数据存储在其他地方）</p>
<p><code>MyISAM</code>存储引擎：建议使用固定长度的数据列代替代替可变长度的数据列。</p>
<p><code>InnoDB</code>存储引擎：建议使用<code>VARCHAR</code>类型。对于<code>InnoDB</code>表，内部的行存储格式并没有区分固定长度和可变长度列（所有的数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的<code>CHAR</code>列不一定比使用可变长度的<code>VARCHAR</code>性能要好。因此，主要的性能因素都在行存储的数据量大小。由于<code>VARCHAR</code>的平均占用空间小于<code>CHAR</code>，因此使用<code>VARCHAR</code>来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。</p>
<h4 id="TEXT和BLOB"><a href="#TEXT和BLOB" class="headerlink" title="TEXT和BLOB"></a><code>TEXT</code>和<code>BLOB</code></h4><p><code>BLOB</code>主要用于保存一些二进制数据，比如照片；而<code>TEXT</code>只能保存字符数据。</p>
<p>但是这两种数据类型会引发一些性能问题，特别是执行过大量的删除操作后，会在数据表留下很大的数据“空洞”，以后填入这些空洞的记录在插入的性能上会有影响。可以通过执行<code>OPTIMIZE TABLE</code>对这类表进行碎片整理。</p>
<p>一般来说，不建议使用这两种数据类型，如果确实需要使用，建议将这两种数据类型分在不同的表中。这样会减少主表存储碎片，显著减少主表的数据量从而获得性能优势。</p>
<blockquote>
<p>优先使用<code>VARCHAR</code>类型，<code>VARCHAR</code>最长可以支持65533字节的长度，可以满足绝大多数需求。</p>
</blockquote>
<h4 id="浮点数和定点数"><a href="#浮点数和定点数" class="headerlink" title="浮点数和定点数"></a>浮点数和定点数</h4><p>当一个数据被定义为浮点数时，如果插入的数据精度超过该列定义的实际精度，则插入值会被四舍五入到实际精度。</p>
<p><strong>定点数实际上是以字符串形式存储的。</strong>所以定点数可以更精确地保存数据,因此在一些对数据精度要求比较高的场合（比如货币），一般使用定点数。</p>
<h2 id="索引设计和使用"><a href="#索引设计和使用" class="headerlink" title="索引设计和使用"></a>索引设计和使用</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>正确使用索引，是提高select操作性能的最佳途径。每种存储引擎对每个表至少支持16个索引，总索引的长度至少为256字节。</p>
<h3 id="索引在不同引擎中如何存储"><a href="#索引在不同引擎中如何存储" class="headerlink" title="索引在不同引擎中如何存储"></a>索引在不同引擎中如何存储</h3><p><code>InnoDB</code> 的表是根据主键进行展开的 B+tree 的聚集索引。<code>MyISAM </code>则为非聚集型索引，**<code>MyISAM</code> 存储会有两个文件，一个是索引文件，另外一个是数据文件，**其中索引文件中的索引指向数据文件中的表数据。</p>
<p>聚集型索引并不是一种单独的索引类型，而是一种存储方式，<code>InnoDB </code>聚集型索引实际上是在同一结构中保存了 B+tree 索引和数据行。当有聚簇索引时，<strong>它的索引实际放在叶子页中。</strong></p>
<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p>最适合索引的列是出现在<code>where</code>子句中的列，或连接子句中指定的列，而不是出现在select关键字后的选择列表中的列。</p>
<p>索引列的基数越大，索引的效果越好。比如出生日期具有不同值，很容易区分各行；而对于性别就两种值，不管搜索哪个值，都会得到一半的结果。</p>
<p>使用短索引。假如有一个CHAR(200)，如果前10或20个字符内，多数值都是唯一的，那么索引就只对前面具有唯一值的使用，能够节省大量索引空间。</p>
<p>利用最左前缀。见下一小节。</p>
<p>对于<code>InnoDB</code>的引擎，尽量手工指定主键。记录默认会按照一定的顺序保存，若有明确定义的主键，则按照主键顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个顺序去保存。按照主键或内部列进行访问是最快的，所以<code>InnoDB</code>表尽量指定主键。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>在<code>MySQL</code>建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<p>要想理解联合索引的最左匹配原则，先来理解下索引的底层原理。索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p>
<p>举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子：</p>
<p><img src="https://img2020.cnblogs.com/blog/1804577/202005/1804577-20200521182659976-48843100.png" alt="https://img2020.cnblogs.com/blog/1804577/202005/1804577-20200521182659976-48843100.png"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为<code>MySQL</code>创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引。</p>
<h3 id="不可见索引"><a href="#不可见索引" class="headerlink" title="不可见索引"></a>不可见索引</h3><p><code>MySQL8.0</code>提供的不可见索引，是为了减小对于表上的索引进行调整时可能会带来的潜在风险。当删除一个你认为不再需要的索引时，一旦系统中还存在个别使用该索引的<code>SQL</code>，那么这些<code>SQL</code>的执行可能会转为全表扫描，严重的话可能直接击垮数据库。并且重建索引需要的时间和消耗的系统资源也会很大。</p>
<p>有了不可见索引，当需要删除一个表的冗余索引时，可能先将其设为不可见，一旦发现有负面影响，还可以快速恢复。</p>
<blockquote>
<p>参考引用：</p>
<p>[1] 最左匹配原则：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ljl150/p/12934071.html">https://www.cnblogs.com/ljl150/p/12934071.html</a></p>
<p>[2] 深入浅出MySQL：数据库开发、管理和维护（第三版）</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/03/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">MySQL存储引擎</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-03 20:05:53" itemprop="dateCreated datePublished" datetime="2022-03-03T20:05:53+08:00">2022-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 10:17:44" itemprop="dateModified" datetime="2022-03-04T10:17:44+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="存储引擎概述"><a href="#存储引擎概述" class="headerlink" title="存储引擎概述"></a>存储引擎概述</h3><p><code>MySQL5.7</code>版本支持的存储引擎有<code>InnoDB</code>、<code>MyISAM</code>、<code>MEMORY</code>、<code>CSV</code>、<code>BLACKHOLE</code>、<code>ARCHIVE</code>、<code>MERGE</code>、<code>FEDERATED</code>、<code>EXAMPLE</code>、<code>NDB</code>等。其中<code>InnoDB</code>和<code>NBDB</code>提供事务安全表，其他都是非事务安全表。</p>
<p>由于常见的存储引擎为<code>InnoDB</code>和<code>MyISAM</code>，所以本篇博客只讨论这两种存储引擎。</p>
<p>其实在此之前，我一直认为存储引擎是基于整个数据库而言的，比如说一个数据库只能设定成一种存储引擎，其实不是的。<strong>存储引擎是基于表级别的。</strong></p>
<p>在创建新表的时候，可以使用关键字<code>ENGINE</code>来设置新建表的存储引擎，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table A(</span><br><span class="line">	...</span><br><span class="line">)ENGINE=MyISAM</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table B(</span><br><span class="line">	...</span><br><span class="line">)ENGINE=InnoDB</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>修改表的存储引擎需要锁表并复制数据，对于线上环境的表进行这个操作非常危险，除非你非常了解可能造成的影响</strong>。</p>
</blockquote>
<h3 id="各类存储引擎的特性"><a href="#各类存储引擎的特性" class="headerlink" title="各类存储引擎的特性"></a>各类存储引擎的特性</h3><table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">MyISAM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B树索引</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">备份/时间点恢复</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持集群</td>
<td align="center">——</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">聚簇索引</td>
<td align="center">——</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">数据压缩</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">数据缓存</td>
<td align="center">——</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">数据加密</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持外键</td>
<td align="center">——</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">地理坐标数据类型</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">地理坐标索引</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">哈希索引</td>
<td align="center">——</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">索引缓存</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">锁粒度</td>
<td align="center">表级</td>
<td align="center">行级</td>
</tr>
<tr>
<td align="center">MVCC多版本控制</td>
<td align="center">——</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">支持复制</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">存储限制</td>
<td align="center">256TB</td>
<td align="center">64TB</td>
</tr>
<tr>
<td align="center">T树索引</td>
<td align="center">——</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">支持事务</td>
<td align="center">——</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">统计信息</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<blockquote>
<p>聚簇索引：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903972843552781">https://juejin.cn/post/6844903972843552781</a></p>
</blockquote>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p><code>MyISAM</code>在某些场景中相对<code>InnoDB</code>的访问速度有明显优势，对事务完整性没有要求或以<code>Select</code>、<code>Insert</code>为主的应用可以使用这个引擎来创建表。</p>
<p><code>MyISAM</code>的表支持三种不同的存储格式：静态表、动态表、压缩表。</p>
<h5 id="静态表："><a href="#静态表：" class="headerlink" title="静态表："></a>静态表：</h5><p>静态表是默认存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。</p>
<p>静态表的数据在存储时会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经丢掉。在保存数据的时候，如果某个要保存的内容前后后空格，那么在返回结果的时候会被去掉。</p>
<h5 id="动态表："><a href="#动态表：" class="headerlink" title="动态表："></a>动态表：</h5><p>动态表包含变长字段，记录不固定长度，这样存储的有点是占用空间相对较少，但是频繁地更新和删除记录会产生碎片，需要定期执行<code>OPTIMIZE TABLE</code>或<code>myisamchk-r</code>命令来改善性能，并且在出现故障时恢复相对比较困难。</p>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>该引擎具有提交、回滚和崩溃恢复能力地事务安全保障，同时提供了更小的锁粒度和更强地并发能力，拥有自己独立的缓存和日志，在<code>MySQL5.6</code>和<code>5.7</code>版本中性能有较大的提升。</p>
<p>相对<code>MyISAM</code>而言，<code>InnoDB</code>会占用更多的磁盘空间以保存数据和索引。但是在大多数情况下，<code>InnoDB</code>都是更好的选择。</p>
<h5 id="自动增长列"><a href="#自动增长列" class="headerlink" title="自动增长列"></a>自动增长列</h5><p><code>InnoDB</code>表的自动增长可以手工插入，但是如果插入的值为空，则实际插入的将是自动增长后的值。另外对于自动增长的值可以手动设置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter TABLE *** AUTO_INCREMENT=N</span><br></pre></td></tr></table></figure>

<p>在<code>MySQL8.0</code>之前，对于<code>InnoDB</code>引擎，这个值存在内存中，那么在数据库重启后，这个值便会丢失，数据库会自动将这个值重置为自增列当前存储最大值+1，可能会引起数据冲突。但是在<code>MySQL8.0</code>中这个Bug得到了修复，实现方式是将自增主键的计数器持久化到<code>REDO LOG</code>中，每次计数器发生改变，都会将其写入<code>REDO LOG</code>，重启后则会根据其中的信息来初始化其内存值。</p>
<p>对于<code>InnoDB</code>表，自动增长的列必须被索引。如果是组合索引，也必须是组合索引的第一列。但是对于<code>MyISAM</code>表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。</p>
<h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><p><code>MySQL</code>支持外键的只有<code>InnoDB</code>存储引擎，在创建外键时，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。</p>
<p>当某个表被其他表创建了外键参照，那么该表的对应索引或者主键禁止被删除。</p>
<blockquote>
<p>外键需要注意的细节较多，一旦使用不当，可能会带来性能下降或者数据不一致问题，需要慎用。</p>
</blockquote>
<h5 id="主键和索引"><a href="#主键和索引" class="headerlink" title="主键和索引"></a>主键和索引</h5><p>不同于其他存储引擎，<code>InnoDB</code>存储引擎的数据文件本身就是以聚簇索引的形式保存的，这个聚簇索引也被称为主索引，也是<code>InnoDB</code>的主键，<code>InnoDB</code>表的每行数据都保存在主索引的叶子节点上。因此，所有的<code>InnoDB</code>表都必须包含主键，若创建表的时候没有显示指定主键，那么<code>InnoDB</code>会自动创建一个长度为6个字节的<code>long</code>类型隐藏字段作为主键。</p>
<p>考虑到聚簇索引的特点和对于查询的优化效果，所有的<code>InnoDB</code>表都应该显示指定主键，一般来说，主键应该按照以下原则来选择：</p>
<ul>
<li>满足唯一和非空约束</li>
<li>优先考虑使用最经常被当作查询条件的字段或者自增字段</li>
<li>字段值基本不会被修改</li>
<li>使用尽可能短的字段</li>
</ul>
<p>在<code>InnoDB</code>表上，除了主键之外的其他索引都叫<code>二级索引</code>或<code>辅助索引</code>，二级索引会指向主索引，并通过主索引获取最终数据。因此，主键是否合理的创建，会对所有索引的效率产生影响。</p>
<h4 id="如何选择存储引擎"><a href="#如何选择存储引擎" class="headerlink" title="如何选择存储引擎"></a>如何选择存储引擎</h4><p><code>MyISAM</code>：如果应用是以读操作和插入操作为主，只有极少的更新和删除操作，并且对事务完整性没有要求、没有并发写操作，那么选择这个存储引擎是合适的。</p>
<p><code>InnoDB</code>: 对于大部分应用程序，都是更好的选择。它能有效地降低由于删除和更新导致的锁定，还可以保证事务完整提交和回滚。</p>
<blockquote>
<p><code>MyISAM</code>读和插入更优的原因：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39631572/article/details/110861044">https://blog.csdn.net/weixin_39631572/article/details/110861044</a></p>
<p><a target="_blank" rel="noopener" href="https://www.xttblog.com/?p=3859">https://www.xttblog.com/?p=3859</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/02/23/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/23/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Java设计模式--单例模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-23 21:20:23 / 修改时间：21:35:33" itemprop="dateCreated datePublished" datetime="2022-02-23T21:20:23+08:00">2022-02-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/23/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/23/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>写在前面：<strong>线程安全</strong>就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。      </p>
<p><strong>线程不安全</strong>就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p>
</blockquote>
<p>单例模式有八种方式，其中完美无缺的有两种。</p>
<p>但是实际工作中不一定用的是完美无缺的。</p>
<h4 id="第一种：饿汉式"><a href="#第一种：饿汉式" class="headerlink" title="第一种：饿汉式"></a>第一种：饿汉式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Mg01 &#123;</span><br><span class="line">    public static final Mg01 INSTANCE = new Mg01();</span><br><span class="line"></span><br><span class="line">    private Mg01() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    public Mg01 getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类加载到内存后,就实例化一个单例,JVM保证线程安全简单实用,推荐实用!</p>
<p>唯一缺点:不管用到与否,类装载时就完成实例化(话说你不用的,你装载它干啥)</p>
<blockquote>
<p>这样写，由于Mgr01被private修饰，故不能够再new一个新的Mgr01，如果要一个新的，只能够调用getInstance方法，注意看getInstance，return的是一个INSTANCE，就是上面被final修饰的实例化的对象名，意思就是无论你调用多少次，返回的都是被final修饰的那个对象</p>
</blockquote>
<h4 id="第二种：懒汉式"><a href="#第二种：懒汉式" class="headerlink" title="第二种：懒汉式"></a>第二种：懒汉式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Mg02 &#123;</span><br><span class="line">    public static Mg02 INSTANCE = new Mg02();</span><br><span class="line"></span><br><span class="line">    private Mg02() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public Mg02 getInstance()&#123;</span><br><span class="line">        if (INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new  Mg02();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先声明但是没有初始化，在getInstance方法里面，先判断是否存在该实例对象，如果不存在，则创建，存在则返回该实例，从而保证单例。</p>
<p>这里定义时不能加final，因为用final修饰就必须初始化</p>
<p>但是会有线程不安全的问题，可能两个线程在没到return前创建了两个实例，此时两个是不同的实例，那么就无法保证是单例的了。</p>
<h4 id="第四种：用锁（效率下降）"><a href="#第四种：用锁（效率下降）" class="headerlink" title="第四种：用锁（效率下降）"></a>第四种：用锁（效率下降）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Mg03 &#123;</span><br><span class="line">    public static Mg03 INSTANCE = new Mg03();</span><br><span class="line"></span><br><span class="line">    private Mg03() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized Mg03 getInstance()&#123;</span><br><span class="line">        if (INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new  Mg02();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="第五种：静态内部类"><a href="#第五种：静态内部类" class="headerlink" title="第五种：静态内部类"></a>第五种：静态内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Mg03 &#123;</span><br><span class="line">    private static class Mg03Holder &#123;</span><br><span class="line">        public static final Mg03 INSTANCE = new Mg03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Mg03() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public Mg03 getInstance()&#123;</span><br><span class="line">        return Mg03Holder.INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个线程安全是由<code>jvm</code>保证的，<code>jvm</code>加载类的时候只加载一次，所以<code>Mg03Holder</code>和<code>getInstance</code>也只加载一次，从而保证线程安全。</p>
<h4 id="第六种：枚举（完美写法）"><a href="#第六种：枚举（完美写法）" class="headerlink" title="第六种：枚举（完美写法）"></a>第六种：枚举（完美写法）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Mg04 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法无法被反序列化的原因：java的反射可以通过一个class文件把整个class加载到内存，再通过反序列化new一个新的类。实际中想阻挡这种写法需要设置内部变量，很复杂。</p>
<p>而枚举单例无法被反序列化，因为枚举类没有构造方法，所以拿到class文件也无法构造对象。如上图中反序列化之后返回的值是INSTANCE,如果根据这个值创建对象的话，那么这个对象和我们单例里创建的是同一个对象，所以严格讲这个是最完美的方法。</p>
<p><strong>综合来看，一般都用第一种就行</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">数据库锁的基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-22 20:45:02 / 修改时间：20:47:13" itemprop="dateCreated datePublished" datetime="2022-02-22T20:45:02+08:00">2022-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="数据库系统的锁的基本原理"><a href="#数据库系统的锁的基本原理" class="headerlink" title="数据库系统的锁的基本原理"></a>数据库系统的锁的基本原理</h3><p>锁的基本原理如下：</p>
<ol>
<li>当一个事务访问某种数据库资源时，如果执行select语句，必须先获得的共享锁；如果执行insert，update或delete语句，必须获得独占锁。这些锁用于锁定被操纵的资源。</li>
<li>当第二个事务也要访问某种相同资源时，如果执行select语句，也必须获得的共享锁；如果执行insert，update或delete语句，必须获得独占锁。此时根据已经放置在资源上的锁的类型，来决定第二个事务到底是应该等待第一个事务解除对资源的锁定，还是可以立刻获得锁。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">资源上已经放置的锁</th>
<th align="center">第二个事务进行读操作</th>
<th align="center">第二个事务进行更新操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无</td>
<td align="center">立即获得共享锁</td>
<td align="center">立即获得独占锁</td>
</tr>
<tr>
<td align="center">共享锁</td>
<td align="center">立即获得共享锁</td>
<td align="center">等待第一个事务解除共享锁</td>
</tr>
<tr>
<td align="center">独占锁</td>
<td align="center">等待第一个事务接触独占锁</td>
<td align="center">等待第一个事务解除独占锁</td>
</tr>
</tbody></table>
<p>许多数据库系统都有自动管理锁的功能，它们能根据事务执行的SQL语句,自动在保证事务间的隔离性与保证事务间的并发性能之间做出权衡，然后自动为数据库资源加上当的锁在运行期间还会自动升级锁的类型,以优化系统的性能。多个事务的并发性能是指数据库系统能够同时执行多个事务的能力，很少出现因为一个事务占用了特定资源，而导到其他事务必须暂停下来长时间等待资源的情况。</p>
<p>对于普通的并发性事务,通过数据库系统的自动锁定管理机制基本可以保证事务之间</p>
<h4 id="锁的多粒度性及自动锁升级"><a href="#锁的多粒度性及自动锁升级" class="headerlink" title="锁的多粒度性及自动锁升级"></a>锁的多粒度性及自动锁升级</h4><p>数据库系统能够锁定的资源包括数据库、表、区域、页面、键值(指带有索引的行数据)和行(即表中的单行数据)。按照锁定资源的粒度,锁可以分为以下类型。</p>
<ol>
<li>数据库级锁:锁定整个数据库。</li>
<li>表级锁:锁定一张数据库表。</li>
<li>区域级锁:锁定数据库的特定区域。</li>
<li>页面级锁:锁定数据库的特定页面。</li>
<li>键值级锁:锁定数据库表中带有索引的一行数据。</li>
<li>行级锁:锁定数据库表中的单行数据(即一条记录)。</li>
</ol>
<p>锁的封锁粒度越大,事务间的隔离性就越高，但是事务间的并发性能就越低。数据库系统根据事务执行的SQL语句，自动对访问的数据资源加上合适的锁。假设某事务只操纵一个表中的部分行数据,系统可能只会添加几个行锁或页面锁，这样可以尽可能多地支持多个事务的并发操作。</p>
<p>但是,如果某个事务频繁地对某个表中的多条记录进行操作，将对该表的许多记录行都加上行级锁,数据库系统中锁的数目会急剧增加，这就加重了系统负荷，影响系统性能。因此,在数据库系统中,一般都支持锁升级。锁升级是指调整锁的粒度，将多个低粒度的锁替换成少数更高粒度的锁,以此来降低系统负荷。例如,当一个事务中的锁较多,达到锁升级门限时,系统自动将行级锁和页面级锁升级为表级锁。</p>
<h4 id="锁的类型和兼容性"><a href="#锁的类型和兼容性" class="headerlink" title="锁的类型和兼容性"></a>锁的类型和兼容性</h4><h5 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a><strong>共享锁</strong></h5><p>共享锁用于读数据操作，它是非独占的，允许其他事务同时读取其锁定的资源，但不允许其他事务更新它。共享锁具有以下特征：</p>
<ul>
<li>加锁的条件：当一个事务执行select语句时，数据库系统会为这个事务分配一把共享锁，来锁定被查询的数据。</li>
<li>解锁的条件：在默认情况下，数据被读取后，数据库系统会立即接触共享锁。例如，当一个事务执行查询语句（select * from account）时，数据库系统会先锁定第一行，读取之后，解除对第一行的锁定，然后锁定第二行。这样，在一个事务读操作过程中，允许其他食物同时更新account表中未被锁定的行。</li>
<li>与其他锁的兼容性：如果数据资源上放置了共享锁，还能再放置共享锁和更新锁。</li>
<li>并发性能：共享锁具有良好的并发性能。当多个事务读相同的数据时，每个事务都会获得一把共享锁，因此可以同时读锁定的数据。</li>
</ul>
<h5 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a><strong>独占锁</strong></h5><p>也称为排他锁，适用于修改数据的场合。它锁定的资源，其他事务不能读取和修改。独占锁具有以下特征：</p>
<ul>
<li>加锁的条件：当一个事务执行insert，update或delete语句时，数据库系统会自动对SQL语句操纵的数据资源使用独占锁。如果该数据资源已经有其他锁存在时，无法对其再放置独占锁。</li>
<li>解锁的条件：独占锁一直到事务结束才能被解除。</li>
<li>兼容性：独占锁不能和其他锁兼容，如果数据资源上已经加了独占锁，就不能再放置其他锁。同样，如果数据资源上已经有了其他锁，也不能再放置独占锁。</li>
<li>并发性能：独占锁的并发性能比较差，只允许有一个事务访问锁定的数据，如果有其他事物也需要访问该数据，就必须等待，直到前一个事务结束，解除了独占锁，其他事务才有机会访问该数据。</li>
</ul>
<h5 id="更新锁"><a href="#更新锁" class="headerlink" title="更新锁"></a><strong>更新锁</strong></h5><p>在更新操作的初始化阶段用来锁定可能要被修改的资源，这可以避免使用共享锁造成的死锁现象。例如对于以下的语句：</p>
<p>update account set balance = 90 where id = 1;</p>
<p>如果使用共享锁，更新操作分为两步：</p>
<ol>
<li>获得一个共享锁，读取 <code>account</code> 表中id为1的记录；</li>
<li>将共享锁升级为独占锁，再执行更新操作。</li>
</ol>
<p><strong>如果同时有两个或多个事务同时更新数据，每个事务都先获得一把共享锁,在更新数据的时候，这些事务都要先将共享锁升级为独占锁。由于独占锁不能与其他锁兼容,因此每事务都进入等待状态,等待其他事务释放共享锁,这就造成了死锁。</strong></p>
<p>如果使用更新锁,更新数据的操作分为以下两步：</p>
<ol>
<li>获得一个更新锁,读取 ACCOUNTS表中ID为1的记录。</li>
<li>将更新锁升级为独占锁,再执行更新操作。</li>
</ol>
<p>更新锁具有以下特征：</p>
<ul>
<li>加锁的条件：当一个事务执行update语句时，数据库系统会先为事务分配一把新锁。</li>
<li>解锁的条件：当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁，</li>
<li><strong>与其他锁的兼容性：更新锁与共享锁是兼容的，也就是说，一个资源可以同时放更新锁和共享锁，但是最多只能放置一把更新锁。这样，当多个事务更新相同的数据时有一个事务能获得更新锁，然后再把更新锁升级为独占锁,其他事务必须等到前一个事务结束后,才能获得更新锁,这就避免了死锁。</strong></li>
<li>并发性能：允许多个事务同时读锁定的资源,但不允许其他事务修改它。</li>
</ul>
<h4 id="死锁及其防治办法"><a href="#死锁及其防治办法" class="headerlink" title="死锁及其防治办法"></a>死锁及其防治办法</h4><p>多数据库系统能够自动定期搜索和处理死锁问题。当检测到锁定请求环时,系统将结束死锁优先级最低的事务,并且撤销该事务。</p>
<p>理解了死锁的概念,在应用程序中可以采用下面的一些方法来尽量避免死锁。</p>
<ol>
<li>合理安排对数据库表的访问顺序。</li>
<li>使用短事务。</li>
<li>如果对数据的一致性要求不是很高，可以允许脏读。脏读不需要对数据资源加锁，可以避免锁冲突。</li>
<li>如果可能的话,错开多个事务访问相同数据资源的时间,以防止锁冲突。</li>
<li>使用尽可能低的事务隔离级别。隔离级别过高，虽然系统可以因此提供更好的隔离性而更大程度上保证数据的完整性和一致性，但各事务间死锁的机会大大增加,反而影响了系统性能。</li>
</ol>
<p>短事务是指在一个数据库事务中包含尽可能少的操作，并且在尽可能短的时间内完成事务不仅能避免死锁，而且能提高事务间的并发性能。因为如果一个事务锁定了某种资源,由于这个事务很快就结束,因此不会长时间锁定资源,其他事务也就不需要长时间等待前一个事务解除对资源的锁定。</p>
<p>为了实现短事务,在应用程序中可以考虑使用以下策略。</p>
<ol>
<li>如果可能的话,尝试把大的事务分解为多个小的事务,然后分别执行。这可以保证每个小事务都很快完成,不会对数据资源锁定很长时间。</li>
<li>应该在处理事务前就准备好用户必须提供的数据,不应该在执行事务过程中,停下来长时间等待用户输入。以取款事务为例,应该在开始取款事务之前,就明确客户的取款数额,这使得取款事务不用中途停下来等待用户输入。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Huang Rui"
      src="/images/me.jpg">
  <p class="site-author-name" itemprop="name">Huang Rui</p>
  <div class="site-description" itemprop="description">国家地板级演员 GitHub顶级粉丝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/18770171448" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;18770171448" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huang Rui</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">123k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:52</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'ug4QbCcxhey1T327h47wyvvV-gzGzoHsz',
      appKey     : 'lWaydRUD874OBFVlx1cw26gj',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
