<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>realhuang</title>
    <link>http://hznu.asia/</link>
    
    <atom:link href="http://hznu.asia/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>国家地板级演员 GitHub顶级粉丝</description>
    <pubDate>Tue, 14 Feb 2023 03:03:34 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>JVM</title>
      <link>http://hznu.asia/2023/02/14/JVM/</link>
      <guid>http://hznu.asia/2023/02/14/JVM/</guid>
      <pubDate>Tue, 14 Feb 2023 02:56:38 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-什么是JVM？&quot;&gt;&lt;a href=&quot;#1-什么是JVM？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是JVM？&quot;&gt;&lt;/a&gt;1. 什么是JVM？&lt;/h3&gt;&lt;p&gt;JVM是指Java虚拟机，在JVM上可以运行Java编译后的字节码文件，也正是因</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-什么是JVM？"><a href="#1-什么是JVM？" class="headerlink" title="1. 什么是JVM？"></a>1. 什么是JVM？</h3><p>JVM是指Java虚拟机，在JVM上可以运行Java编译后的字节码文件，也正是因为JVM使得Java具有跨平台性。</p><h3 id="2-简单介绍下JVM的内存区域？"><a href="#2-简单介绍下JVM的内存区域？" class="headerlink" title="2. 简单介绍下JVM的内存区域？"></a>2. 简单介绍下JVM的内存区域？</h3><p>JVM内存区域有堆、栈、本地方法栈、虚拟机栈和程序计数器。</p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-3.png" alt="Java虚拟机运行时数据区" style="zoom:67%;"><p>其中方法区和堆是线程共享的。</p><p><strong>虚拟机栈：</strong>每个线程都有其自己的虚拟机栈，是其私有的，方法执行时，栈帧会存储其局部变量、操作数栈和动态链接。</p><p><strong>本地方法栈：</strong>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p><strong>程序计数器：</strong>也被称为 PC 寄存器，是一块较小的内存空间。它可以看作是当前线程所执行的字节码的行号指示器。</p><p><strong>Java堆：</strong>Java堆一般都是最大的区域，里面还细分了很多区域，一般垃圾回收都在堆内进行，并且几乎所有的对象创建也在堆上。</p><p><strong>方法区：</strong>方法区是比较特别的一块区域，和堆类似，它也是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>它特别在 Java 虚拟机规范对它的约束非常宽松，所以方法区的具体实现历经了许多变迁，例如 jdk1.7 之前使用永久代作为方法区的实现。</p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-4.png" alt="Java虚拟机栈" style="zoom: 67%;"><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-5.png" alt="Java 堆内存结构" style="zoom:67%;"><h3 id="3-说一下-JDK1-6、1-7、1-8-内存区域的变化？"><a href="#3-说一下-JDK1-6、1-7、1-8-内存区域的变化？" class="headerlink" title="3. 说一下 JDK1.6、1.7、1.8 内存区域的变化？"></a>3. 说一下 JDK1.6、1.7、1.8 内存区域的变化？</h3><p>JDK1.6时使用永久代作为方法区：</p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-6.png" alt="JDK 1.6内存区域" style="zoom:67%;"><p>JDK1.7时将字符串常量池、静态变量，存放在堆上：</p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-7.png" alt="JDK 1.7内存区域" style="zoom:67%;"><p>在 JDK1.8 时彻底干掉了永久代，而在直接内存中划出一块区域作为<strong>元空间</strong>，运行时常量池、类常量池都移动到元空间：</p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-8.png" alt="JDK 1.8内存区域" style="zoom:67%;"><h3 id="4-运行时常量池、类常量池和字符串常量池分别是什么？"><a href="#4-运行时常量池、类常量池和字符串常量池分别是什么？" class="headerlink" title="4. 运行时常量池、类常量池和字符串常量池分别是什么？"></a>4. 运行时常量池、类常量池和字符串常量池分别是什么？</h3><p>运行时常量池（Runtime Constant Pool）是 Java 虚拟机内存中的一块区域，它存储着在类文件的常量池（Class Constant Pool）中的所有常量，并且在运行时期间可以在程序中被引用到。运行时常量池中存储的内容包括了字符串常量、整型常量、浮点型常量等类型。</p><p>类常量池（Class Constant Pool）是在编译期间预先在 class 文件中创建的一个常量池，它存储着类的相关信息，如类名、方法名、字符串常量、整型常量等。</p><p>字符串常量池（String Constant Pool）是一个特殊的常量池，它存储着字符串常量，并且使用字符串常量池可以节省内存，因为所有的字符串常量在内存中只有一份拷贝，避免了创建多份字符串常量对象所带来的内存浪费。</p><h3 id="5-为什么用元空间代替永久代？"><a href="#5-为什么用元空间代替永久代？" class="headerlink" title="5. 为什么用元空间代替永久代？"></a>5. 为什么用元空间代替永久代？</h3><p>有主观和客观两方面的原因。</p><ul><li>主观上，使用永久代容易产生内存溢出等问题。</li><li>客观上，在 Oracle 收购 BEA 获得了 JRockit 的所有权后，为了和JRockit 虚拟机更好兼容，综合考虑替换了。</li></ul><h3 id="6-对象的加载过程？"><a href="#6-对象的加载过程？" class="headerlink" title="6. 对象的加载过程？"></a>6. 对象的加载过程？</h3><p>容易和类的加载过程混淆。</p><ol><li>首先查看类是否加载、解析或初始化过。如果没有，则先执行类的加载过程。</li><li>类检查完成后，JVM将为新的对象分配内存。</li><li>内存分配完成后，JVM将分配到的内存空间初始化为0</li><li>接下来初始化对象头，里面包含了该对象时哪个类的实例、如何找到元数据链接、对象的哈希码以及对象的GC分代年龄等信息。</li></ol><h3 id="7-类的加载过程"><a href="#7-类的加载过程" class="headerlink" title="7. 类的加载过程"></a>7. 类的加载过程</h3><ol><li>加载。将类通过类加载器从硬盘里的.class文件加载到内存中</li><li>链接。链接包括三个步骤。<ul><li>验证：验证语法是否正确</li><li>准备：为类变量（静态变量）分配内存，并将其初始化为默认值</li><li>解析：此时将符号引用转换为直接引用，符号引用是一种指向类或方法的引用，而直接引用是指向实际内存位置的引用。</li></ul></li><li>初始化：为类变量分配内存，并为其赋值，如果没有赋值则为其默认值。</li></ol><h3 id="8-什么是指针碰撞？什么是空闲列表？"><a href="#8-什么是指针碰撞？什么是空闲列表？" class="headerlink" title="8. 什么是指针碰撞？什么是空闲列表？"></a>8. 什么是指针碰撞？什么是空闲列表？</h3><p>指针碰撞和空闲列表都是分配内存的方式。</p><ul><li><strong>指针碰撞：</strong>在内存中有一个指针，指针两侧分别是已分配区域和未分配区域，当有新的对象要分配时，指针向未分配区域移动相应距离。</li><li><strong>空闲列表：</strong>内存中已分配区域和未分配区域是不规整的，由一个表来记录每块区域的相关信息，在需要分配时根据记录表查找合适的区域进行分配，分配完成后再更新记录表。</li></ul><p>两种方式的选择由Java堆是否规整决定，而Java堆是否规整由选择的垃圾回收器是否具有压缩整理能力决定。</p><h3 id="9-JVM-里-new-对象时，堆会发生抢占吗？JVM-是怎么设计来保证线程安全的？"><a href="#9-JVM-里-new-对象时，堆会发生抢占吗？JVM-是怎么设计来保证线程安全的？" class="headerlink" title="9. JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？"></a>9. JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？</h3><p>会发生抢占，假如内存正在给一个对象分配时，指针移动需要修改还没来得及移动，此时另一个线程进来，也需要分配内存，这样就会产生冲突，此时有两个解决办法：</p><ul><li>采用CAS算法保证原子性。</li><li>事先为每个线程分配一小段缓存区域（本地线程缓冲区），当有新的线程进来时，先分配到缓冲区，如果缓冲区满了或者放不下，再锁定内存区域同步分配内存区域。</li></ul><h3 id="10-对象的内存布局是怎样的？"><a href="#10-对象的内存布局是怎样的？" class="headerlink" title="10. 对象的内存布局是怎样的？"></a>10. 对象的内存布局是怎样的？</h3><p>对象主要有对象头、实例数据、对齐填充三部分。</p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/jvm-12.png" alt="对象的存储布局" style="zoom:67%;"><ul><li><strong>对象头：</strong><ul><li>类型指针：表示对象代表哪个类。</li></ul></li><li><strong>实例数据：</strong>用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。</li><li><strong>对齐填充：</strong>没有特别含义，相当于占位符。</li></ul><h3 id="11-内存溢出和内存泄漏是什么意思？"><a href="#11-内存溢出和内存泄漏是什么意思？" class="headerlink" title="11. 内存溢出和内存泄漏是什么意思？"></a>11. 内存溢出和内存泄漏是什么意思？</h3><p>内存泄漏指内存没有被正确释放，使内存被白白占用。</p><p>内存溢出指内存超出可用内存限制，而溢出。</p><h3 id="12-能手写内存溢出的例子吗？"><a href="#12-能手写内存溢出的例子吗？" class="headerlink" title="12. 能手写内存溢出的例子吗？"></a>12. 能手写内存溢出的例子吗？</h3><ul><li><strong>堆溢出：</strong>堆溢出只要不断创建不可被回收的静态变量、静态对象即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"> */</span><br><span class="line">public class HeapOOM &#123;</span><br><span class="line">    static class OOMObject &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            list.add(new OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>虚拟机栈溢出：</strong>虚拟机栈存储的是线程，所以不断创建线程早晚会溢出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * vm参数：-Xss2M</span><br><span class="line"> */</span><br><span class="line">public class JavaVMStackOOM &#123;</span><br><span class="line">    private void dontStop() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void stackLeakByThread() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">        JavaVMStackOOM oom = new JavaVMStackOOM();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-内存泄漏可能由哪些原因造成？"><a href="#13-内存泄漏可能由哪些原因造成？" class="headerlink" title="*13. 内存泄漏可能由哪些原因造成？"></a>*13. 内存泄漏可能由哪些原因造成？</h3><ul><li><strong>静态集合类：</strong>静态集合类生命周期和JVM一样，所以一直不会被释放</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class OOM &#123;</span><br><span class="line"> static List list = new ArrayList();</span><br><span class="line"> public void oomTests()&#123;</span><br><span class="line">   Object obj = new Object();</span><br><span class="line">   list.add(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>单例模式：</strong>和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。</li><li><strong>数据连接、IO、Socket 等连接：</strong>创建的连接不再使用时，需要调用 <strong>close</strong> 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Connection conn = null;</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    conn = DriverManager.getConnection(&quot;url&quot;, &quot;&quot;, &quot;&quot;);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    ResultSet rs = stmt.executeQuery(&quot;....&quot;);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;finally &#123;</span><br><span class="line">    //不关闭连接</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>变量不合理的作用域：</strong>一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Simple &#123;</span><br><span class="line">    Object object;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        object = new Object();</span><br><span class="line">        //...其他代码</span><br><span class="line">        //由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放</span><br><span class="line">        object = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在《Effective Java》第七条 消除过期的对象引用。在栈弹出操作时，如果是非Java这种没有垃圾回收机制的语言，如果不将其置为空等，就容易发生内存泄漏，因为栈内部还维护着对这些对象的过期引用。所谓过期引用，就是永远不会再被解除的引用。</p></blockquote><ul><li><strong>hash值改变：</strong>假如在HashMap中的某个值，hash改变后，用相同的key将找不到这个值，从而无法删除。<strong>这也是为什么 String 类型被设置成了不可变类型的原因。</strong></li></ul><blockquote><p>String在创建时是会缓存Hash值的，如果改变了就不是其本身了，所以设置成了不可变类型。</p></blockquote><ul><li><strong>ThreadLocal使用不当：</strong>ThreadLocal 的弱引用导致内存泄漏</li></ul>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/Java/">Java</category>
      
      
      <category domain="http://hznu.asia/tags/JVM/">JVM</category>
      
      
      <comments>http://hznu.asia/2023/02/14/JVM/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java并发编程</title>
      <link>http://hznu.asia/2022/11/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <guid>http://hznu.asia/2022/11/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      <pubDate>Mon, 14 Nov 2022 08:33:09 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-进程和线程有什么区别？&quot;&gt;&lt;a href=&quot;#1-进程和线程有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;1. 进程和线程有什么区别？&quot;&gt;&lt;/a&gt;1. 进程和线程有什么区别？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;进程是系统进行资源分配和调度的最小单</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-进程和线程有什么区别？"><a href="#1-进程和线程有什么区别？" class="headerlink" title="1. 进程和线程有什么区别？"></a>1. 进程和线程有什么区别？</h3><ul><li>进程是系统进行资源分配和调度的最小单位。</li><li>线程是CPU进行调度的最小单位，一个进程可以包含多个线程。</li></ul><p>比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。</p><h3 id="2-进程创建有哪些方式？"><a href="#2-进程创建有哪些方式？" class="headerlink" title="*2. 进程创建有哪些方式？"></a>*2. 进程创建有哪些方式？</h3><ul><li>继承Runnable接口，重写run()方法（推荐）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableTask implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Runnable!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RunnableTask task = new RunnableTask();</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承Thread类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static class MyThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;This is child thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的start()方法和主线程是交替执行的，通过调用Thread类的 start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到CPU时间片，就开始执行run()方法。</p></blockquote><p>上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，可以实现Callable接口</p><ul><li>实现Callable接口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class CallerTask implements Callable&lt;String&gt; &#123;</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;Hello,i am running!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FutureTask&lt;String&gt; task=new FutureTask&lt;String&gt;(new CallerTask());</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            String result=task.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-什么是CAS算法？"><a href="#3-什么是CAS算法？" class="headerlink" title="3. 什么是CAS算法？"></a>3. 什么是CAS算法？</h3><p>CAS（compare and swap，比较并且交换）算法是通过非阻塞方式避免多线程安全的一种方式，属于乐观锁相关的技术。</p><p>简单来说，它维护了三个变量，旧的预期值A、当前内存值V、即将更新的值B，通过while循环不断获取内存中的数值比较并更新。</p><p>同时，CAS也存在着一些问题：</p><ol><li>ABA问题。当且仅当内存值V等于旧的预期值A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。那么如果先将预期值A给成B，再改回A，那CAS操作就会误认为A的值从来没有被改变过，这时其他线程的CAS操作仍然能够成功，但是很明显是个漏洞，因为预期值A的值变化过了。</li></ol><blockquote><p>在Java并发包中，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性，即在变量前面添加版本号，每次变量更新的时候都把版本号+1，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p></blockquote><ol><li>CPU消耗过高的问题，while循环时间过长会极大消耗CPU的性能。</li></ol><blockquote><p>当某一方法比如：getAndAddInt()执行时，如果CAS失败，会一直进行尝试。如果CAS长时间尝试但是一直不成功，可能会给CPU带来很大的开销。</p></blockquote><ol start="3"><li>只能保证一个共享变量的原子操作。</li></ol><blockquote><p>当操作1个共享变量时，我们可以使用循环CAS的方式来保证原子操作，但是操作多个共享变量时，循环CAS就无法保证操作的原子性，这个时候就需要用锁来保证原子性。</p><p>在多线程环境中，其他线程可能在循环CAS进行更新操作之前修改了其他共享变量的值，从而导致循环CAS的更新操作失效。</p></blockquote><h3 id="4-Thread-sleep-0-会发生什么？"><a href="#4-Thread-sleep-0-会发生什么？" class="headerlink" title="4. Thread.sleep(0)会发生什么？"></a>4. Thread.sleep(0)会发生什么？</h3><p>首先，sleep()指定毫秒数后，是不一定会在指定的毫秒数后立即执行的，关键至于是否分配到了CPU时间片。</p><p>这里，就需要区分Windows和Unix操作系统了。Unix操作系统使用的是时间片算法，Windows操作系统使用的是抢占式算法。<strong>我们现在基于Unix操作系统来讨论。</strong></p><p>假如我们调用Thread.sleep(1000)，代表在未来1000毫秒内不参与时间片的竞争，但是在1000毫秒后，如果有优先级更高的线程，那么我们这个休眠了1000毫秒的线程依然不会执行。</p><p>而Thread.sleep(0)的作用看上去只是在0毫秒内不参与时间片的竞争，好像写不写没有什么区别，其实不是这样的。Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。<strong>这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。</strong></p><blockquote><p>所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。</p><p>但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。</p></blockquote><h3 id="5-线程有哪些常用的调度方法？"><a href="#5-线程有哪些常用的调度方法？" class="headerlink" title="5. 线程有哪些常用的调度方法？"></a>5. 线程有哪些常用的调度方法？</h3><p>等待：wait()、wait(long timeout)、join()</p><p>通知：notify()、notifyAll()</p><p>让出优先权：yield()</p><p>中断：interrupt()、interrupted()、isinterrupted()</p><p>休眠：sleep()</p><blockquote><p>假设有两个线程 <code>threadA</code> 和 <code>threadB</code>。如果从 <code>threadA</code> 调用 <code>threadB.join()</code>，<code>threadA</code> 将等待 <code>threadB</code> 完成后再继续执行。</p><p>如果调用 <code>join</code> 的线程在等待另一个线程完成时被中断，则 <code>join</code> 方法可能会引发 <code>InterruptedException</code>。</p></blockquote><blockquote><p>thread.yield()表示线程主动放弃CPU，它用于暂时暂停当前线程的执行，并允许其他线程运行。它会被移动到等待运行的线程队列的末尾，其他线程将有机会运行。</p><p>“thread.yield()”仅在多线程环境中有效，其行为是平台相关的。不能保证在线程调用”thread.yield()”后立即运行其他线程。实际行为可能取决于操作系统使用的调度程序和其他线程在队列中的优先级。</p></blockquote><blockquote><p>wait()：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回:</p><p>（1） 线程A调用了共享对象 notify()或者 notifyAll()方法；</p><p><strong>（2）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。</strong></p></blockquote><h3 id="6-线程有哪几种状态？"><a href="#6-线程有哪几种状态？" class="headerlink" title="*6. 线程有哪几种状态？"></a>*6. 线程有哪几种状态？</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态：线程被创建，但还没有调用start()方法</td></tr><tr><td>RUNNABLE</td><td>运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”</td></tr><tr><td>BLOCKED</td><td>阻塞状态：表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td>等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td>TIME_WAITING</td><td>超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的</td></tr><tr><td>TERMINATED</td><td>终止状态：表示当前线程已经执行完毕</td></tr></tbody></table><h3 id="7-什么是守护线程？"><a href="#7-什么是守护线程？" class="headerlink" title="7. 什么是守护线程？"></a>7. 什么是守护线程？</h3><p>线程一般分用户线程和守护线程。</p><p>在JVM启动时会调用main函数，main函数所在线程就是用户线程。但是在JVM内部其实还存在其他很多线程，比如垃圾回收线程。在JVM退出后，用户线程会退出，但是守护线程不一定。</p><h3 id="8-线程间有哪些通信方式？"><a href="#8-线程间有哪些通信方式？" class="headerlink" title="8. 线程间有哪些通信方式？"></a>8. 线程间有哪些通信方式？</h3><ol><li>全局变量：线程可以访问全局变量并对其进行读写操作。</li><li>管道（pipe）：管道是一种特殊的文件，它允许不相关进程间的数据交换。</li><li>信号量（semaphore）：信号量是一种控制多个线程同时访问共享资源的方法。</li><li>消息队列（message queue）：消息队列允许线程通过发送和接收消息来通信。</li><li>共享内存（shared memory）：共享内存是一段可供多个线程访问的内存。</li><li>互斥量（mutex）：互斥量是一种同步机制，用于防止多个线程同时对共享资源进行访问。</li><li>条件变量（condition variable）：条件变量是一种同步机制，用于控制线程的执行顺序。</li></ol><p>这些通信方式在不同的操作系统和编程语言中可能会有所差异，请以具体环境为准。</p><p>在Java中方式如下：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-10.png" alt="线程间通信方式"></p><h3 id="9-什么是ThreadLocal？"><a href="#9-什么是ThreadLocal？" class="headerlink" title="9. 什么是ThreadLocal？"></a>9. 什么是ThreadLocal？</h3><p>ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-11.png" alt="ThreadLocal线程副本"></p><ul><li>创建</li></ul><p>创建了一个ThreadLocal变量localVariable，任何一个线程都能并发访问localVariable。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static ThreadLocal&lt;String&gt; localVariable = new ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>写入</li></ul><p>线程可以在任何地方使用localVariable，写入变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localVariable.set(&quot;鄙人三某”);</span><br></pre></td></tr></table></figure><ul><li>读取</li></ul><p>线程在任何地方读取的都是它写入的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localVariable.get();</span><br></pre></td></tr></table></figure><blockquote><p>如果修改了<code>ThreadLocal</code>的值，它将在本线程内生效。每个线程都有自己的<code>ThreadLocal</code>副本，并且每个线程只能修改它自己的副本。因此，当您修改了线程的<code>ThreadLocal</code>值时，不会影响其他线程中的<code>ThreadLocal</code>值。</p><p>例如，如果使用<code>ThreadLocal</code>来存储当前用户的名称，并在多个线程中处理请求，则每个线程都有自己的副本，存储了当前处理请求的用户的名称。如果某个线程修改了它的<code>ThreadLocal</code>值，则不会影响其他线程的<code>ThreadLocal</code>值。</p></blockquote><h3 id="10-使用ThreadLocal举例？"><a href="#10-使用ThreadLocal举例？" class="headerlink" title="10. 使用ThreadLocal举例？"></a>10. 使用ThreadLocal举例？</h3><p>可以用来做用户信息上下文的存储。</p><p>我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接口，都会在请求头中携带一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？</p><p>一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？</p><p>这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取出ThreadLocal中存的用户数据。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-12.png" alt="ThreadLoca存放用户上下文"></p><p>很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。</p><p>我们常用的数据库连接池也用到了ThreadLocal：</p><ul><li>数据库连接池的连接交给ThreadLocal进行管理，保证当前线程的操作都是同一个Connnection。</li></ul><blockquote><p>ThreadLocal 内存泄露是怎么回事？：<a href="https://tobebetterjavaer.com/sidebar/sanfene/javathread.html#_13-threadlocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B">https://tobebetterjavaer.com/sidebar/sanfene/javathread.html#_13-threadlocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B</a></p></blockquote><h3 id="11-Java中父子线程如何共享数据？"><a href="#11-Java中父子线程如何共享数据？" class="headerlink" title="11. Java中父子线程如何共享数据？"></a>11. Java中父子线程如何共享数据？</h3><p>父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？</p><p>这时候可以用到另外一个类——<code>InheritableThreadLocal </code>。</p><p>使用起来很简单，在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class InheritableThreadLocalTest &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final ThreadLocal threadLocal = new InheritableThreadLocal();</span><br><span class="line">        // 主线程</span><br><span class="line">        threadLocal.set(&quot;不擅技术&quot;);</span><br><span class="line">        //子线程</span><br><span class="line">        Thread t = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                System.out.println(&quot;鄙人三某 ，&quot; + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：在Thread类里还有另外一个变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span><br></pre></td></tr></table></figure><p>在Thread.init的时候，如果父线程的<code>inheritableThreadLocals</code>不为空，就把它赋给当前线程（子线程）的<code>inheritableThreadLocals </code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)</span><br><span class="line">    this.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure><h3 id="12-volatile关键字的作用？"><a href="#12-volatile关键字的作用？" class="headerlink" title="12. volatile关键字的作用？"></a>12. volatile关键字的作用？</h3><p>volatile有两个作用，保证<strong>可见性</strong>和<strong>有序性</strong>。</p><p><strong>可见性：</strong></p><p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。</p><p>关键字volatile可以用来修饰字段（成员变量），volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p><p>例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-26.png" alt="volatile内存可见性"></p><p><strong>有序性：</strong></p><p>重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。</p><h3 id="13-简单介绍下synchronized？"><a href="#13-简单介绍下synchronized？" class="headerlink" title="*13. 简单介绍下synchronized？"></a>*13. 简单介绍下synchronized？</h3><p>Synchronized是用来同步代码，使其在多线程环境下，保证原子性的。</p><p>Synchronized有三种用法，一种用于实例方法，一种用于静态代码块，一种用于静态方法。</p><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized void method() &#123;</span><br><span class="line">  //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>修饰静态方法</strong>：也就是给当前类加锁，会作用于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。</p><p>如果⼀个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调⽤这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized void staic method() &#123;</span><br><span class="line"> //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。 synchronized(类.class) 表示进⼊同步代码前要获得 当前 <strong>class</strong> 的锁</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(this) &#123;</span><br><span class="line"> //业务代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-Monitor是什么？"><a href="#14-Monitor是什么？" class="headerlink" title="14. Monitor是什么？"></a>14. Monitor是什么？</h3><p>Monitor是一种同步机制，在Java虚拟机（HotSpot）中，Monitor由ObjectMonitor实现的，可以叫内部锁或者Monitor锁。</p><h3 id="15-除了原子性，synchronized可见性，有序性，可重入性怎么实现？"><a href="#15-除了原子性，synchronized可见性，有序性，可重入性怎么实现？" class="headerlink" title="15. 除了原子性，synchronized可见性，有序性，可重入性怎么实现？"></a>15. 除了原子性，synchronized可见性，有序性，可重入性怎么实现？</h3><ul><li>可见性：</li></ul><p>在加锁前，将清空线程本地内存中共享变量的值，从而使用共享变量时需要从共享内存中读取。</p><p>synchronized的可见性是保证在一个线程访问共享内存时，不让其他线程同时访问，并且在线程修改完某个变量后，将修改后的值，同步刷回到共享内存。</p><ul><li>有序性：</li></ul><p>synchronized的有序性是保证在一条线程访问时，禁止另一条线程进入。因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是并不会禁止底层的指令重排。</p><ul><li>可重入性：</li></ul><p>synchronized的可重入性是指<strong>允许一个线程二次请求自己持有对象锁的临界资源</strong>，是通过其本身的一个计数器保证的。当一条线程获取到锁时，count计数器加1，线程执行完成后则减1，直到被清零释放锁。</p><h3 id="16-as-if-serial又是什么？单线程的程序一定是顺序的吗？"><a href="#16-as-if-serial又是什么？单线程的程序一定是顺序的吗？" class="headerlink" title="16. as-if-serial又是什么？单线程的程序一定是顺序的吗？"></a>16. as-if-serial又是什么？单线程的程序一定是顺序的吗？</h3><p>as-if-serial是指：不管底层指令如何重排序，程序的执行结果不能被改变。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。如果不存在数据依赖关系，则可能被重排序。看以下示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;   // A</span><br><span class="line">double r = 1.0;   // B </span><br><span class="line">double area = pi * r * r;   // C</span><br></pre></td></tr></table></figure><p>在上面的示例中，C依赖于A和B，但是A和B之前不存在依赖关系。因此，执行顺序可能是A-B-C或B-A-C。</p><h3 id="17-什么是指令重排？"><a href="#17-什么是指令重排？" class="headerlink" title="17. 什么是指令重排？"></a>17. 什么是指令重排？</h3><p>指令重排可以分三种情况：</p><ol><li>编译器优化的重排序：在语句执行时，如果不存在依赖关系，则可以进行重排序。</li><li>内存系统的重排序：由于处理器使用缓存和读/写缓冲区，使得加载和存储看上去是乱序执行。</li><li>指令并行的重排序：现代处理器采用指令并行技术，使得多条指令可以并行执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li></ol><h3 id="18-锁的状态有哪些？Synchronized锁是如何升级的？"><a href="#18-锁的状态有哪些？Synchronized锁是如何升级的？" class="headerlink" title="18. 锁的状态有哪些？Synchronized锁是如何升级的？"></a>18. 锁的状态有哪些？Synchronized锁是如何升级的？</h3><p>状态有无锁、偏向锁、轻量级锁、重量级锁。升级是从 无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。</p><blockquote><p>在JDK1.6以前Synchronized实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong>。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化。</p></blockquote><p>Java对象头里，有一块结构，叫<code>Mark Word</code>标记字段，这块结构会随着锁的状态变化而变化。</p><p>64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-34.png" alt="Mark Word变化"></p><h3 id="19-介绍一下各种锁状态？"><a href="#19-介绍一下各种锁状态？" class="headerlink" title="19. 介绍一下各种锁状态？"></a>19. 介绍一下各种锁状态？</h3><p><strong>偏向锁：</strong>偏向锁是在单线程环境下使用的，是防止CAS过度消耗资源。引入偏向锁是为了在多线程竞争的情况下尽量减少不必要的轻量级 锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令。（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所 以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。</p><blockquote><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线 程多次获得，因此有了偏向锁。</p></blockquote><p><strong>轻量级锁：</strong>它的本意是在没有多线程竞争的前提下，减少传统的重量 级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，<strong>轻量级锁所适应的场 景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀 为重量级锁。</strong></p><blockquote><p><strong>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进 一步提高性能。</strong></p></blockquote><p><strong>重量级锁：</strong>Synchronized依赖于对象内部的Monitor锁实现。但是这个Monitor锁本质是依赖于底层操作系统的Mutex Lock实现，而线程从用户态切换到内核态开销巨大，这就是为什么重量级锁耗费资源的原因。</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，而是自旋，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><h3 id="20-介绍一下锁的其他优化？"><a href="#20-介绍一下锁的其他优化？" class="headerlink" title="20. 介绍一下锁的其他优化？"></a>20. 介绍一下锁的其他优化？</h3><p><strong>适应性自旋：</strong>在轻量级锁获取不到CPU时，是会通过自旋不断获取的，然而这是比较耗费CPU的，因此做了相关优化。比如某一次自旋获取CPU成功了，那么下一次自旋次数便会增加；如果获取失败了，下一次便会减少。</p><p><strong>锁粗化：</strong>当连续几段代码有加锁、解锁操作时，将其合并在一起操作。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StringBufferTest &#123;</span><br><span class="line">    StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">    public void append()&#123;</span><br><span class="line">        stringBuffer.append(&quot;a&quot;);</span><br><span class="line">        stringBuffer.append(&quot;b&quot;);</span><br><span class="line">        stringBuffer.append(&quot;c&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p><p><strong>锁消除：</strong>锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。</p><h3 id="21-ConcurrentHashMap中的分段锁思想？"><a href="#21-ConcurrentHashMap中的分段锁思想？" class="headerlink" title="21. ConcurrentHashMap中的分段锁思想？"></a>21. ConcurrentHashMap中的分段锁思想？</h3><p>分段锁其实是一种思想，而ConcurrentHashMap则是这种思想的最佳实践。</p><p>与ConcurrentHashMap相似的有HashTable，但是因为效率低下而被弃用，其效率低下的主要原因就是众多线程竞争同一把锁。</p><p>而ConcurrentHashMap则允许容器中有多个锁，每把锁锁一部分数据，这样就提高了并发时的效率。<strong>首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong></p><p><img src="https://images2015.cnblogs.com/blog/554581/201703/554581-20170329093553826-1781572140.png" alt="img"></p><p>Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。</p><h3 id="22-什么是可重入锁？"><a href="#22-什么是可重入锁？" class="headerlink" title="22. 什么是可重入锁？"></a>22. 什么是可重入锁？</h3><p>可重入锁（Reentrant Lock）是一种常用的同步机制，允许同一线程多次获取锁。也就是说，如果一个线程已经获得了锁，它在释放该锁之前可以再次获取该锁。这是一种递归锁，用于保护复杂的代码块，其中一个线程可以在不释放锁的情况下进入该代码块多次。</p><p>可重入锁在多线程环境下非常有用，因为它允许线程在获得锁后再次请求锁而不会发生死锁，并且提高了代码的可读性和可维护性。</p><p>例如，在 Java 中，可重入锁通常实现为 java.util.concurrent.locks.ReentrantLock 类。</p><h3 id="23-说说Synchronized和ReentrantLock的区别？"><a href="#23-说说Synchronized和ReentrantLock的区别？" class="headerlink" title="*23. 说说Synchronized和ReentrantLock的区别？"></a>*23. 说说Synchronized和ReentrantLock的区别？</h3><ul><li><p><strong>锁的实现：</strong> synchronized是Java语言的关键字，基于JVM实现。而ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）</p></li><li><p><strong>性能：</strong> 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。</p></li><li><p>功能特点：</p><p>ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。</p><ul><li>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制</li><li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li><li>synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。</li><li>ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。</li></ul></li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-38.png" alt="synchronized和ReentrantLock的区别"></p><h3 id="24-什么是AQS？"><a href="#24-什么是AQS？" class="headerlink" title="24. 什么是AQS？"></a>24. 什么是AQS？</h3><p>AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。</p><blockquote><p>AQS内容较多，暂不过多关注。</p></blockquote><h3 id="25-简单介绍下ReentrantLock？"><a href="#25-简单介绍下ReentrantLock？" class="headerlink" title="25. 简单介绍下ReentrantLock？"></a>25. <strong>简单介绍下ReentrantLock</strong>？</h3><p>ReentrantLock是可重入独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。</p><p>举例看其加锁操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    private int counter = 0;</span><br><span class="line">    private ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    public void incrementCounter() &#123;</span><br><span class="line">        lock.lock(); // 加锁</span><br><span class="line">        try &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock(); // 释放锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getCounter() &#123;</span><br><span class="line">        return counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new ReentrantLock() </code>构造函数默认创建的是非公平锁 NonfairSync。</p><h3 id="26-Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？"><a href="#26-Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？" class="headerlink" title="26. Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？"></a>26. Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？</h3><ul><li>使用原子操作类，例如AtomicInteger，实现i++原子操作</li><li>使用juc包下的ReentrantLock()，对i++加锁</li><li>使用Synchronized，对i++加锁</li></ul><h3 id="27-原子操作类有哪些？"><a href="#27-原子操作类有哪些？" class="headerlink" title="27. 原子操作类有哪些？"></a>27. 原子操作类有哪些？</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-46.png" alt="原子操作类"></p><h3 id="28-AtomicInteger的原理？"><a href="#28-AtomicInteger的原理？" class="headerlink" title="28. AtomicInteger的原理？"></a>28. AtomicInteger的原理？</h3><p>原理就是基于CAS的。</p><h3 id="29-什么是线程死锁？如何避免？"><a href="#29-什么是线程死锁？如何避免？" class="headerlink" title="***29. 什么是线程死锁？如何避免？"></a>***29. 什么是线程死锁？如何避免？</h3><p>死锁是指两个线程同时竞争同一个资源，而造成相互等待的现象。</p><p>线程死锁的四个条件：互斥条件、请求与保持条件、不可剥夺条件、环路等待条件。</p><ul><li><strong>互斥条件：</strong>指一个线程对已经获取到的资源排他性使用，当一个线程持有当前资源时，直至其释放，其他线程只能等待。直到占有资源的线程释放资源。</li><li><strong>请求与保持条件：</strong>当一个线程持有一个资源时，又请求另一个资源，而另一个资源被占用，从而一直等待造成阻塞，当前线程也不释放资源。</li><li><strong>不可剥夺条件：</strong>当一个线程持有一个资源时，其他线程不可剥夺其资源，直到自身使用完成后自己释放。</li><li><strong>环路等待条件：</strong>一个线程集合中的线程，形成了环路等待。</li></ul><p>避免死锁需要<strong>至少</strong>破坏以上四个条件的其中一个：</p><ul><li>对于互斥条件，不可以破坏，因为加锁就是为了互斥。</li><li>对于请求与保持条件，可以通过一次性申请全部资源来破坏。</li><li>对于不可剥夺条件，在请求遇到阻塞时，可以通过释放自身的资源来破坏。</li><li>对于环路等待条件，可以通过给线程分配优先级，使其有顺序的执行来破坏。</li></ul><h3 id="30-CountDownLatch（倒计数器）了解吗？"><a href="#30-CountDownLatch（倒计数器）了解吗？" class="headerlink" title="30. CountDownLatch（倒计数器）了解吗？"></a>30. CountDownLatch（倒计数器）了解吗？</h3><p><strong>场景1：协调子线程结束动作：等待所有子线程运行结束</strong></p><p>例如，我们很多人喜欢玩的王者荣耀，得等所有人都点击确认之后，才能到选英雄阶段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    CountDownLatch countDownLatch = new CountDownLatch(5);</span><br><span class="line"></span><br><span class="line">    Thread 大乔 = new Thread(countDownLatch::countDown);</span><br><span class="line">    Thread 兰陵王 = new Thread(countDownLatch::countDown);</span><br><span class="line">    Thread 安其拉 = new Thread(countDownLatch::countDown);</span><br><span class="line">    Thread 哪吒 = new Thread(countDownLatch::countDown);</span><br><span class="line">    Thread 铠 = new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 稍等，上个卫生间，马上到...</span><br><span class="line">            Thread.sleep(1500);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125; catch (InterruptedException ignored) &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    大乔.start();</span><br><span class="line">    兰陵王.start();</span><br><span class="line">    安其拉.start();</span><br><span class="line">    哪吒.start();</span><br><span class="line">    铠.start();</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(&quot;所有玩家已经就位！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new CountDownLatch(5)</code>用户创建初始的latch数量，各玩家通过<code>countDownLatch.countDown()</code>完成状态确认，主线程通过<code>countDownLatch.await()</code>等待。</p><p><strong>场景2. 协调子线程开始动作：统一各线程动作开始的时机</strong></p><p>王者游戏中也有类似的场景，游戏开始时，各玩家的初始状态必须一致。不能有的玩家都出完装了，有的才降生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">    Thread 大乔 = new Thread(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 兰陵王 = new Thread(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 安其拉 = new Thread(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 哪吒 = new Thread(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 铠 = new Thread(() -&gt; waitToFight(countDownLatch));</span><br><span class="line"></span><br><span class="line">    大乔.start();</span><br><span class="line">    兰陵王.start();</span><br><span class="line">    安其拉.start();</span><br><span class="line">    哪吒.start();</span><br><span class="line">    铠.start();</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">    System.out.println(&quot;敌方还有5秒达到战场，全军出击！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void waitToFight(CountDownLatch countDownLatch) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        countDownLatch.await(); // 在此等待信号再继续</span><br><span class="line">        System.out.println(&quot;收到，发起进攻！&quot;);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个场景中，仍然用五个线程代表大乔、兰陵王、安其拉、哪吒和铠等五个玩家。需要注意的是，各玩家虽然都调用了<code>start()</code>线程，但是它们在运行时都在等待<code>countDownLatch</code>的信号，在信号未收到前，它们不会往下执行。</p><h3 id="31-什么是线程池？"><a href="#31-什么是线程池？" class="headerlink" title="31. 什么是线程池？"></a>31. 什么是线程池？</h3><p>线程池，简单说就是一个拥有很多线程的容器。合理使用线程池有三个好处：</p><ol><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程的可管理性</li></ol><h3 id="32-实际使用线程池的例子？"><a href="#32-实际使用线程池的例子？" class="headerlink" title="32. 实际使用线程池的例子？"></a>32. 实际使用线程池的例子？</h3><p>用户注册时，防止同一时刻用户注册量过大，使用了多线程。</p><h3 id="33-线程池的工作流程？"><a href="#33-线程池的工作流程？" class="headerlink" title="**33. 线程池的工作流程？"></a>**33. 线程池的工作流程？</h3><ol><li>当线程池创建时，是没有线程的，任务队列通过参数的形式传入。</li><li>当ThreadPoolExecutor调用 execute() 方法添加一个任务时，线程池会做如下判断：</li></ol><ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果队列满了，但是线程数小于最大线程数，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。</li></ul><ol start="3"><li>当一个线程完成任务后，它会从队列中取下一个任务来执行。</li><li>当一个线程闲置时，此时若线程数大于corePoolSize，那么这个线程则会被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li></ol><h3 id="34-线程池的主要参数有哪些？"><a href="#34-线程池的主要参数有哪些？" class="headerlink" title="34. 线程池的主要参数有哪些？"></a>34. 线程池的主要参数有哪些？</h3><ul><li><strong>corePoolSize：</strong>核心线程数。如果线程数小于核心线程数，那么新增一个任务便会创建一个新的线程来处理。如果线程数等于核心线程数，那么新增的任务会放到任务队列中。</li><li><strong>maximumSize：</strong>最大线程数。如果任务队列满了还有新的线程，并且线程总数小于最大线程数，那么会创建新的线程来处理任务。</li><li><strong>keepAliveTime：</strong>非核心线程存活时间。</li><li><strong>unit：</strong>非核心线程存活时间单位</li><li><strong>workQueue：</strong>工作队列。当核心线程满了，队列还没满的时候，任务会先进入队列中。</li><li><strong>threadFactory：</strong>创建线程使用的工厂</li><li><strong>handler：</strong>拒绝策略</li></ul><h3 id="35-线程池拒绝策略有哪些？"><a href="#35-线程池拒绝策略有哪些？" class="headerlink" title="*35. 线程池拒绝策略有哪些？"></a>*35. 线程池拒绝策略有哪些？</h3><ul><li><strong>AbortPolicy：直接抛出RejectedExecutionException异常。</strong></li><li><strong>CallerRunsPolicy：用调用者所在的线程来执行任务。</strong></li><li><strong>DiscardOldestPolicy：丢弃最老的任务</strong>。</li><li><strong>DiscardPolicy：直接丢弃任务。</strong></li></ul><p>下面是一个配置线程池拒绝策略的代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = new ThreadPoolExecutor(10,100,60,TimeUnit.SECONDS,</span><br><span class="line">    new ArrayBlockingQueue&lt;&gt;(200),</span><br><span class="line">    new ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure><p>如果要实现自己的拒绝策略，则可以实现<code>RejectedExecutionHandler</code>接口。</p><h3 id="36-线程池有哪几种工作队列？"><a href="#36-线程池有哪几种工作队列？" class="headerlink" title="36. 线程池有哪几种工作队列？"></a>36. 线程池有哪几种工作队列？</h3><ul><li><strong>ArrayBlockingQueue：</strong>是一个有界阻塞队列，按FIFO排序。</li><li><strong>LinkedBlockingQueue：</strong>是可以设置容量的链表结构的阻塞队列，按FIFO进行排序。如果不对容量进行设置，则是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。吞吐量高于ArrayBlockingQueue，newFixedThreadPool线程池使用的是该队列。</li><li><strong>DelayQueue：</strong>是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排列，否则根据插入的先后顺序排列。newScheduleThreadPool线程池使用了该队列。</li><li><strong>PriorityBlockingQueue：</strong>具有优先级的无阻塞队列。</li><li><strong>SynchronousQueue：</strong>是一个不存储元素的阻塞队列，当一个线程进行插入操作时，必须有另一个线程进行移除操作，否则该插入操作将被一直阻塞。newCacheThreadPool使用了该队列。</li></ul><h3 id="37-常见的线程池有哪些？"><a href="#37-常见的线程池有哪些？" class="headerlink" title="***37. 常见的线程池有哪些？"></a>***37. 常见的线程池有哪些？</h3><p>常见的线程池有以下四种：</p><ul><li>newFixedThreadPool：固定线程数目的线程池。</li><li>newSingleThreadPool：单线程的线程池。</li><li>newCacheThreadPool：可缓存的线程池。</li><li>newScheduleThreadPool：定时及周期执行的线程池。</li></ul><h3 id="38-四种线程池的原理和适用场景？"><a href="#38-四种线程池的原理和适用场景？" class="headerlink" title="**38. 四种线程池的原理和适用场景？"></a>**38. 四种线程池的原理和适用场景？</h3><h5 id="newSingleThreadExecutor："><a href="#newSingleThreadExecutor：" class="headerlink" title="newSingleThreadExecutor："></a>newSingleThreadExecutor：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>核心线程数为1</li><li>最大线程数也为1</li><li>阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM</li><li>keepAliveTime为0</li></ul><p><strong>工作流程：</strong></p><ul><li>提交任务</li><li>线程池中是否有一条线程</li><li>如果有，则进入阻塞队列，没有则执行，执行完再取下一个</li></ul><h5 id="newFixedThreadPool："><a href="#newFixedThreadPool：" class="headerlink" title="newFixedThreadPool："></a>newFixedThreadPool：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>核心线程数和最大线程数一样，自定义</li><li>阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM</li><li>keepAliveTime为0</li></ul><p><strong>工作流程：</strong></p><ul><li>提交任务</li><li>如果线程数少于核心线程，创建核心线程执行任务</li><li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li><li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li></ul><p><strong>使用场景</strong></p><p>FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p><h5 id="newScheduleThreadPool："><a href="#newScheduleThreadPool：" class="headerlink" title="newScheduleThreadPool："></a>newScheduleThreadPool：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>最大线程数为Integer.MAX_VALUE，也有OOM的风险</li><li>阻塞队列是DelayedWorkQueue</li><li>keepAliveTime为0</li><li>scheduleAtFixedRate() ：按某种速率周期执行</li><li>scheduleWithFixedDelay()：在某个延迟后执行</li></ul><p><strong>工作机制</strong></p><ul><li>线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。</li><li>线程执行这个ScheduledFutureTask。</li><li>线程修改ScheduledFutureTask的time变量为下次将要被执行的时间。</li><li>线程把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add()）。</li></ul><h5 id="newCacheThreadPool："><a href="#newCacheThreadPool：" class="headerlink" title="newCacheThreadPool："></a>newCacheThreadPool：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点：</strong></p><ul><li>核心线程数为0</li><li>最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM</li><li>阻塞队列是SynchronousQueue</li><li>非核心线程空闲存活时间为60秒</li></ul><p>工作流程：</p><ul><li>提交任务</li><li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li><li>判断是否有空闲线程，如果有，就去取出任务执行。</li><li>如果没有空闲线程，就新建一个线程执行。</li><li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li></ul><p><strong>适用场景</strong></p><p>用于并发执行大量短期的小任务。</p><h3 id="39-线程池提交execute和submit有什么区别？"><a href="#39-线程池提交execute和submit有什么区别？" class="headerlink" title="39. 线程池提交execute和submit有什么区别？"></a>39. 线程池提交execute和submit有什么区别？</h3><ol><li>execute 用于提交不需要返回值的任务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub &#125; </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    Object s = future.get(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">    <span class="comment">// 处理中断异常 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123; </span><br><span class="line">    <span class="comment">// 处理无法执行任务异常 </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="comment">// 关闭线程池 executor.shutdown();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="40-线程池的线程数应该怎么配置？"><a href="#40-线程池的线程数应该怎么配置？" class="headerlink" title="40. 线程池的线程数应该怎么配置？"></a>40. 线程池的线程数应该怎么配置？</h3><p>一般的经验，不同类型线程池的参数配置：</p><ol><li>计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在<strong>页缺失</strong>(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><ol><li>IO密集型：线程数适当大一点，机器的CPU核心数*2。</li><li>混合型：可以考虑根绝情况将它拆分成CPU密集型和IO密集型任务，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。</li></ol><p>当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。</p><h3 id="41-如何关闭线程池？"><a href="#41-如何关闭线程池？" class="headerlink" title="41. 如何关闭线程池？"></a>41. 如何关闭线程池？</h3><p>可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p><p><strong>shutdown() 将线程池状态置为shutdown,并不会立即停止</strong>：</p><ol><li>停止接收外部submit的任务</li><li>内部正在跑的任务和队列里等待的任务，会执行完</li><li>等到第二步完成后，才真正停止</li></ol><p><strong>shutdownNow() 将线程池状态置为stop。一般会立即停止，事实上不一定</strong>：</p><ol><li>和shutdown()一样，先停止接收外部提交的任务</li><li>忽略队列里等待的任务</li><li>尝试将正在跑的任务interrupt中断</li><li>返回未执行的任务列表</li></ol><p>shutdown 和shutdownnow简单来说区别如下：</p><ul><li>shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。</li><li>shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。</li></ul><h3 id="42-线程池有哪些状态"><a href="#42-线程池有哪些状态" class="headerlink" title="42. 线程池有哪些状态"></a>42. 线程池有哪些状态</h3><p>RUNNING、SHUTDOWM、STOP、TIDYING、TERMINATED</p><p>线程池各个状态切换如图所示：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-78.png" alt="线程池状态切换图"></p><h3 id="43-你能设计实现一个线程池吗？"><a href="#43-你能设计实现一个线程池吗？" class="headerlink" title="***43.  你能设计实现一个线程池吗？"></a>***43.  你能设计实现一个线程池吗？</h3><ul><li>线程池中有N个工作线程</li><li>把任务提交给线程池运行</li><li>如果线程池已满，把任务放入队列</li><li>最后当有空闲时，获取队列中任务来执行</li></ul><blockquote><p>代码参考Cubox的 “一个简单线程池的实现”</p></blockquote><h3 id="44-单机线程池执行断电了应该怎么处理？"><a href="#44-单机线程池执行断电了应该怎么处理？" class="headerlink" title="44. 单机线程池执行断电了应该怎么处理？"></a>44. 单机线程池执行断电了应该怎么处理？</h3><p>可以对任务队列和线程池做持久化处理，等待恢复供电后根据回溯日志做出相关处理。</p><h3 id="45-简单介绍下Fork-Join框架？"><a href="#45-简单介绍下Fork-Join框架？" class="headerlink" title="45. 简单介绍下Fork/Join框架？"></a>45. 简单介绍下Fork/Join框架？</h3><p>Fork/Join框架是Java7提供的一个用于并行执行任务的框架，Fork/Join框架采用的是分而治之的思想，当有许多任务时，分割成许多小任务，将小任务放到不同的任务队列中，创建各自的线程处理这些任务。当有线程先完成任务时，它去其它线程的队列里窃取一个任务来执行，这种方式叫做工作窃取。</p><p>减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/Java/">Java</category>
      
      
      <category domain="http://hznu.asia/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</category>
      
      
      <comments>http://hznu.asia/2022/11/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java集合框架</title>
      <link>http://hznu.asia/2022/11/04/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</link>
      <guid>http://hznu.asia/2022/11/04/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</guid>
      <pubDate>Fri, 04 Nov 2022 02:57:27 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-快速失败-fail-fast-和安全失败-fail-safe&quot;&gt;&lt;a href=&quot;#1-快速失败-fail-fast-和安全失败-fail-safe&quot; class=&quot;headerlink&quot; title=&quot;1. 快速失败(fail-fast)和安全失败(fail</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-快速失败-fail-fast-和安全失败-fail-safe"><a href="#1-快速失败-fail-fast-和安全失败-fail-safe" class="headerlink" title="1. 快速失败(fail-fast)和安全失败(fail-safe)"></a>1. 快速失败(fail-fast)和安全失败(fail-safe)</h3><p><strong>快速失败：</strong>是Java集合支持的一种快速的失败检测机制，不能在并发情况下使用</p><p>原理：在遍历过程中，如果集合内元素发生过修改，则<code>modCount</code>将被改变，而每次遍历将检测<code>modCount</code>的值，如果发生变化，将抛出异常。</p><p>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。</p><p><strong>安全失败：</strong>在遍历时，不是直接在集合上进行遍历的，而是实现拷贝原有集合内容，在拷贝的集合上进行遍历的。</p><p>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p><p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类。</p><h3 id="2-有哪些实现ArrayList线程安全的方法？"><a href="#2-有哪些实现ArrayList线程安全的方法？" class="headerlink" title="2. 有哪些实现ArrayList线程安全的方法？"></a>2. 有哪些实现ArrayList线程安全的方法？</h3><ul><li>使用<code>CopyOnWriteArrayList</code>代替。</li><li>通过同步机制控制ArrayList的读写。</li><li>Vector：Vector是一个线程安全的List,但是它的线程安全实现方式是对所有操作都加上了synchronized关键字，这种方式严重影响效率.所以并不推荐使用Vector。</li><li>synchronizedList：示例如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;String&gt;());</span><br><span class="line">list.add(&quot;1&quot;);</span><br><span class="line">list.add(&quot;2&quot;);</span><br><span class="line">list.add(&quot;3&quot;);</span><br><span class="line"></span><br><span class="line">synchronized (list) &#123;</span><br><span class="line">    Iterator i = list.iterator(); // Must be in synchronized block</span><br><span class="line">    while (i.hasNext()) &#123;</span><br><span class="line">        //foo(i.next());</span><br><span class="line">        System.out.println(i.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-CopyOnWriteArrayList的原理"><a href="#3-CopyOnWriteArrayList的原理" class="headerlink" title="3. CopyOnWriteArrayList的原理"></a>3. CopyOnWriteArrayList的原理</h3><p>CopyOnWriteArrayList就是线程安全版本的ArrayList。CopyOnWriteArrayList采用了一种读写分离的并发策略。CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。</p><h3 id="4-HashMap的put流程"><a href="#4-HashMap的put流程" class="headerlink" title="4. HashMap的put流程"></a>4. HashMap的put流程</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-13.jpg" alt="HashMap插入数据流程图"></p><h3 id="5-HashMap查找操作"><a href="#5-HashMap查找操作" class="headerlink" title="5. HashMap查找操作"></a>5. HashMap查找操作</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-14.png" alt="HashMap查找流程图"></p><ol><li><p>使用扰动函数，获取新的哈希值</p></li><li><p>计算数组下标，获取节点</p></li><li><p>当前节点和key匹配，直接返回</p></li><li><p>否则，当前节点是否为树节点，查找红黑树</p></li><li><p>否则，遍历链表查找</p></li></ol><h3 id="6-HashMap的哈希-扰动函数是怎么设计的"><a href="#6-HashMap的哈希-扰动函数是怎么设计的" class="headerlink" title="6. HashMap的哈希/扰动函数是怎么设计的?"></a>6. HashMap的哈希/扰动函数是怎么设计的?</h3><p>HashMap的哈希函数是先拿到 key 的hashcode，是一个32位的int类型的数值，然后让hashcode的高16位和低16位进行异或操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        // key的hashCode和key的hashCode右移16位做异或运算</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>让hashcode的高16位和低16位进行异或操作，目的是为了降低哈希碰撞的概率。</p></blockquote><h3 id="7-为什么哈希-扰动函数能降hash碰撞？"><a href="#7-为什么哈希-扰动函数能降hash碰撞？" class="headerlink" title="*7. 为什么哈希/扰动函数能降hash碰撞？"></a>*7. 为什么哈希/扰动函数能降hash碰撞？</h3><p>因为<code>key.hashCode()</code> 函数调用的是 key 键值类型自带的哈希函数，返回的是int散列值，而int值的范围是随<strong>编译器</strong>的位数变化的，在32位和64位编译器中，范围是 <code>-2^32 - 1 —— 2^32 -1</code> ，这样的映射空间范围太大，内存根本存不下。所以需要对数组长度取模运算，得到的余数用来访问数组下标。</p><p>哈希/扰动函数降低hash碰撞，是通过自身的高16位和低16位进行异或操作，混合原始哈希码的高位和低位，以此来加大低位的随机性，从而降低随机性。</p><blockquote><p>关于详细说明，访问 <a href="https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_14-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%88%E5%B8%8C-%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E8%83%BD%E9%99%8Dhash%E7%A2%B0%E6%92%9E">https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_14-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%88%E5%B8%8C-%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E8%83%BD%E9%99%8Dhash%E7%A2%B0%E6%92%9E</a></p></blockquote><h3 id="8-为什么HashMap的容量是2的倍数呢？"><a href="#8-为什么HashMap的容量是2的倍数呢？" class="headerlink" title="8. 为什么HashMap的容量是2的倍数呢？"></a>8. 为什么HashMap的容量是2的倍数呢？</h3><ul><li>为了方便哈希取余，这样做可以方便位运算，效率也比 % 取余高。</li><li>在扩容的时候，因为扩容的是2的倍数，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞。</li></ul><h3 id="9-为什么HashMap链表转换成红黑树的阈值为8？"><a href="#9-为什么HashMap链表转换成红黑树的阈值为8？" class="headerlink" title="9. 为什么HashMap链表转换成红黑树的阈值为8？"></a>9. 为什么HashMap链表转换成红黑树的阈值为8？</h3><p>因为和统计学相关，节点个数为8的情况，发生概率小。</p><p>至于红黑树回转成链表设置为6是因为，如果设置为8，那么如果发生碰撞，节点的增减恰好在8附近，那么链表和红黑树会不断相互转换，影响效率。</p><h3 id="10-HashMap为什么扩容因子是0-75"><a href="#10-HashMap为什么扩容因子是0-75" class="headerlink" title="10. HashMap为什么扩容因子是0.75"></a>10. HashMap为什么扩容因子是0.75</h3><p>这是一种折中的考虑设置。</p><p>如果扩容因子比较大，为1，那么空间利用率高了，但是时间成本就高了。</p><p>如果扩容因子比较小，为0.5，那么空间利用率就低了。</p><h3 id="11-HashMap的扩容机制详解"><a href="#11-HashMap的扩容机制详解" class="headerlink" title="11. HashMap的扩容机制详解"></a>11. HashMap的扩容机制详解</h3><blockquote><p><a href="https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_21-%E9%82%A3%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97">https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_21-%E9%82%A3%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97</a></p></blockquote><h3 id="12-JDK1-8对HashMap做了哪些优化？"><a href="#12-JDK1-8对HashMap做了哪些优化？" class="headerlink" title="12. JDK1.8对HashMap做了哪些优化？"></a>12. JDK1.8对HashMap做了哪些优化？</h3><ul><li>数据结构由 <code>数组 + 链表</code> 改成 <code>数组 + 链表 + 红黑树</code> ，时间复杂度由 o(n) 下降到 o(logn)</li><li>链表由头插法改成尾插法。因为头插法在扩容时链表会发生反转，多线程环境下容易形成环。</li><li>扩容rehash。1.7时需要重新hash计算位置，1.8则不用，新的位置不变或者使用索引+新增容量大小。</li></ul><h3 id="13-手动实现一个HashMap"><a href="#13-手动实现一个HashMap" class="headerlink" title="13. 手动实现一个HashMap"></a>13. 手动实现一个HashMap</h3><blockquote><p><a href="https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_23-%E4%BD%A0%E8%83%BD%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAhashmap%E5%90%97">https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_23-%E4%BD%A0%E8%83%BD%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAhashmap%E5%90%97</a></p></blockquote><h3 id="14-HashMap在多线程环境下会出现哪些问题？"><a href="#14-HashMap在多线程环境下会出现哪些问题？" class="headerlink" title="14. HashMap在多线程环境下会出现哪些问题？"></a>14. HashMap在多线程环境下会出现哪些问题？</h3><ul><li>同时有get和put的时候，可能出现get为空。如果在put的时候，出现了扩容时，会导致rehash（1.7时重新计算位置，1.8时可能使用索引+新增容量）。</li><li>在1.7时，链表的头插法可能在多线程环境下出现环形链表。</li><li>同时put可能导致元素缺失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在 JDK 1.7 和 JDK 1.8 中都存在。</li></ul><h3 id="15-如何解决HashMap线程不安全的问题？"><a href="#15-如何解决HashMap线程不安全的问题？" class="headerlink" title="15. 如何解决HashMap线程不安全的问题？"></a>15. 如何解决HashMap线程不安全的问题？</h3><ul><li>使用ConcurrentHashMap，是通过加synchronized 实现的，粒度比较粗。</li><li>Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Map map=Collections.synchronizedMap(new HashMap());</span><br></pre></td></tr></table></figure><ul><li>ConcurrentHashMap 在jdk1.7中使用分段锁，在jdk1.8中使用CAS+synchronized</li></ul><blockquote><p>详解ConcurrentHashMap 在1.7和1.8的区别的原理：<a href="https://blog.csdn.net/m0_55611144/article/details/126223849">https://blog.csdn.net/m0_55611144/article/details/126223849</a></p><p><a href="https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_26-%E8%83%BD%E5%85%B7%E4%BD%93%E8%AF%B4%E4%B8%80%E4%B8%8Bconcurrenthashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97">https://tobebetterjavaer.com/sidebar/sanfene/collection.html#_26-%E8%83%BD%E5%85%B7%E4%BD%93%E8%AF%B4%E4%B8%80%E4%B8%8Bconcurrenthashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97</a></p></blockquote><h3 id="16-HashMap-内部节点是有序的吗？"><a href="#16-HashMap-内部节点是有序的吗？" class="headerlink" title="16. HashMap 内部节点是有序的吗？"></a>16. HashMap 内部节点是有序的吗？</h3><p>无序的。如果要有序，可以使用TreeMap或LinkedHashMap。    </p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/Java/">Java</category>
      
      
      <category domain="http://hznu.asia/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</category>
      
      
      <comments>http://hznu.asia/2022/11/04/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JavaSE</title>
      <link>http://hznu.asia/2022/10/26/JavaSE/</link>
      <guid>http://hznu.asia/2022/10/26/JavaSE/</guid>
      <pubDate>Wed, 26 Oct 2022 02:56:15 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-JVM、JDK-和-JRE-有什么区别&quot;&gt;&lt;a href=&quot;#1-JVM、JDK-和-JRE-有什么区别&quot; class=&quot;headerlink&quot; title=&quot;1. JVM、JDK 和 JRE 有什么区别&quot;&gt;&lt;/a&gt;1. JVM、JDK 和 JRE 有什么区别</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-JVM、JDK-和-JRE-有什么区别"><a href="#1-JVM、JDK-和-JRE-有什么区别" class="headerlink" title="1. JVM、JDK 和 JRE 有什么区别"></a>1. JVM、JDK 和 JRE 有什么区别</h3><p>JVM是Java虚拟机，Java程序运行在JVM上。而正是因为JVM，使得Java具有了跨平台性。</p><p>JRE是Java运⾏时环境，包含在JDK内，它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。</p><p>JDK提供了开发Java程序所需的一系列类包、环境等，它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><h3 id="2-为什么说Java语言“编译与解释并存”？"><a href="#2-为什么说Java语言“编译与解释并存”？" class="headerlink" title="2. 为什么说Java语言“编译与解释并存”？"></a>2. 为什么说Java语言“编译与解释并存”？</h3><p>高级编程语言按照程序的执行方式分为<strong>编译型</strong>和<strong>解释型</strong>两种。</p><p>说Java是编译型是因为，Java语言是经过编译器编译成字节码后在JVM上运行的。</p><p>说Java是解释型是因为，字节码需要在JVM上经过解释成操作系统能识别的语言（机器码），再由操作系统去执行。</p><h3 id="3-Java-有哪些数据类型？"><a href="#3-Java-有哪些数据类型？" class="headerlink" title="3. Java 有哪些数据类型？"></a>3. Java 有哪些数据类型？</h3><p>Java的数据类型分为<strong>基本数据类型</strong>和<strong>引用类型</strong>。</p><p>基本数据类型有：int，long，float，byte，short，double，char，boolean</p><p>引用类型有：class、interface、数组</p><p><strong>引申：为什么Java里有基本数据类型和引用数据类型？</strong></p><pre><code>     存储方式：引用类型在堆里而基本类型在栈里。栈空间小且连续，存取速度比较快；在堆中则需要new，对基本数据类型来说空间浪费率太高；  传值方式：基本类型是在方法中定义的非全局基本数据类型变量，调用方法时作为参数是按数值传递的；引用数据类型变量，调用方法时作为参数是按引用地址传递的；</code></pre><blockquote><p>如果不声明，默认小数为double类型，所以如果要用float的话，必须进行强转</p><p>例如：float a=1.3; 会编译报错，正确的写法 float a = (float)1.3;或者float a = 1.3f;（f或F都可以不区分大小写）</p></blockquote><h3 id="4-详解装箱和拆箱"><a href="#4-详解装箱和拆箱" class="headerlink" title="4. 详解装箱和拆箱"></a>4. 详解装箱和拆箱</h3><h3 id="5-抽象类-abstract-class-和接口-interface-有什么区别？"><a href="#5-抽象类-abstract-class-和接口-interface-有什么区别？" class="headerlink" title="5. 抽象类(abstract class)和接口(interface)有什么区别？"></a>5. 抽象类(abstract class)和接口(interface)有什么区别？</h3><ol><li>接口的方法默认是 public ，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>⼀个类可以实现多个接口，但只能实现⼀个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li><li>从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，而接口是对行为的抽象，是⼀种行为的规范。</li><li>抽象类和接口都不能实例化。</li></ol><blockquote><p>总结⼀下 jdk7~jdk9 Java 中接⼝的变化：</p><ol><li>在 jdk 7 或更早版本中，接⼝⾥⾯只能有常量变量和抽象⽅法。这些接⼝⽅法必须由选择实现接⼝的类实现。</li><li>jdk 8 的时候接⼝可以有默认⽅法和静态⽅法功能。</li><li>jdk 9 在接⼝中引⼊了私有⽅法和私有静态⽅法。</li></ol></blockquote><h3 id="6-final关键字的作用"><a href="#6-final关键字的作用" class="headerlink" title="6. final关键字的作用"></a>6. final关键字的作用</h3><p>final关键字表示不可变，可以修饰类、属性和方法。</p><p>被final修饰的类不可继承。</p><p>被final修饰的属性不可变，<strong>被 final 修饰的变量必须被显式第指定初始值，还得注意的是，这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变。</strong></p><p>被final修饰的方法不可被重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">System.out.println(sb);  <span class="comment">//abcd</span></span><br></pre></td></tr></table></figure><blockquote><p> 上面的例子则说明了变量不可变的含义是指引用不可变。</p></blockquote><h3 id="7-重写和重载的区别"><a href="#7-重写和重载的区别" class="headerlink" title="7. 重写和重载的区别"></a>7. 重写和重载的区别</h3><p><strong>重载</strong>：</p><p>方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。<strong>重载Overloading是一个类中多态性的一种表现。</strong></p><p><strong>重写：</strong></p><p>1）参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</p><p>2）返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。</p><p>3）访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</p><p>4）重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：</p><p>父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int doSomething() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 输入参数不同，意味着方法签名不同，重载的体现</span><br><span class="line">public int doSomething(List&lt;String&gt; strs) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// return类型不一样，编译不能通过</span><br><span class="line">public short doSomething() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-final、finally、finalize-的区别？"><a href="#8-final、finally、finalize-的区别？" class="headerlink" title="8. final、finally、finalize 的区别？"></a>8. final、finally、finalize 的区别？</h3><p>final：见第6点。</p><p>finally：是和try、catch结合使用的。finally包含的代码块，一定会被执行。</p><p>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。</p><h3 id="9-和-equals-的区别？"><a href="#9-和-equals-的区别？" class="headerlink" title="9. ==和 equals 的区别？"></a>9. ==和 equals 的区别？</h3><p>对于基本数据类型，==比较的是他们的值，而基本数据类型没有equals方法。</p><p>对于引用类型，==比较的是他们的地址。<strong>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</strong></p><p><strong>诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</strong></p><h3 id="10-为什么重写-equals-时必须重写-hashCode-方法？"><a href="#10-为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="10. 为什么重写 equals 时必须重写 hashCode 方法？"></a>10. 为什么重写 equals 时必须重写 hashCode 方法？</h3><p>因为如果两个对象相等，那么他们的hash值一定相等，对两个对象分别调⽤ equals 方法都返回 true。反之如果两个对象hash值相等，他们不一定相等。因此，<strong>equals</strong> 方法被覆盖过，则 <strong>hashCode</strong> 方法也必须被覆盖。</p><p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode() ，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p><h3 id="11-Java-是值传递，还是引用传递？"><a href="#11-Java-是值传递，还是引用传递？" class="headerlink" title="11. Java 是值传递，还是引用传递？"></a>11. Java 是值传递，还是引用传递？</h3><p>Java 语言是<strong>值传递</strong>。JVM 的内存分为堆和栈，其中栈中存储了基本数据类型和引用数据类型实例的地址，也就是对象地址。</p><p>而对象所占的空间是在堆中开辟的，所以传递的时候可以理解为把变量存储的对象地址给传递过去，因此引用类型也是值传递。</p><h3 id="12-Java如何实现浅拷贝和深拷贝？"><a href="#12-Java如何实现浅拷贝和深拷贝？" class="headerlink" title="12. Java如何实现浅拷贝和深拷贝？"></a>12. Java如何实现浅拷贝和深拷贝？</h3><p>浅拷贝：Object 类提供的 clone()方法可以非常简单地实现对象的浅拷贝。</p><p>深拷贝：</p><ul><li>重写克隆方法：重写克隆方法，引用类型变量单独克隆，这里可能会涉及多层递归。</li><li>序列化：可以先将原对象序列化，再反序列化成拷贝对象。</li></ul><h3 id="13-Java创建对象有哪些方式？"><a href="#13-Java创建对象有哪些方式？" class="headerlink" title="13. Java创建对象有哪些方式？"></a>13. Java创建对象有哪些方式？</h3><ul><li>new 创建新对象</li><li>通过反射机制</li><li>采用 clone 机制</li><li>通过序列化机制</li></ul><h3 id="14-String-不是不可变类吗？字符串拼接是如何实现的？"><a href="#14-String-不是不可变类吗？字符串拼接是如何实现的？" class="headerlink" title="14. String 不是不可变类吗？字符串拼接是如何实现的？"></a>14. String 不是不可变类吗？字符串拼接是如何实现的？</h3><p>在<strong>jdk1.8 之前</strong>，a 和 b 初始化时位于字符串常量池，ab 拼接后的对象位于堆中。经过拼接新生成了 String 对象。如果拼接多次，那么会生成多个中间对象。</p><p>内存如下：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-18.png" alt="jdk1.8之前的字符串拼接"></p><p>在<strong>Java8 时</strong>JDK 对“+”号拼接进行了优化，上面所写的拼接方式会被优化为基于 StringBuilder 的 append 方法进行处理。Java 会在编译期对“+”号进行处理。</p><p><strong>这样看，使用 + 号 和使用 StringBuilder  是没有区别的，在一般情况下是这样，但是在循环里面，建议使用 StringBuilder 。</strong></p><p>举个例子，看一段这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s= &quot;&quot; ;</span><br><span class="line">    for(int i=1;i&lt;10;i++)&#123;</span><br><span class="line">    s+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用jad工具反编译代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">String s = &quot;&quot;:</span><br><span class="line">for(int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">s = (new StringBuilder(String.valueOf(s))).append(i).tostring() ;</span><br><span class="line">&#125;</span><br><span class="line">System.out.printin(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的做法应该是在循环外层先创建好StringBuilder 对象，然后在循环体内使用append 方法进行处理。</p><h3 id="15-什么是序列化？什么是反序列化？Serializable-接口有什么用？"><a href="#15-什么是序列化？什么是反序列化？Serializable-接口有什么用？" class="headerlink" title="15. 什么是序列化？什么是反序列化？Serializable 接口有什么用？"></a>15. 什么是序列化？什么是反序列化？Serializable 接口有什么用？</h3><p>序列化是将Java对象转换为二进制流，反序列化是将二进制流转换为对象。</p><p>这个接口只是一个标记，没有具体的作用，但是如果不实现这个接口，在诸如使用Dubbo等RPC调用场景的情况下，会抛出异常。</p><h5 id="Dubbo-RPC-方法类都要实现Serializable接口的原因"><a href="#Dubbo-RPC-方法类都要实现Serializable接口的原因" class="headerlink" title="Dubbo RPC 方法类都要实现Serializable接口的原因"></a>Dubbo RPC 方法类都要实现Serializable接口的原因</h5><p>dubbo在使用hessian2协议序列化方式的时候，对象的序列化使用的是JavaSerializer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.com.caucho.hessian.io.SerializerFactory#getDefaultSerializer</span><br><span class="line"></span><br><span class="line">com.alibaba.com.caucho.hessian.io.SerializerFactory#getSerializer</span><br><span class="line"></span><br><span class="line">com.alibaba.com.caucho.hessian.io.Hessian2Output#writeObject</span><br></pre></td></tr></table></figure><p>获取默认的序列化方式的时候，会判断该参数是否实现了Serializable接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected Serializer getDefaultSerializer(Class cl) &#123;</span><br><span class="line">    if (_defaultSerializer != null)</span><br><span class="line">        return _defaultSerializer;</span><br><span class="line">    // 判断是否实现了Serializable接口</span><br><span class="line">    if (!Serializable.class.isAssignableFrom(cl)</span><br><span class="line">        &amp;&amp; !_isAllowNonSerializable) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Serialized class &quot; + cl.getName() + &quot; must implement java.io.Serializable&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return new JavaSerializer(cl, _loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-Java-泛型了解么？什么是类型擦除？为什么要类型擦除？介绍一下常用的通配符？"><a href="#16-Java-泛型了解么？什么是类型擦除？为什么要类型擦除？介绍一下常用的通配符？" class="headerlink" title="16. Java 泛型了解么？什么是类型擦除？为什么要类型擦除？介绍一下常用的通配符？"></a>16. Java 泛型了解么？什么是类型擦除？为什么要类型擦除？介绍一下常用的通配符？</h3><p>Java泛型是JDK1.5的特性，<strong>泛型本质上是参数化类型，也就是说操作的数据类型被指定为一个参数。</strong></p><p>类型擦除是指在编译时，所有的泛化类型被擦除，转换成实际需要的类型。</p><p>需要类型擦除主要是为了向下兼容，因为 JDK5 之前是没有泛型的，为了让 JVM 保持向下兼容，就出了类型擦除这个策略。</p><p>常见通配符有K、T、E、V。</p><h3 id="17-正向代理和反向代理的区别"><a href="#17-正向代理和反向代理的区别" class="headerlink" title="17. 正向代理和反向代理的区别"></a>17. 正向代理和反向代理的区别</h3><p>网络代理分为正向代理和反向代理，代理其实就是一个中介，最初的时候，只有正向代理，是帮助内网客户端访问外网服务器的，后来出现了反向代理，是把外网客户端的请求转发给内网服务器。<br>其实最简单的区别，正向代理代理的是客户端，反向代理代理的是服务器。正向代理一般是客户端架设的，反向代理一般是服务器架设的。<br>1、代理对象不同。正向代理代理的是客户端，反向代理代理的是服务器。正向代理帮助客户访问其无法访问的服务器资源，反向代理帮助服务器做负载均衡，另外，由于客户端跟真实服务器不直接接触，能起到一定安全防护的作用。<br>2、架设主体不同。正向代理一般是客户端架设的，比如在自己的机器上装一个代理软件，反向代理一般是服务器架设的，通常是在机器集群中部署个反向代理服务器。<br>3、保护对象不同。正向代理保护对象是客户端，反向代理保护对象是原始资源服务器。<br>4、作用目的不同。正向代理主要目的是解决访问限制问题，而反向代理一方面是作为负载均衡，再就是起到安全防护的作用。</p><h3 id="18-在Java中，String为什么设置成不可变类型"><a href="#18-在Java中，String为什么设置成不可变类型" class="headerlink" title="18. 在Java中，String为什么设置成不可变类型"></a>18. 在Java中，String为什么设置成不可变类型</h3><p>在Java中，String被设计成不可变类型，是为了提高字符串的安全性和可靠性。具体来说，有以下几个原因：</p><ol><li>线程安全：由于字符串是不可变的，所以多个线程可以同时访问同一个字符串对象，而不需要担心数据被篡改，从而提高了程序的线程安全性。</li><li>缓存哈希值：由于字符串的哈希值在创建时就被缓存起来了，所以不需要每次使用字符串时都重新计算哈希值，从而提高了程序的性能。</li><li>安全性：由于字符串是不可变的，所以在使用字符串时不需要担心数据被意外修改，从而提高了程序的安全性。</li><li>简化代码：由于字符串是不可变的，所以在使用字符串时可以省去一些代码，比如不需要手动处理字符串的长度、位置等信息，从而使代码更加简洁易懂。</li></ol>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/Java/">Java</category>
      
      
      <category domain="http://hznu.asia/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</category>
      
      
      <comments>http://hznu.asia/2022/10/26/JavaSE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>师生双选系统钉钉版实现过程总结</title>
      <link>http://hznu.asia/2022/10/18/%E5%B8%88%E7%94%9F%E5%8F%8C%E9%80%89%E7%B3%BB%E7%BB%9F%E9%92%89%E9%92%89%E7%89%88%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/</link>
      <guid>http://hznu.asia/2022/10/18/%E5%B8%88%E7%94%9F%E5%8F%8C%E9%80%89%E7%B3%BB%E7%BB%9F%E9%92%89%E9%92%89%E7%89%88%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Tue, 18 Oct 2022 06:32:41 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;一-需求分析&quot;&gt;&lt;a href=&quot;#一-需求分析&quot; class=&quot;headerlink&quot; title=&quot;一. 需求分析&quot;&gt;&lt;/a&gt;一. 需求分析&lt;/h2&gt;&lt;h4 id=&quot;用户提出需求&quot;&gt;&lt;a href=&quot;#用户提出需求&quot; class=&quot;headerlink&quot; ti</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="一-需求分析"><a href="#一-需求分析" class="headerlink" title="一. 需求分析"></a>一. 需求分析</h2><h4 id="用户提出需求"><a href="#用户提出需求" class="headerlink" title="用户提出需求"></a>用户提出需求</h4><p>本系统是学院老师，希望给即将毕业的本科生，提供一个双选导师的平台，指导论文的编写，并希望该系统能够接入钉钉使用，用户提出的大致需求如下：</p><blockquote><p>1、导入老师信息（系部，工号，姓名，研究方向，可指导本科生人数）；<br>2、导入学生信息（学号，专业，姓名）；<br>3、学生可以选择本系部的导师（先到先得，满8人后，此导师就不可以再被选择）；<br>4、导师可以点是否同意接收此学生。如果不同意，取消被选，导师名额增加一个，该学生再不能选该导师；<br>5、后台管理员可以设置什么时候开始双选，什么时候截止。</p></blockquote><h4 id="补充需求"><a href="#补充需求" class="headerlink" title="补充需求"></a>补充需求</h4><p>对于初次需求，用户进行了完善，新增需求点如下：</p><blockquote><ol><li>学生志愿可以填写3个，第一轮一志愿的老师选择确认，第二轮二志愿的老师选择，第三轮三志愿的老师选择。三轮结束后，学生和导师自动匹配。</li><li>老师的界面可以显示学生的绩点和100字以内的自荐信。</li></ol></blockquote><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>在用户提出需求后，一般来说，都是会有不少瑕疵或者没考虑到的功能点的，所以需要开发人员细化需求，对其进一步拆解。</p><p>从上面的需求我们可以提炼出三个角色——管理员、学生、导师。而我们对功能点的分析也应该从这三个角色展开分析。</p><h5 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h5><p>对于管理员角色，用户希望能够设置双选时间区间，并且能够导入学生和老师信息。</p><p>此时，我们对管理员的设置双选时间区间功能点应该拆分为两块，一个是在没有双选时间的时候，新增双选时间；另一块是在数据库中已经存在双选时间的时候，更新双选时间。对于导入学生老师信息功能相对明确。</p><p>从上面的需求看，管理员的功能用户只提出了两个功能，但是仔细分析，我们会发现这两个功能显然是不够的。</p><p>首先，双选完成后，<strong>双选结果管理员是不是也需要能看到？看到结果是不是也需要一个导出功能？</strong>如果仅仅只是能看，不能导出那这个系统就极大不便了，这也是后期用户肯定会提出来的。</p><p>其次，对于用户，管理员是不是需要能够对其进行管理？比如修改某个用户信息，去年的双选学生需要删除，获取今年新增的老师也要加进来等等，因此，<strong>管理员还需要用户管理功能，而不仅仅只是导入功能</strong>。</p><p>这样，我们需要在用户提出需求的基础上，新增两个功能点：</p><blockquote><ol><li>双选结果查看并导出；</li><li>用户管理。</li></ol></blockquote><h5 id="学生"><a href="#学生" class="headerlink" title="学生"></a>学生</h5><p>从用户的初次需求和补充需求来看，用户提出的功能点是学生能够在系统内选择导师，补充需求提出学生能够填写自荐信。而系统涉及的功能点还包括对学生能够选择的导师进行筛选，这块我们后面分析。</p><p>这样，学生角色功能点如下：</p><blockquote><ol><li>选择导师</li></ol></blockquote><h5 id="导师"><a href="#导师" class="headerlink" title="导师"></a>导师</h5><p>从用户的初次需求和补充需求来看，提出的需求较为模糊。用户描述是“导师可以点是否同意接收此学生。如果不同意，取消被选，导师名额增加一个，该学生再不能选该导师”。</p><p>作为开发人员，对于前面一句话，其实要分析为：导师同意接收时名额减一，拒绝时流转到下一个流程。而对于学生不能再选择导师，即在学生填写志愿时判断不能有重复导师即可。</p><p>这样，导师角色功能点如下：</p><blockquote><ol><li>同意、拒绝接收</li><li>查看双选结果</li></ol></blockquote><h4 id="得出流程图"><a href="#得出流程图" class="headerlink" title="得出流程图"></a>得出流程图</h4><p><img src="https://img.hznu.asia/blog/%E9%9C%80%E6%B1%82%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><h2 id="二-结合钉钉分析"><a href="#二-结合钉钉分析" class="headerlink" title="二. 结合钉钉分析"></a>二. 结合钉钉分析</h2><p>看完上面的分析，应该会角色功能其实不多，应该也很容易可以开发完成，但是这也是很多开发者在开发初期容易产生的错觉。</p><blockquote><p>所有的编程人员都是乐观主义者。          —-《人月神话》</p></blockquote><p>我们来结合钉钉梳理一下需求，以及开发过程中我们需要考虑的问题。</p><h4 id="应用类型"><a href="#应用类型" class="headerlink" title="应用类型"></a>应用类型</h4><p>在开发初期，我们明确了要做能够接入钉钉的应用。而通过阅读文档会发现，钉钉的应用是分很多种的，每种的功能限制是不一样的，比如有些可以调用钉钉消息通知的接口，而有些不行。同时，不同应用虽然有些功能都可以做到，但是他们调用的API也是不一样的。</p><p>钉钉的应用类型如下：</p><table><thead><tr><th>应用类型</th><th>开发者</th><th>使用人员</th><th>支持的能力</th><th>是否支持上架到钉钉应用广场</th></tr></thead><tbody><tr><td>企业内部应用</td><td>企业内部开发者或委托的服务商开发者</td><td>安装了该应用的企业内部人员</td><td>小程序支持移动端H5微应用支持移动端支持PC端机器人</td><td>否</td></tr><tr><td>第三方企业应用</td><td>产品方案商的开发者</td><td>购买开通该三方应用的企业内部人员</td><td>小程序支持移动端H5微应用支持移动端支持PC端</td><td>是，需要满足上架要求，上架流程请参考<a href="https://open.dingtalk.com/document/operation-specification/isv-cooperation-guide#topic-2057068">合作全流程指引</a>。</td></tr><tr><td>第三方个人应用</td><td>产品方案商的开发者</td><td>钉钉的个人用户</td><td>小程序支持移动端</td><td>否</td></tr></tbody></table><p>进一步阅读各种类型的文档得出，企业内部应用最符合我们的需求，并且可以很方便调用大部分API，因此，类型<strong>我们选择为企业内部应用</strong>。</p><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>权限控制在没有开发经验的用户不会提出的需求点，但是开发人员是需要重点关注的。</p><p>既然我们要做的是钉钉小程序，那么权限控制就理应交给钉钉去控制，而我们去获取钉钉的数据，因此，就需要阅读文档，去了解钉钉是如何实现权限控制以及用户如何登录的。</p><p>通过阅读企业内部应用免登流程后，我们可以总结出，实现企业内部应用免登，是让企业员工在钉钉内使用企业内部应用时无需输入账号和密码，其登录流程如下：</p><ol><li><p>获取免登授权码（AuthCode，客户端调用获取）。</p><ul><li><a href="https://open.dingtalk.com/document/orgapp-client/mini-program-free-login">小程序免登</a></li><li><a href="https://open.dingtalk.com/document/orgapp-client/logon-free-process">微应用免登</a></li></ul></li><li><p>获取AccessToken。</p><p>调用接口获取access_token，详情参考<a href="https://open.dingtalk.com/document/orgapp-server/obtain-orgapp-token">获取企业内部应用的access_token</a>。</p></li><li><p>获取userid。</p><p>调用接口获取用户的userid，详情参考<a href="https://open.dingtalk.com/document/orgapp-server/obtain-the-userid-of-a-user-by-using-the-log-free">通过免登码获取用户信息</a>。</p></li><li><p>获取用户详情。</p><p>调用接口获取用户详细信息，详情参考<a href="https://open.dingtalk.com/document/orgapp-server/query-user-details">根据userId获取用户详情</a>。</p></li></ol><h4 id="用户信息管理"><a href="#用户信息管理" class="headerlink" title="用户信息管理"></a>用户信息管理</h4><p>对于用户信息，是开发过程中需要重点关注的问题。用户提出需求是系统管理员能够导入学生和导师信息。如果这里在师生双选系统中，单独做一个导入功能的话，那么就需要用户做一张excel表，核对各种信息后，然后去导入用户信息。</p><p>这样做确实不难，目前市面上非常多excel导入导出组件，可以很方便实现。但是，如果采用这种方式的话，做出来的系统是不是钉钉小程序区别不大。</p><p>因为这样做，你的用户信息没办法和钉钉交互，而你也没办法使用钉钉的消息通知，待办事项通知等等功能。学生选择完成导师后，导师需要进入应用才能看到学生的双选信息，然后再进行操作，这显然意义不大，也没有充分利用钉钉小程序的特性，我认为这样实现是一个失败的产品。</p><p>所以，对于用户管理，我们借助钉钉帮我们实现。但是，如果在原有用户基础上操作的话，容易影响其他功能使用，也不够安全。因此，我们在钉钉管理界面新建一个“师生双选部门”，并新增三个子部门：“导师”、“学生”、“管理员”，如下图所示：</p><p><img src="https://img.hznu.asia/blog/%E6%96%B0%E5%A2%9E%E5%B8%88%E7%94%9F%E5%8F%8C%E9%80%89%E9%83%A8%E9%97%A8.png"></p><p>对于用户信息，从需求看，还需要绩点和招生人数两个信息，因此，我们需要新增拓展字段，并对学生角色隐藏“招生人数”此类敏感信息，如下图所示：</p><p><img src="https://img.hznu.asia/blog/%E6%8B%93%E5%B1%95%E5%AD%97%E6%AE%B5%E8%AE%BE%E7%BD%AE.png"></p><h4 id="API调用权限控制"><a href="#API调用权限控制" class="headerlink" title="API调用权限控制"></a>API调用权限控制</h4><p>对于每个钉钉应用，用户都可以以应用为维度控制调用权限，登录钉钉管理后台–》权限控制即可配置，如下图所示：</p><p><img src="https://img.hznu.asia/blog/%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE.png"></p><h4 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h4><p>前端我选用的框架是Vue、uniapp，组件库使用uview。原因是uview可以很方便打包成各种小程序，既可以当H5使用，也可以稍作修改，接入小程序。</p><p>后端则是常见的SpringBoot等。</p><h4 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h4><p>真机调试过程相对比较麻烦，需要先使用HBuilderX开发工具，将前端开发完成，可以测试后，打包成钉钉小程序，并导入小程序开发者工具，进行真机调试。此时，需要使电脑和手机在同一个局域网中，同时需要在钉钉小程序应用后台配置应用网关，添加局域网IP。</p><p>对此真机调试的缓存数据，由于不能手动删除，因此需要在前端首页mock数据，并调用钉钉或uniapp缓存api加载或删除缓存数据。</p><h4 id="OA审批调用"><a href="#OA审批调用" class="headerlink" title="OA审批调用"></a>OA审批调用</h4><p>OA审批调用是在代码实现过程中，工作量稍大的部分。此处也分官方OA审批和自有OA审批，这里不展开讲解两者区别，可进入钉钉开发者文档查看<a href="https://open.dingtalk.com/document/orgapp-server/workflow-overview">OA审批模块</a>。</p><p>通过分析后，我认为自有OA审批对于该需求会好做一些，更方便自己控制和数据调用，所以我采用的是自有OA审批，自己控制该流程。采用自由OA审批分以下几个步骤：</p><ol><li>构造审批模板，需通过调用API构造。如果存在，则直接返回模板ID使用。</li><li>每次审批开始前，需要创建不带流程的审批实例。该实例会在申请人一端的OA审批模块看到，并传入URL，点击跳转查看该实例详情。</li><li>创建并拿到审批实例ID后，创建待办事项，待办事项在审批接收人一端的待办事项可以看到。并且传入URL，点击跳转该待办任务详情。</li><li>若导师同意接收，待办任务接收，审批实例也结束，结果导入双选结果表；若导师拒绝，则待办任务结束，审批实例不结束，后续流程仍复用该实例。其他流转逻辑则根据需求而流转，在代码内实现。</li><li>导师和学生匹配成功后，需要调用钉钉API的消息通知，通知导师和学生匹配成功。</li></ol><p>通过分析以上逻辑，我们会发现有一块是需要传入URL的，因此，在测试阶段，我们需要做内网穿透，否则每次都需要部署到服务器测试，非常麻烦。钉钉在之前是提供了内网穿透测试工具的，但是在今年7月停止服务，因此，需要寻找另一款工具，这里不推荐使用<a href="https://ngrok.com/docs/getting-started">ngrok</a>。因为他们在免费版本中强制执行安全页面(浏览器警告)，并且没办法调用后端的Get请求。作为替代方案，目前先使用花生壳看下效果怎样。</p><h4 id="师生匹配"><a href="#师生匹配" class="headerlink" title="师生匹配"></a>师生匹配</h4><p>在师生匹配过程中，实际上还是碰到不少问题的。首先我们给予用户需求来分析一下。</p><p>在用户的首次需求中，用户提出需求说：导师是先选先得。</p><p>在补充需求中，用户提出需求说：学生可以选择三个志愿。</p><p>这样其实是有问题的。如果先到先得的话，可能有这种场景：一个学生选择三个志愿导师，一个人就占了三个名额了，其他学生没导师选了。这样其他人要选择导师的话，就要等先选的人流程走完，将名额空出来才可以选。这样的产品显示不够好。</p><p>所以，我们要结合用户需求，进行对接修改。在和用户对接后，我们将需求修改成这样：</p><blockquote><p>不设置先到先得，所有学生都能选所有导师，把选择权给导师。假如有8个招生名额，有10个同学选择该导师，导师接收8个。其他两位同学走二志愿。二志愿没有名额或者拒绝走三志愿，以此类推，直到走到自动匹配阶段。</p></blockquote><p>这样看似乎没有什么问题了，其实不然。</p><p>用上面的分析看，流程是这样的，假如到了导师选择的开放时间，学生进入系统选择导师。这样有些学生可能会先选择导师，有些选的慢一些。假如先选的学生直接开始流程，那么会有什么现象呢？</p><p>假如这样的话，我们没办法等到所有学生选择完成后再开始下一流程。因为学生数据都在钉钉内，我们不知道本次有多少学生参加导师选择。</p><p>那么有没有办法获取呢，其实也是有的，因为我们是在钉钉新建了一个部门，直接获取部门人数就好了。但是仍然会有一些问题，即使我们获取到所有学生数，假如只有几个学生没有提交双选意向，那么流程还是继续不下去。</p><p>所以，我们应该把选择权交给用户。在学生提交双选意向后，不直接开始流程，而是先存在数据库，并将当前提交的用户信息提交让系统管理员看到，由管理员选择是否开始流程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在一个项目开发前期，用户提出的需求往往都不够明确，需要需求人员反复对接完善需求，其实这也是一块非常大而且需求非常多时间的开发过程，在开发过程中也应该得到重视。总而言之，一切要从用户角度出发，用他们的想法，结合程序开发的思维去细化需求，思考问题。</p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">项目总结</category>
      
      
      
      <comments>http://hznu.asia/2022/10/18/%E5%B8%88%E7%94%9F%E5%8F%8C%E9%80%89%E7%B3%BB%E7%BB%9F%E9%92%89%E9%92%89%E7%89%88%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DDD初探(2)</title>
      <link>http://hznu.asia/2022/09/23/DDD%E5%88%9D%E6%8E%A2(2)/</link>
      <guid>http://hznu.asia/2022/09/23/DDD%E5%88%9D%E6%8E%A2(2)/</guid>
      <pubDate>Fri, 23 Sep 2022 06:19:22 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;上一篇系列文章DDD初探(1)简单介绍了领域、子域、限界上下文、上下文映射图、一些常见的系统架构、实体和值对象等等。对DDD基本概念以及部分核心思想进行阐述，这篇则是延续了上一篇，将对DDD的、领域服务、领域事件、聚合、工厂和资源库等等进行进一步讲</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>上一篇系列文章DDD初探(1)简单介绍了领域、子域、限界上下文、上下文映射图、一些常见的系统架构、实体和值对象等等。对DDD基本概念以及部分核心思想进行阐述，这篇则是延续了上一篇，将对DDD的、领域服务、领域事件、聚合、工厂和资源库等等进行进一步讲解。</p></blockquote><h2 id="一-领域服务"><a href="#一-领域服务" class="headerlink" title="一. 领域服务"></a>一. 领域服务</h2><p>领域中的服务表示一个无状态的操作，它用于实现特定于某个领域的任务。当某个操作不适合放在聚合和值对象上时，最好的方式便是使用领域服务了。</p><p>在上一篇系列文章中，我们有讲到贫血模型的概念，同时也给出了避免贫血模型的方法。要想避免贫血模型，简单说，就是要给实体赋予行为，而领域服务也有些相似，他是用来处理一些包含业务逻辑的实体的行为。</p><p>那么，在什么情况下，一个操作不属于实体或者值对象呢？要给出一个全面的原因列表是困难的，这里罗列了以下几点。你可以使用领域服务来:</p><ol><li><strong>执行一个显著的业务操作过程。</strong></li><li><strong>对领域对象进行转换。</strong></li><li><strong>以多个领域对象作为输入进行计算，结果产生一个值对象。</strong></li></ol><p>要理解什么是领域服务其实是不难的，在业务处理过程，对于领域服务和实体行为的划分也没有一个严格的约束，取决于怎么设计更为合理。我们举个简单的例子对两者进行区分。</p><p>假如现在有个权限认证限界上下文，我们要做两件事，一件是检查用户是否是活跃状态一件是根据用户ID、账号、密码查出一个用户对象，并对某些敏感内容做数据脱敏处理。这两件事看上去也是相辅相成的，如果要检查用户状态的话，那么就要先把这个对象查出来，然后去查他的某个字段是否是活跃状态。</p><p>但是，假如要查出这个对象的话，就必然要从资源库（后面会单独介绍，暂时可以理解成数据库）中去取出来，并进行如数据脱敏等类似的业务逻辑的处理。</p><p>因此，我们较好的做法是将检查活跃状态这个完全和对象相关的行为放到实体或聚合里面去做，而和业务相关并且需要资源库参与的放在领域服务中去做。</p><p>其实解释到这里，大概以及可以对其有一个简单的概念了，个人认为这部分理解并不是很难，如果觉得有必要深入结合例子理解的话，可以结合一些相关书籍去看。</p><h2 id="二-领域事件"><a href="#二-领域事件" class="headerlink" title="二. 领域事件"></a>二. 领域事件</h2><p>在DDD的最初形态中，是不包含领域事件这个概念的，随着DDD的发展，逐渐加上了这部分内容。目前业界对于领域事件褒贬不一，大部分人还是拒绝在微服务中引入领域事件，因为他是的系统间的调用关系变得复杂且不清晰，同时，他也并不是一个容易设计的模块。</p><p>在引入领域事件时，你需要对系统有个相对全面的理解，因为引入领域事件后，系统有了更为复杂的调用关系。同时，由于领域事件处理包括：事件构建和发布、事件数据持久化、事件总线、消息中间件、事件接收和处理等，所以你需要对这些技术都有较为深入的理解。但是，作为介绍DDD的文章，还是有必要介绍一下领域事件的，毕竟他也有他的好处——实现解耦。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>一个领域事件将导致进一步的业务操作，在实现业务解耦的同时，还有助于形成完整的业务闭环。</p><p>举例来说的话，领域事件可以是业务流程的一个步骤，比如学生学费缴费完成后，触发生成缴费凭证的动作或者触发发送缴费邮件通知操作；或者一个事件发生后触发的后续动作，比如密码连续输错三次，触发锁定账户的动作。</p><h4 id="如何识别领域事件"><a href="#如何识别领域事件" class="headerlink" title="如何识别领域事件"></a>如何识别领域事件</h4><p>在做场景分析时，我们要捕捉业务人员口中的关键词：“如果发生……，则……”“当做完……的时候，请通知……”“发生……时，则……”等。在这些场景中，如果发生某种事件后，会触发进一步的操作，那么这个事件很可能就是领域事件。</p><p>领域事件比较容易和传统 SOA 的直接调用混淆，所以有必要解释下两者的关系。<strong>首先我们要明白，一次事务最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应采用领域事件的最终一致性。</strong></p><p>领域事件驱动设计可以切断领域模型之间的强依赖关系，事件发布完成后，发布方不必关心后续订阅方事件处理是否成功，这样可以实现领域模型的解耦，维护领域模型的独立性和数据的一致性。在领域模型映射到微服务系统架构时，领域事件可以解耦微服务，微服务之间的数据不必要求强一致性，而是基于事件的最终一致性。</p><p>而领域事件也分为一个微服务内的领域事件和多个微服务之间的领域事件。</p><h4 id="一个微服务内的领域事件"><a href="#一个微服务内的领域事件" class="headerlink" title="一个微服务内的领域事件"></a>一个微服务内的领域事件</h4><p>微服务内大部分事件的集成，都发生在同一个进程内，进程自身可以很好地控制事务，因此不一定需要引入消息中间件。但一个事件如果同时更新多个聚合，按照 DDD“一次事务只更新一个聚合”的原则，你就要考虑是否引入事件总线。但微服务内的事件总线，可能会增加开发的复杂度，因此你需要结合应用复杂度和收益进行综合考虑。</p><h4 id="微服务之间的领域事件"><a href="#微服务之间的领域事件" class="headerlink" title="微服务之间的领域事件"></a>微服务之间的领域事件</h4><p>领域事件发生在微服务之间的场景比较多，事件处理的机制也更加复杂。跨微服务的事件可以推动业务流程或者数据在不同的子域或微服务间直接流转。</p><p>跨微服务的事件机制要总体考虑事件构建、发布和订阅、事件数据持久化、消息中间件，甚至事件数据持久化时还可能需要考虑引入分布式事务机制等。</p><p>微服务之间的访问也可以采用应用服务直接调用的方式，实现数据和服务的实时访问，弊端就是跨微服务的数据同时变更需要引入分布式事务，以确保数据的一致性。分布式事务机制会影响系统性能，增加微服务之间的耦合，所以我们还是要尽量避免使用分布式事务。</p><h3 id="领域事件总体架构"><a href="#领域事件总体架构" class="headerlink" title="领域事件总体架构"></a>领域事件总体架构</h3><p>领域事件的执行需要一系列的组件和技术来支撑。我们来看一下这个领域事件总体技术架构图，领域事件处理包括：事件构建和发布、事件数据持久化、事件总线、消息中间件、事件接收和处理等。下面我们逐一讲一下。</p><p><img src="https://img.hznu.asia/DDD/%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p><h4 id="1-事件构建和发布"><a href="#1-事件构建和发布" class="headerlink" title="1. 事件构建和发布"></a>1. 事件构建和发布</h4><p>事件基本属性至少包括：事件唯一标识、发生时间、事件类型和事件源，其中事件唯一标识应该是全局唯一的，另外事件中还有一项更重要，那就是业务属性，用于记录事件发生那一刻的业务数据，这些数据会随事件传输到订阅方，以开展下一步的业务操作。</p><p>事件发布之前需要先构建事件实体并持久化。事件发布的方式有很多种，你可以通过应用服务或者领域服务发布到事件总线或者消息中间件，也可以从事件表中利用定时程序或数据库日志捕获技术获取增量事件数据，发布到消息中间件。</p><h4 id="2-事件数据持久化"><a href="#2-事件数据持久化" class="headerlink" title="2. 事件数据持久化"></a>2. 事件数据持久化</h4><p>事件数据持久化可用于系统之间的数据对账，或者实现发布方和订阅方事件数据的审计。当遇到消息中间件、订阅方系统宕机或者网络中断，在问题解决后仍可继续后续业务流转，保证数据的一致性。</p><h4 id="3-事件总线"><a href="#3-事件总线" class="headerlink" title="3. 事件总线"></a>3. 事件总线</h4><p>事件总线是实现微服务内聚合之间领域事件的重要组件，它提供事件分发和接收等服务。事件总线是进程内模型，它会在微服务内聚合之间遍历订阅者列表，采取同步或异步的模式传递数据。</p><p>事件分发流程大致如下：如果是微服务内的订阅者（其它聚合），则直接分发到指定订阅者；如果是微服务外的订阅者，将事件数据保存到事件库（表）并异步发送到消息中间件；如果同时存在微服务内和外订阅者，则先分发到内部订阅者，将事件消息保存到事件库（表），再异步发送到消息中间件。</p><h4 id="4-消息中间件"><a href="#4-消息中间件" class="headerlink" title="4. 消息中间件"></a>4. 消息中间件</h4><p>跨微服务的领域事件大多会用到消息中间件，实现跨微服务的事件发布和订阅。消息中间件的产品非常成熟，市场上可选的技术也非常多，比如 Kafka，RabbitMQ 等。</p><h4 id="5-事件接收和处理"><a href="#5-事件接收和处理" class="headerlink" title="5. 事件接收和处理"></a>5. 事件接收和处理</h4><p>微服务订阅方在应用层采用监听机制，接收消息队列中的事件数据，完成事件数据的持久化后，就可以开始进一步的业务处理。领域事件处理可在领域服务中实现。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>在 DDD 中，实体和值对象是很基础的领域对象。实体一般对应业务对象，它具有业务属性和业务行为；而值对象主要是属性集合，对实体的状态和特征进行描述。但实体和值对象都只是个体化的对象，它们的行为表现出来的是个体的能力。</p><h4 id="聚合的作用"><a href="#聚合的作用" class="headerlink" title="聚合的作用"></a>聚合的作用</h4><p>社会是由一个个的个体组成的，象征着我们每一个人。随着社会的发展，慢慢出现了社团、机构、部门等组织，我们开始从个人变成了组织的一员，大家可以协同一致的工作，朝着一个最大的目标前进，发挥出更大的力量。</p><p><strong>领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。</strong></p><p><strong>也可以这么理解，聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。</strong></p><p>聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。</p><p>按照这种方式设计出来的微服务很自然就是“高内聚、低耦合”的。聚合在 DDD 分层架构里属于领域层，领域层包含了多个聚合，共同实现核心业务逻辑。</p><h4 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h4><p>聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。</p><p>传统数据模型中的每一个实体都是对等的，如果任由实体进行无控制地调用和数据修改，很可能会导致实体之间数据逻辑的不一致。而如果采用锁的方式则会增加软件的复杂度，也会降低系统的性能。<strong>如果把聚合比作组织，那聚合根就是这个组织的负责人。</strong></p><p>聚合根也称为根实体，它不仅是实体，还是聚合的管理者。首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑。其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。</p><p>最后在聚合之间，它还是聚合对外的接口人，以聚合根 ID 关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根 ID 关联引用，如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体。</p><h4 id="聚合的一些设计原则"><a href="#聚合的一些设计原则" class="headerlink" title="聚合的一些设计原则"></a>聚合的一些设计原则</h4><ol><li>在一致性边界内建模真正的不变条件。聚合用来封装真正的不变性，而不是简单地将对象组合在一起。聚合内有一套不变的业务规则，各实体和值对象按照统一的业务规则运行，实现对象数据的一致性，边界之外的任何东西都与该聚合无关，这就是聚合能实现业务高内聚的原因。</li><li>设计小聚合。如果聚合设计得过大，聚合会因为包含过多的实体，导致实体之间的管理过于复杂，高频操作时会出现并发冲突或者数据库锁，最终导致系统可用性变差。而小聚合设计则可以降低由于业务过大导致聚合重构的可能性，让领域模型更能适应业务的变化。</li><li>通过唯一标识引用其它聚合。聚合之间是通过关联外部聚合根 ID 的方式引用，而不是直接对象引用的方式。外部聚合的对象放在聚合边界内管理，容易导致聚合的边界不清晰，也会增加聚合之间的耦合度。</li><li>在边界之外使用最终一致性。聚合内数据强一致性，而聚合之间数据最终一致性。在一次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应采用领域事件的方式异步修改相关的聚合，实现聚合之间的解耦（相关内容我会在领域事件部分详解）。</li><li>通过应用层实现跨聚合的服务调用。为实现微服务内聚合之间的解耦，以及未来以聚合为单位的微服务组合和拆分，应避免跨聚合的领域服务调用和跨聚合的数据库表关联。</li></ol><h4 id="聚合和聚合根有什么不同"><a href="#聚合和聚合根有什么不同" class="headerlink" title="聚合和聚合根有什么不同"></a>聚合和聚合根有什么不同</h4><p>如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。</p><p>在DDD的领域模型中聚合是一个逻辑边界概念，聚合本身没有业务逻辑实现相关的代码。聚合的业务逻辑是由聚合内的聚合根、实体、值对象和领域服务等来实现的。聚合没有ID，它不是实体，所以它没有class，就跟企业里面的部门一样，它只是一个组织名称上的概念，在部门内部的人员才是实体，部门内的若干人员一起构成聚合。每个聚合内有一个聚合根，多个实体、值对象和领域服务等领域对象，它们共同完成聚合的业务逻辑。</p><p>参考引用：</p><blockquote><p>【1】 《实现领域驱动设计》 弗农</p><p>【2】 《DDD实战课》极客时间系列文章</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/DDD/">DDD</category>
      
      
      
      <comments>http://hznu.asia/2022/09/23/DDD%E5%88%9D%E6%8E%A2(2)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NotSingle项目关于&#39;动态&#39;模块设计的一些思考</title>
      <link>http://hznu.asia/2022/09/13/NotSingle%E9%A1%B9%E7%9B%AE%E5%85%B3%E4%BA%8E&#39;%E5%8A%A8%E6%80%81&#39;%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</link>
      <guid>http://hznu.asia/2022/09/13/NotSingle%E9%A1%B9%E7%9B%AE%E5%85%B3%E4%BA%8E&#39;%E5%8A%A8%E6%80%81&#39;%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</guid>
      <pubDate>Tue, 13 Sep 2022 09:09:52 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;NotSingle项目已经做了挺久了，但是好像还没有好好介绍一下。&lt;/p&gt;
&lt;p&gt;NotSingle是一个我一直在利用空闲时间推进的在线交友</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>NotSingle项目已经做了挺久了，但是好像还没有好好介绍一下。</p><p>NotSingle是一个我一直在利用空闲时间推进的在线交友平台，分为后台管理端和用户端。目前一直在推进的一直是用户端，目前前端后台都是自己一个人在做的，所以开发周期拉的比较长。</p><h4 id="为什么选择做这个类型的项目"><a href="#为什么选择做这个类型的项目" class="headerlink" title="为什么选择做这个类型的项目"></a>为什么选择做这个类型的项目</h4><p>首先，从大三开始就一直做的是后台管理类的项目，差不多就是“能跑就行”的开发状态，并没有经历太多性能方面的考虑需求。而这个平台在用户端，则需要大量考虑这方面的需求。因此相对来说，具有一定的挑战性。</p><h4 id="前端技术选型"><a href="#前端技术选型" class="headerlink" title="前端技术选型"></a>前端技术选型</h4><p>用户端前端技术选型主要就是<code>Vue</code>、<code>uniapp</code>、<code>uview</code>等框架。选择这些技术，一方面是因为这些都是我比较熟悉的技术，另一方面，考虑到后期可能各种因素变动，可能会选择做成<code>h5</code>、<code>微信小程序</code>等等，而<code>uview</code>可以很方便进行打包。</p><p>后台管理员技术选型和用户端一样，也是使用<code>Vue</code>，只是选择了<code>elementui</code>作为开发组件库。</p><h4 id="后端技术选型"><a href="#后端技术选型" class="headerlink" title="后端技术选型"></a>后端技术选型</h4><p>目前做的一版并不是微服务的，后期会进行拆分再做一版，并进行性能优化，目前在兼顾一些简单性能的基础上，先把功能做出来。为什么这样做呢？因为我想根据压测结果，能够清晰看到优化后的测试结果，进行对比，更能对性能优化有一个清晰直观的认识。</p><p>简单介绍之后就改步入正题了！</p><h2 id="“动态”模块设计"><a href="#“动态”模块设计" class="headerlink" title="“动态”模块设计"></a>“动态”模块设计</h2><p>因为这里看文字可能会有歧义，因此先简单介绍下。</p><p>“动态”模块，类似于发微博。也许后期会取一个好听点或者个性一点的名字，比如：唠唠…这里暂时称为动态吧。这个模块主要功能是：用户发布动态、查看他人动态、编辑动态（如有必要）、删除动态、点赞动态、评论动态。看上去功能不多是吧？但是经过思考后，发现要注意的地方还是不少的，我总结出一下值得思考的问题。</p><p>虽然看过《实现领域驱动设计》，认为最好不以数据库设计为导向去做项目，但毕竟真正完全按书中所说去做还是有难度的。目前对书中提到内容后期也会做业务领域的限界上下文划分，目前主要还是以功能实现、性能优化、简单系统设计解耦为主。因此后面讲到的内容，也会以这方面考虑为导向。</p><h4 id="点赞数据该不该存？怎么存？"><a href="#点赞数据该不该存？怎么存？" class="headerlink" title="点赞数据该不该存？怎么存？"></a>点赞数据该不该存？怎么存？</h4><p>点赞数据，如果存的话，数据量过大，所以这个数据不将点赞人和被点赞人数据存进数据库，只存储每条动态点赞条数。而如果每有一个用户点赞一次便存进数据库的话，数据库肯定是撑不住的。因此引入Redis缓存，整体策略如下：</p><ol><li>每次点赞时先查缓存中有没有，没有的话从数据库拉出来，并加1，若有直接加1；</li><li>每隔一段时间将点赞数据存储数据库；</li><li>每条动态失效时间为3天，即三天内没有人点赞，便将该条缓存数据失效，并在失效前存入数据库</li></ol><h4 id="评论数据表怎么设计好？"><a href="#评论数据表怎么设计好？" class="headerlink" title="评论数据表怎么设计好？"></a>评论数据表怎么设计好？</h4><p>评论数据表，正常来讲，就是存id、评论对应的动态id、评论者的用户id、评论的内容、评论的时间。但是，还有一点需要考虑，用户评论时，分为<strong>评论该条动态</strong>以及<strong>回复该条动态底下的评论</strong>。因此，该表需要再加入一个区分这两种类型的字段，这里目前是准备用<code>-1</code>标识<strong>对该条动态的评论</strong>，而对于回复的评论，则存回复的评论id。</p><h2 id="动态拉取如何设计"><a href="#动态拉取如何设计" class="headerlink" title="动态拉取如何设计"></a>动态拉取如何设计</h2><p>对于动态拉取设计是单独作为一个小节来介绍的，因为这块需要探讨的东西也很多，并且也有很多我需要去学习的地方。<strong>在设计前，首先要明确一个原则，设计没有好坏，对于我的系统来说，够用就好！</strong></p><h4 id="数据量分析"><a href="#数据量分析" class="headerlink" title="数据量分析"></a>数据量分析</h4><p>因为暂时只准备在一个学校进行推广，学校人数往上估计不会超过5w人，假设所有人都注册并使用该系统，MAU（月活）假设为1w（往高一点去设计），<strong>MAU（月活） 与 DAU（日活）的数量根据经验值约是两倍关系</strong>，那么DAU大概就是5k。</p><p>假设用户每天平均请求的次数为 100 次，<strong>可计算出平均每秒并发访问量约为：(5000*100)/(60 * 60 * 24) 约等于58qps</strong>，而通常每日访问的峰值大约在平均每秒并发访问量的 2~9 倍，因此，<strong>访问峰值的数值大概在 100qps ~ 540qps之间。</strong></p><p>有了这些数据，我们的系统则至少要满足以上需求，同时也要兼顾可扩展性要求。</p><h4 id="动态浏览有哪些需要关注的点"><a href="#动态浏览有哪些需要关注的点" class="headerlink" title="动态浏览有哪些需要关注的点"></a>动态浏览有哪些需要关注的点</h4><p>当你打开动态：</p><ul><li>打开动态页面，浏览自己关注的用户发布了哪些新内容</li><li>打开某特定用户的时间轴，浏览该用户发布的内容</li><li>查看推荐浏览的动态</li></ul><p>因此需要聚焦信息流和时间线的<strong>数据存储</strong>和<strong>数据访问</strong>，来权衡设计。</p><h4 id="拉模型"><a href="#拉模型" class="headerlink" title="拉模型"></a>拉模型</h4><h5 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h5><p>动态模块，分为三种动态：关注、推荐和同校。顾名思义，分别为关注的人的动态，推荐的动态和同校的动态。如果采取拉模型的话，那么以上三种动态就需要这样来做：</p><ol><li>对于关注的人的动态，需要现在关注表查出用户所有关注的人，再根据这些人的id去动态表去查，查完后要根据时间排序，再返回。</li><li>对于推荐的动态，由于推荐系统目前来看工作量这块较为庞大，后期会引入。因此暂时就从动态列表拉出新发布的数据。</li><li>对于同校的动态，其实就是在同校里面筛选了。</li></ol><p>我们重点看“关注”的动态，若采取主动型的模型。<strong>当你打开动态，查看自己的订阅的动态（其实就是关注的用户发的动态）时，系统会做以下几件事</strong>：</p><p><strong>1. 先去取出你所关注的的用户列表，</strong></p><p><strong>2. 分别把这些你所关注的的用户的时间线上的动态取出来，</strong></p><p><strong>3. 按时间执行归并排序，返回给你所需要的动态订阅。</strong></p><p><img src="https://img.hznu.asia/blog/%E5%8A%A8%E6%80%81%E6%8B%89%E6%A8%A1%E5%9E%8B%E8%BF%87%E7%A8%8B%E5%9B%BE.png"></p><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>假设该用户关注了 N 个用户，每个用户拉20条动态，那么时间复杂度就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20*N次DB读 + N路归并 = 20*N次DB访问 + 20log(N)内存处理</span><br></pre></td></tr></table></figure><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><p>经过上面分析，缺陷显而易见。<strong>当用户想拉取自己订阅的动态时，需执行较多DB操作，用户需等待这一系列 DB 操作以及归并执行完成，系统才会将所有动态返给客户端显示，对于用户就得等待较长时间。</strong></p><h4 id="推模型"><a href="#推模型" class="headerlink" title="推模型"></a>推模型</h4><h5 id="流程分析-1"><a href="#流程分析-1" class="headerlink" title="流程分析"></a>流程分析</h5><p>对于动态拉模型，同样分三个类型：</p><ol><li>对于关注的人的动态，使用观察者模式，每个用户维护数组，即在用户发布动态时便推送给关注的人，用户查数据也就是根据这个容器去查。</li><li>对于推荐的动态，就是直接查询动态表的数据。这里不用考虑脏读等等。</li><li>对于同校的动态，与第二种同理。</li></ol><p>当用户打开动态时，系统会做以下几件事：</p><ol><li>在系统启动时，为每个用户建立一个存储他人动态的列表，列表中只包含他所关注的用户发布的动态</li><li>当某个用户发布动态后，会将动态推送至关注了他的所有人维护的动态列表</li><li>当用户需要查看自己订阅的动态列表时，只需按时间顺序，从该动态列表中取出</li></ol><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h5><p>当用户在刷新自己订阅的动态列表时，只需1次DB读取。</p><p>当用户发一条动态，若该用户被 N 个用户关注，则需执行 N 次 DB 写入。</p><h5 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h5><p><strong>浪费DB空间：</strong>需要给每个用户维护一个动态表，浪费内存或DB。<br><strong>动态更新可能会不及时：</strong>如一个热门用户有1000粉丝，整个推送的过程可能要持续相当一段时间，有些粉丝可能已经收到这个用户发布的动态，但是有的粉丝可能5分钟后才收到，影响用户体验。</p><h4 id="利弊对比："><a href="#利弊对比：" class="headerlink" title="利弊对比："></a>利弊对比：</h4><table><thead><tr><th>模型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>pull模型</td><td>1. 实现简单<br>2.易于扩展</td><td>1. 数据量大拉动态较耗时</td></tr><tr><td>push模型</td><td>1. 拉取动态时更快</td><td>1. 需要更多空间<br>2. 不活跃用户会占用大量资源<br>3.动态推送有些快有些慢，不及时</td></tr></tbody></table><h2 id="分别优化"><a href="#分别优化" class="headerlink" title="分别优化"></a>分别优化</h2><p>上面对两种模型进行了分析，并比较了两种模型的优缺点，那么应该选用哪种模型呢？我觉得仅凭上面的分析还不能下定义，因为上面的其实还是有一定的优化空间的，我们先分别对两种模型进行优化，再来比较看看。</p><h4 id="推模型优化"><a href="#推模型优化" class="headerlink" title="推模型优化"></a>推模型优化</h4><p>对于推模型，由于发布动态后后处理消息有时间延迟。导致用户有可能在自己所关注的用户发布动态一段时间后，才能够在自己的动态列表里刷到该条消息。可采用一定方案提升用户体验，在消息分发时，先对粉丝按规则排序，如按用户活跃度（按最新登录系统时间排序），针对活跃度越高用户，优先进行推送，能在一定程度上缓解以上痛点。</p><h4 id="拉模型优化"><a href="#拉模型优化" class="headerlink" title="拉模型优化"></a>拉模型优化</h4><p>对于拉模型，一个比较有效的方法就是减少数据库操作，那么此时必然就要引入缓存了。</p><p>Pull 模型系统瓶颈在于用户请求动态列表时，且这一过程需消耗用户等待时间。可在访问DB前加个缓存层，若缓存命中，直接将数据返给用户，大大缩减用户等待时间。</p><p><strong>加个缓存其实不难，需要思考的事，加完缓存之后有什么需要考虑？</strong></p><p>首先我们来分析下，缓存怎么起作用？加入缓存后，拉取动态列表时，就仅需一次 Cache 访问：</p><ul><li>根据我们之前拉取20条的策略，无缓存动态列表的用户，归并 N 个关注好友的最新 20 条动态，取出前 20 条放入缓存，并返回给用户。后面查询时，若已做缓存，直接返回。</li><li>已做缓存的用户，归并 N 个用户在某个时间之后的所有动态，加入缓存</li></ul><p><strong>注意上面，缓存是每个用户的动态列表（前20条），并不是每个用户查出来的所有关注用户的20条动态列表。</strong></p><p><strong>这时候，其实要考虑的问题很多。</strong></p><p>假如采用拉模型+缓存，当一个用户拉取所有他关注的人的前20条动态时，缓存没有的话查库并加到缓存，缓存有直接返回。为了方便理解，我们举个例子。</p><p>一个用户关注了10个人，这时候我们获取到这10个人的id，根据个人id去动态表查询他发布了哪些动态。这时候就需要遍历这20个人，每次去查这个人的信息时，先去缓存中查询是否有这个人的动态，如果没有的话就查库，有的话就返回缓存中的信息。</p><p>那么，此时又有一个问题，假如现在用户阅读完了缓存中的所有数据，这时候再请求又要查库了吧，在查库前，又有新的用户更新了动态，这时候查的不能简单查每个用户再后面20条动态了，还要把新发布的加上。</p><p>这部分数据介于之前查出的20条之前面和后面，那么这时候，你就需要知道上次查库的时间了吧，这样才知道目前缓存中的数据是在哪个时间之后的20条数据</p><h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p>关于如何选择，我认为要结合系统需求来看。因为在项目上线时，虽然仅仅只针对一个学校的用户。假如采用push模型时，相对来说对存储空间需求也是大了一些的，毕竟假如上线后，服务器等等都是自掏腰包。选择pull模型最为经济省力，所以我选择pull模型。</p><h4 id="动态发布时需要做什么"><a href="#动态发布时需要做什么" class="headerlink" title="动态发布时需要做什么"></a>动态发布时需要做什么</h4><p>如果采用拉模型的话，在动态发布时，是需要额外执行往缓存中添加数据的操作的。因为如果采用拉模型的话，我们逻辑是这样的：先从缓存中按发布时间查询出某个人的前10条动态信息，若缓存中没有，则从数据库中查询，若缓存中有，则查缓存中的信息。</p><p>问题就在这里了，假如缓存中数据还没有失效，那么我们查询的就是缓存的信息，假如在我们查之前，该用户发布了一条动态，进入的数据库，而此时缓存中便没有。因此，我们在发布信息时，要同步去查询缓存中是否有该用户的信息，假如有的话，那么就要将缓存中的信息取出来，加入新发布的动态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看似较为简单的模块其实要考虑的东西还是很多的，由于之前这方面经验较少，因此肯定还是有遗漏或考虑不完善的地方，后期有想到会继续补充。</p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/NotSingle/">NotSingle</category>
      
      
      <category domain="http://hznu.asia/tags/NotSingle/">NotSingle</category>
      
      
      <comments>http://hznu.asia/2022/09/13/NotSingle%E9%A1%B9%E7%9B%AE%E5%85%B3%E4%BA%8E&#39;%E5%8A%A8%E6%80%81&#39;%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入理解SpringIOC</title>
      <link>http://hznu.asia/2022/08/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringIOC/</link>
      <guid>http://hznu.asia/2022/08/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringIOC/</guid>
      <pubDate>Thu, 25 Aug 2022 07:03:26 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;从三年前就开始接触了Spring，当时也是看着视频教程一步步跟着写，也体会不到具体有什么用处。&lt;/p&gt;
&lt;p&gt;直到接触了第一个项目，使用了Spring，大致了解他是做什么的，后面做的项目多了，也对有了一定的理解，可以进行简单的描述。&lt;/p&gt;
&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>从三年前就开始接触了Spring，当时也是看着视频教程一步步跟着写，也体会不到具体有什么用处。</p><p>直到接触了第一个项目，使用了Spring，大致了解他是做什么的，后面做的项目多了，也对有了一定的理解，可以进行简单的描述。</p><p>再后面，读了Spring官网的文档后，对其整体也有了一个简单的认知，也做过一些简单的摘录，但是感觉并没有经过自己思考进行一次真正的总结。</p><p>现在，在读过一些<code>DDD</code>和面向对象的书后，便开始对Spring做一个整体的总结。从两大核心<code>IOC</code>和<code>AOP</code>入手，结合一些我认为通俗易懂的例子，探讨一下为什么要使用Spring，看看是否会有不一样的发现。</p></blockquote><h2 id="一-为什么需要Spring-IOC"><a href="#一-为什么需要Spring-IOC" class="headerlink" title="一. 为什么需要Spring IOC"></a>一. 为什么需要Spring IOC</h2><h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h3><h4 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h4><p>假如，现在有一个新闻播报系统，需要从新闻社获取新闻源，来实现新闻播报。我们用一个<code>NewsProvider</code>类来做以上工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class NewsProvider&#123;</span><br><span class="line">    private INewsListener newsListener; // 抓取新闻内容</span><br><span class="line">    private INewsPersister newPersistener; // 存储抓取的新闻</span><br><span class="line">    public void getAndPersistNews()&#123;</span><br><span class="line">    String[] newsIds = newsListener.getAvailableNewsIds();</span><br><span class="line">    if(ArrayUtils.isEmpty(newsIds))&#123;</span><br><span class="line">    return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(String newsId : newsIds)&#123;</span><br><span class="line">            NewsBean newsBean = newsListener.getNewsByPK(newsId); </span><br><span class="line">            newPersistener.persistNews(newsBean);</span><br><span class="line">            newsListener.postProcessIfNecessary(newsId);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>其中，<code>NewsProvider</code>需要依赖<code>INewsListener</code>来帮助抓取新闻内容，并依赖<code>INewsPersister</code>存储抓取的新闻。</p><p>假如我们默认使用A新闻社的新闻，那么我们相应地提供了<code>ANewsListener</code>和<code>ANewsPersister</code>两个实现，通常情况下，需要在构造函数中构造<code>INewsProvider </code>依赖的这两个类（使用setter也是可以的，为了方便书写和看懂，使用构造方法注入）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public NewsProvider() &#123;</span><br><span class="line"> newsListener = new ANewsListener();</span><br><span class="line">newPersistener = new ANewsPersister();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，此时<code>NewsProvider</code>类如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class NewsProvider&#123;</span><br><span class="line">    private INewsListener newsListener; // 抓取新闻内容</span><br><span class="line">    private INewsPersister newPersistener; // 存储抓取的新闻</span><br><span class="line">    </span><br><span class="line">    public NewsProvider() &#123;</span><br><span class="line">        newsListener = new ANewsListener();</span><br><span class="line">        newPersistener = new ANewsPersister();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void getAndPersistNews()&#123;</span><br><span class="line">    String[] newsIds = newsListener.getAvailableNewsIds();</span><br><span class="line">    if(ArrayUtils.isEmpty(newsIds))&#123;</span><br><span class="line">    return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(String newsId : newsIds)&#123;</span><br><span class="line">            NewsBean newsBean = newsListener.getNewsByPK(newsId); </span><br><span class="line">            newPersistener.persistNews(newsBean);</span><br><span class="line">            newsListener.postProcessIfNecessary(newsId);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>在<code>Spring IoC</code>的理念出现之前，就是这样做的。被注入对象（<code>NewsProvider</code>）会直接依赖于被依赖对象（<code>ANewsListener</code>和<code>ANewsPersister</code>）。</p><p>但是，在<code>IoC</code>的场景中，二者之间通过<code>IoC Service Provider</code>来打交道，所有的被注入对象和依赖对象现在由<code>IoC Service Provider</code>统一管理。</p><p>被注入对象需要 什么，直接跟<code>IoC Service Provider</code>招呼一声，后者就会把相应的被依赖对象注入到被注入对象中，从而达到<code>IoC Service Provider</code>为被注入对象服务的目的。</p><p><code>IoC Service Provider</code>在这里就是通常的<code>IoC</code>容器所充当的角色。</p><p><strong>从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转， 控制也从被注入对象转到了<code>IoC Service Provider</code>那里。</strong></p><h4 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h4><p>对于前面例子中的<code>NewsProvider</code>来说，在使用<code>IoC</code>之前，如果没有其他需求或变动，用起来是没有问题的。但是，当系统中新增另一家新闻社的新闻来源时， 问题就来了。</p><p>假如我们新增了一家名为B的新闻社获取新闻来源，这个时候，你该如何处理呢？</p><p>首先，毫无疑问地，应该先根据B新闻社的服务 接口提供一个<code>BNewsListener</code>实现，用来接收新闻；其次，因为都是相同的数据访问逻辑， 所以原来的<code>ANewsPersister</code>可以重用做持久化，我们先放在一边不管。最后，就主要是业务处理对象 <code>NewsProvider</code>了。</p><p>因为我们之前没有用<code>IoC</code>，所以，现在的对象跟<code>ANewsListener</code>是绑定的，我们无法重用这个类了。为了解决问题，我们可能要重新实现一个继承自 <code>NewsProvider</code>的<code>BNewsProvider</code>，或者干脆重新写一个类似的功能。 </p><p>而使用<code>IoC</code>后，面对同样的需求，我们却完全可以不做任何改动，就直接使用<code>NewsProvider</code>。 因为不管是A新闻社还是B新闻社，对于我们的系统来说，处理逻辑实际上应该是一样的：根据 各个公司的连接接口取得新闻，然后将取得的新闻存入数据库。因此，我们只要根据B的新闻服务接口，为B的<code>NewsProvider</code>提供相应的<code>BNewsListener</code>注入就可以了，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NewsProvider aNewsProvider = new NewsProvider(new ANewsListener(),new ANewsPersister());</span><br><span class="line">NewsPrivider bNewsProvider = new NewsProvider(new BNewsListener(),new BNewsPersister());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class NewsProvider&#123;</span><br><span class="line">    private INewsListener newsListener; // 抓取新闻内容</span><br><span class="line">    private INewsPersister newPersistener; // 存储抓取的新闻</span><br><span class="line">    </span><br><span class="line">    public NewsProvider(INewsListener newsListener, INewsPersister newPersistener) &#123;</span><br><span class="line">        this.newsListener = newsListener;</span><br><span class="line">        this.newPersistener = newPersistener;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void getAndPersistNews()&#123;</span><br><span class="line">    ....</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>其实，这就是<code>NewsProvider</code>依赖方向的转变，也是从主动获取到被动接收的转变。原来<code>NewsProvider</code>直接依赖于具体的<code>ANewsListener</code>和<code>ANewsPersister</code>，通俗讲，从前是主动去 new 自己需要的对象，现在则是通过构造器被动的接收传递进来的对象，使得<code>NewsProvider</code>大大增强了可重用性。</p><h3 id="IoC-Service-Provider"><a href="#IoC-Service-Provider" class="headerlink" title="IoC Service Provider"></a>IoC Service Provider</h3><p>在上一节，我们有提到<code>IoC Service Provider</code>这个词，尽管这个词看到遍很容易猜到是做什么的，但是还是有必要讲解下。因为他涉及到理解<code>IoC</code>如何管理对象间的依赖关系。</p><p>虽然业务对象可以通过<code>IoC</code>方式声明相应的依赖，但是最终仍然需要通过某种角色或者服务将这些相互依赖的对象绑定到一起，而<code>IoC Service Provider</code>就对应<code>IoC</code>场景中的这一角色。</p><p> <code>IoC Service Provider</code>在这里是一个抽象出来的概念，它可以指代任何将<code>IoC</code>场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的<code>IoC</code>框架或 者<code>IoC</code>容器实现。比如，可以通过以下代码绑定与新闻相关的对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INewsListener newsListener = new ANewsListener(); </span><br><span class="line">INewsPersister newsPersister = new ANewsPersister();</span><br><span class="line">NewsProvider newsProvider = new NewsProvider(newsListener,newsPersister); newsProvider.getAndPersistNews();</span><br></pre></td></tr></table></figure><p> 这段代码就可以认为是这个场景中的<code>IoC Service Provider</code>，他将<code>ANewsListener</code>和<code>ANewsPersister</code>绑定到了一起，只不过这段代码比较简单，而且目的也过于单一罢了。</p><p>要将系统中几十、几百甚至数以千计的业务对象绑定到一起，采用这种方式显然是不切实际的。 通用性暂且不提，单单是写这些绑定代码看起来也很丑陋。</p><p>但是，现在许多开源产品通过各种方式为我们做了这部分工作。所以，目前来看，我们只需要使用这些产品提供的服务就可以了。Spring 的<code>IoC</code>容器就是一个典型的提供依赖注入服务的<code>IoC Service Provider</code>。</p><h5 id="IoC-Service-Provider的职责"><a href="#IoC-Service-Provider的职责" class="headerlink" title="IoC Service Provider的职责"></a>IoC Service Provider的职责</h5><p><code>IoC Service Provider</code>的职责相对来说比较简单，主要有两个：<strong>业务对象的构建管理和业务对象间的依赖绑定。</strong></p><ul><li><strong>业务对象的构建管理。</strong>在<code>IoC</code>场景中，业务对象无需关心所依赖的对象如何构建如何取得，但这部分工作始终需要有人来做。所以，<code>IoC Service Provider</code>需要将对象的构建逻辑从客户端对象（客户端是相对而言，比如A依赖于B，那么A此时就是客户端对象）那里剥离出来，以免这部分逻辑污染业务对象的实现。</li><li><strong>业务对象间的依赖绑定。</strong>对于<code>IoC Service Provider</code>来说，这个职责是最难以实现的，同时也是最重要的。<code>IoC Service Provider</code>通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系。</li></ul><h5 id="如何管理对象间的依赖关系"><a href="#如何管理对象间的依赖关系" class="headerlink" title="如何管理对象间的依赖关系"></a>如何管理对象间的依赖关系</h5><p>有了<code>IoC Service Provider</code>前面的简单的创建功能，此时，则需要记录创建的对象之间的对应关系。记录的方式也有许多种：比如：</p><ul><li>可以通过最基本的文本文件来记录被注入对象和其依赖对象之间的对应关系；</li><li>也可以通过描述性较强的XML文件格式来记录对应信息； </li><li>还可以通过编写代码的方式来注册这些对应信息；</li></ul><p>实际上，当前流行的<code>IoC Service Provider</code>产品使用的注册对象管理信息的方式主要有以下几种：</p><ol><li><p><strong>编码方式</strong></p><p>这种方式顾名思义，直接在代码中，管理对象间的依赖注入关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IoContainer container = ...;</span><br><span class="line">container.register(NewsProvider.class,new NewsProvider());</span><br><span class="line">container.register(INewsListener.class,new DowJonesNewsListener());</span><br><span class="line">...</span><br><span class="line">NewsProvider newsProvider = (NewsProvider)container.get(NewsProvider.class);</span><br><span class="line">newProvider.getAndPersistNews(); </span><br></pre></td></tr></table></figure></li><li><p><strong>配置文件方式</strong></p></li></ol><p>这种方式在Spring中也是很常见的，比如在xml文件中管理Bean对象等等。</p><ol start="3"><li><strong>元数据方式</strong></li></ol><p>这种方式，我们一般现在称为<code>注解</code>。</p><h2 id="二-IoC之BeanFactory"><a href="#二-IoC之BeanFactory" class="headerlink" title="二. IoC之BeanFactory"></a>二. IoC之BeanFactory</h2><p>在上一节，我们提到了<code>IoC Service Provider</code>，Spring的IoC容器就是一个<code>IoC Service Provider</code>，但是，这只是它被冠以IoC之名的部分原因。</p><p>Spring的IoC容器是一个提供IoC支持的轻量级容器，除了基本的IoC支持，它作为轻量级容器还提供了IoC之外的支持。如在Spring的IoC容器之上，Spring还提供了 相应的AOP框架支持、企业级服务集成等服务。Spring的IoC容器和<code>IoC Service Provider</code>所提供的服务之间存在一定的交集，二者关系如下图所示：</p><p><img src="https://img.hznu.asia/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringIOC/Spring%E7%9A%84IoC%E5%AE%B9%E5%99%A8%E5%92%8CIoC%20Service%20Provider%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><h4 id="Spring的两种容器："><a href="#Spring的两种容器：" class="headerlink" title="Spring的两种容器："></a>Spring的两种容器：</h4><p>Spring提供了两种容器类型：<code>BeanFactory</code>和<code>ApplicationContext</code>。 </p><p><code>BeanFactory</code>: 基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，<strong>默认采用延迟初始化策略（lazy-load）</strong>。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的 IoC 容器选择。 </p><p><code>ApplicationContext</code>: <strong>ApplicationContext在BeanFactory的基础上构建</strong>，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持。<strong>ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。</strong>在那些系统资源充足，并且要求更多功能的场景中， ApplicationContext类型的容器是比较合适的选择。</p><p>下图是BeanFactory和ApplicationContext继承关系，从图中可以看到，ApplicationContext除了间接继承了BeanFactory外，还继承了<code>ApplicationEventPublisher</code>和<code>ResourceLoader</code>，即事件发布和资源加载，后面还会详细讲到。</p><p><img src="https://img.hznu.asia/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringIOC/BeanFactory%E5%92%8CApplicationContext%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png"></p><h4 id="简单理解BeanFactory："><a href="#简单理解BeanFactory：" class="headerlink" title="简单理解BeanFactory："></a>简单理解BeanFactory：</h4><p>BeanFactory，顾名思义，就是生产Bean的工厂。当然，严格来说，这个“生产过程”可能不像 说起来那么简单。既然Spring框架提倡使用POJO，那么把每个业务对象看作一个JavaBean对象，或许更容易理解为什么Spring的IoC基本容器会起这么一个名字。</p><p>作为Spring提供的基本的IoC容器， BeanFactory可以完成作为IoC Service Provider的所有职责，包括业务对象的注册和对象间依赖关系的绑定。 所以，对于客户端来说，与BeanFactory交互其实很简单。</p><p>我们来看下<strong>BeanFactory接口</strong>里的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactory &#123;</span><br><span class="line">    String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class="line"></span><br><span class="line">    Object getBean(String var1) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; var1);</span><br><span class="line"></span><br><span class="line">    boolean containsBean(String var1);</span><br><span class="line"></span><br><span class="line">    boolean isSingleton(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    boolean isPrototype(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    boolean isTypeMatch(String var1, Class&lt;?&gt; var2) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    Class&lt;?&gt; getType(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    String[] getAliases(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的源码之列出其中一部分能说明问题的代码，上面代码中的方法基本上都是查询相关的方法，例如，取得某个对象的方法（<code>getBean</code>）、查询某个对象是否存在于容器中的方法（<code>containsBean</code>），或者取得某个bean的状态或者类型的方法等。 因为通常情况下，对于独立的应用程序，只有主入口类才会跟容器的API直接耦合。</p><h4 id="有了BeanFactory后，有什么不一样"><a href="#有了BeanFactory后，有什么不一样" class="headerlink" title="有了BeanFactory后，有什么不一样"></a>有了BeanFactory后，有什么不一样</h4><p>我们继续接着上面的新闻社的例子来看，在BeanFactory出现之前，我们通常会直接在应用程序的入口类的main方法中，自己实例化相应的对象并调用之，如以下代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NewsProvider newsProvider = new NewsProvider(); </span><br><span class="line">newsProvider.getAndPersistNews(); </span><br></pre></td></tr></table></figure><p>这样，所有的这些Bean都将在程序中，并且由开发者来管理他们之间的关联关系，一旦Bean多起来，耦合将杂乱无章，假如我们使用了BeanFactory，我们可以在XML中配置或者使用注解把他们交给IoC管理，我们这里为了方便看，使用XML文件来说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;ANewsProvider&quot; class=&quot;..NewsProvider&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;0&quot;&gt;</span><br><span class="line">        &lt;ref bean=&quot;ANewsListener&quot;/&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;1&quot;&gt; 9</span><br><span class="line">        &lt;ref bean=&quot;ANewsPersister&quot;/&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"> ...</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>将他们注册到IoC容器并配置好了他们的关联关系之后，便可以加载配置文件路径并调用了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory container = new XmlBeanFactory(new ClassPathResource(&quot;上面配置文件路径&quot;));</span><br><span class="line">NewsProvider newsProvider = (NewsProvider)container.getBean(&quot;ANewsProvider&quot;);</span><br><span class="line">newsProvider.getAndPersistNews();</span><br></pre></td></tr></table></figure><p>当然，现在还有更简洁的使用注解的方式，其本质都是一样的，这里就不一一讲解。</p><h4 id="BeanFactory的对象注册与依赖绑定方式"><a href="#BeanFactory的对象注册与依赖绑定方式" class="headerlink" title="BeanFactory的对象注册与依赖绑定方式"></a>BeanFactory的对象注册与依赖绑定方式</h4><p>BeanFactory作为一个<code>IoC Service Provider</code>，为了能够明确管理各个业务对象以及业务对象之间的 依赖绑定关系，同样需要某种途径来记录和管理这些信息。</p><h4 id="代码方式实现"><a href="#代码方式实现" class="headerlink" title="代码方式实现"></a>代码方式实现</h4><p>虽然在实际操作中，不会有这种方式手动管理，但是了解这些代码可以让我们更加清楚BeanFactory在底层是如何运作的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"> DefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory();</span><br><span class="line"> BeanFactory container = (BeanFactory)bindViaCode(beanRegistry);</span><br><span class="line"> NewsProvider newsProvider = (NewsProvider)container.getBean(&quot;djNewsProvider&quot;);</span><br><span class="line"> newsProvider.getAndPersistNews();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static BeanFactory bindViaCode(BeanDefinitionRegistry registry)&#123;</span><br><span class="line">  AbstractBeanDefinition newsProvider = new RootBeanDefinition(NewsProvider.class,true);</span><br><span class="line">  AbstractBeanDefinition newsListener = new RootBeanDefinition(ANewsListener.class,true);</span><br><span class="line">  AbstractBeanDefinition newsPersister = new RootBeanDefinition(APersister.class,true);</span><br><span class="line">  // 将bean定义注册到容器中</span><br><span class="line">  registry.registerBeanDefinition(&quot;NewsProvider&quot;, newsProvider);</span><br><span class="line">  registry.registerBeanDefinition(&quot;AListener&quot;, newsListener);</span><br><span class="line">  registry.registerBeanDefinition(&quot;APersister&quot;, newsPersister);</span><br><span class="line">  // 指定依赖关系</span><br><span class="line">  // 1. 可以通过构造方法注入方式</span><br><span class="line">  ConstructorArgumentValues argValues = new ConstructorArgumentValues();</span><br><span class="line">  argValues.addIndexedArgumentValue(0, newsListener);</span><br><span class="line">  argValues.addIndexedArgumentValue(1, newsPersister);</span><br><span class="line">  newsProvider.setConstructorArgumentValues(argValues);</span><br><span class="line">  // 或者通过setter方法注入方式</span><br><span class="line">  MutablePropertyValues propertyValues = new MutablePropertyValues();</span><br><span class="line">  propertyValues.addPropertyValue(new propertyValue(&quot;newsListener&quot;,newsListener));</span><br><span class="line">  propertyValues.addPropertyValue(new PropertyValue(&quot;newPersistener&quot;,newsPersister));</span><br><span class="line">  newsProvider.setPropertyValues(propertyValues);</span><br><span class="line">  // 绑定完成</span><br><span class="line">  return (BeanFactory)registry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanFactory只是一个接口，我们最终需要一个该接口的实现来进行实际的Bean的管理。</p><p>DefaultListableBeanFactory就是这么一个比较通用的BeanFactory实现类。DefaultListableBeanFactory除了间接地实现了BeanFactory接口，还实现了BeanDefinitionRegistry接口，该接口(BeanDefinitionRegistry)才是在BeanFactory的实现中担当Bean注册管理的角色。</p><p>我们来看下<code>BeanDefinitionRegistry</code>中的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinitionRegistry extends AliasRegistry &#123;</span><br><span class="line">    void registerBeanDefinition(String var1, BeanDefinition var2) throws BeanDefinitionStoreException;</span><br><span class="line"></span><br><span class="line">    void removeBeanDefinition(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    BeanDefinition getBeanDefinition(String var1) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    boolean containsBeanDefinition(String var1);</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    int getBeanDefinitionCount();</span><br><span class="line"></span><br><span class="line">    boolean isBeanNameInUse(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从接口中方法命名其实就可以很容易看出具体是做什么用的，其实这也是好代码的一个评价标准。这些代码主要就是获取、判断或者删除<code>BeanDefinition</code>，<code>BeanDefinition</code>又是什么呢？</p><p>我们来看部分<code>BeanDefinition</code>的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line">    String SCOPE_SINGLETON = &quot;singleton&quot;;</span><br><span class="line">    String SCOPE_PROTOTYPE = &quot;prototype&quot;;</span><br><span class="line">    int ROLE_APPLICATION = 0;</span><br><span class="line">    int ROLE_SUPPORT = 1;</span><br><span class="line">    int ROLE_INFRASTRUCTURE = 2;</span><br><span class="line"></span><br><span class="line">    void setParentName(@Nullable String var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getParentName();</span><br><span class="line"></span><br><span class="line">    void setBeanClassName(@Nullable String var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getBeanClassName();</span><br><span class="line"></span><br><span class="line">    void setScope(@Nullable String var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getScope();</span><br><span class="line"></span><br><span class="line">    void setLazyInit(boolean var1);</span><br><span class="line"></span><br><span class="line">    boolean isLazyInit();</span><br><span class="line"></span><br><span class="line">    void setDependsOn(@Nullable String... var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">    void setAutowireCandidate(boolean var1);</span><br><span class="line"></span><br><span class="line">    boolean isAutowireCandidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出来，<code>BeanDefinition</code>其实就是保存了一个Bean的所有必要信息。</p><p><strong>基本上，BeanFactory接口只定义如何访问容器内管理的Bean的方法，各个BeanFactory的具体实现类负责具体Bean的注册以及管理工作。 BeanDefinitionRegistry接口定义抽象了Bean的注册逻辑。通常情况下，具体的BeanFactory实现类会实现这个接口来管理Bean的注册。</strong>它们之间的关系下图所示:</p><p><img src="https://img.hznu.asia/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringIOC/BeanFactory%E3%80%81BeanDefinitionRegistry%E4%BB%A5%E5%8F%8ADefaultListableBeanFactory%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><p>这样，我们可以总结得出<code>BeanDefinition</code>、<code>BeanFactory</code>和<code>BeanDefinitionRegistry</code>三者的关系。</p><p><strong><code>BeanFactory</code>：只是一个接口，我们最终需要一个该接口的实现来进行实际的Bean的管理，具体其他职责由具体实现类来完成，这里暂时还没有讨论到实现类。</strong></p><p><strong><code>BeanDefinition</code>：保存了一个Bean的所有必要信息，注册Bean时注入，需要时再取出来。</strong></p><p><strong><code>BeanDefinitionRegistry</code>：定义抽象了Bean的注册逻辑，获取、判断或者删除<code>BeanDefinition</code>等等。</strong></p><p>现在，我们再来梳理一下。每一个受管的对象，在容器中都会有一个BeanDefinition的实例（instance）与之相对应，该 BeanDefinition的实例负责保存对象的所有必要信息，包括其对应的对象的class类型、是否是抽象类、构造方法参数以及其他属性等。</p><p>当客户端向BeanFactory请求相应对象的时候，BeanFactory会 通过这些信息为客户端返回一个完备可用的对象实例。<code>RootBeanDefinition</code>和<code>ChildBeanDefinition</code>是BeanDefinition的两个主要实现类。</p><p>现在再来看下开头那部分代码实现：</p><p>main 方法中，首先构造一个 DefaultListableBeanFactory 作 为 BeanDefinitionRegistry，然后将其交给bindViaCode方法进行具体的对象注册和相关依赖管理，然后通过 bindViaCode返回的BeanFactory取得需要的对象，最后执行相应逻辑。在我们的实例里，就是取得NewsProvider进行新闻的处理。 </p><p>在bindViaCode方法中，首先针对相应的业务对象构造与其相对应的BeanDefinition，使用 了 RootBeanDefinition 作为 BeanDefinition 的实现类。构造完成后，将这些 BeanDefinition注册到通过方法参数传进来的BeanDefinitionRegistry中。之后，因为我们的NewsProvider是采用的构造方法注入，所以，需要通过ConstructorArgumentValues为其注入相关依赖。在这里为了同时说明setter方法注入，也同时展示了在Spring中如 何使用代码实现setter方法注入。最后，以BeanFactory的形式返回已经注册并绑定了所有相关业务对象的BeanDefinitionRegistry实例。</p><h4 id="配置文件实现"><a href="#配置文件实现" class="headerlink" title="配置文件实现"></a>配置文件实现</h4><p>配置文件具体实现方式就不进行说明，这篇文章主要还是为了了解原理。</p><h4 id="注解方式实现"><a href="#注解方式实现" class="headerlink" title="注解方式实现"></a>注解方式实现</h4><p>因为之前看代码实现可能会觉得很复杂，这里为了说明其简洁性看下注解方式实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class NewsProvider&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private INewsListener newsListener;</span><br><span class="line">    @Autowired</span><br><span class="line">    private INewsPersister newPersistener;</span><br><span class="line"></span><br><span class="line">    public NewsProvider(INewsListener newsListner,INewsPersister newsPersister)&#123;</span><br><span class="line">    this.newsListener = newsListner;</span><br><span class="line">    this.newPersistener = newsPersister;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class ANewsListener implements INewsListener&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class ANewsPersister implements INewsPersister&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="BeanFactory和FactoryBean"><a href="#BeanFactory和FactoryBean" class="headerlink" title="BeanFactory和FactoryBean"></a>BeanFactory和FactoryBean</h4><p>这是很容易混淆的两个概念，FactoryBean是Spring容器提供的一种可以扩展容器对象实例化逻辑的接口。FactoryBean，其主语是Bean，定语为Factory，也就是说，它本身与其他注册到容器的对象一样，只是一个Bean而已，只不过，这种类型的Bean本身就是生产对象的工厂 （Factory）。</p><p>其源码如下，只有三个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    T getObject() throws Exception;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    default boolean isSingleton() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>getObject()</code>方法会返回该FactoryBean“生产”的对象实例，我们需要实现该方法以给出自己 的对象实例化逻辑；其他两个方法看名字应该也能猜到，就不一一说明。</p><h5 id="为什么要FactoryBean"><a href="#为什么要FactoryBean" class="headerlink" title="为什么要FactoryBean"></a>为什么要FactoryBean</h5><p> 当某些对象的实例化过程过于烦琐，通过XML配置过于复杂，使我们宁愿使用Java代码来完成这个实例化过程的时候，或者，某些第三方库不能直接注册到Spring容器的时候，就可以实现<code>org.springframework.beans.factory.FactoryBean</code>接口，给出自己的对象实例化逻辑代码。当然，不使用FactoryBean，而像通常那样实现自定义的工厂方法类也是可以的。</p><p>这样说可能不好理解，我们来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Bean</span><br><span class="line"> */</span><br><span class="line">public class Mapper &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    public Mapper(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MapperFactoryBean implements FactoryBean&lt;Mapper&gt; &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private Mapper mapper;</span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Mapper getObject() &#123;</span><br><span class="line">        if (mapper == null) &#123;</span><br><span class="line">            mapper = new Mapper(id);</span><br><span class="line">        &#125;</span><br><span class="line">        return mapper;</span><br><span class="line">    &#125;</span><br><span class="line">     // 这里是getObjectType() 和 isSingleton() 实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;mapper&quot; class=&quot;com.wangtao.spring.bean.MapperFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class BaseTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void application() &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);</span><br><span class="line">        // 下面这句将抛出异常</span><br><span class="line">        // MapperFactoryBean mapper = context.getBean(&quot;mapper&quot;, MapperFactoryBean.class);</span><br><span class="line">        Mapper mapper = context.getBean(&quot;mapper&quot;, Mapper.class);</span><br><span class="line">        Assert.assertEquals(1, mapper.getId().intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从测试结果中得知，我们虽然配置的是<code>MapperFactoryBean</code>的实例，但是根据id拿到的是<code>getObject</code>方法创建的对象。其实在容器中创建的对象仍然是<code>MapperFactoryBean</code>的实例，只是在获取的时候会判断这个结果对象是不是派生于<code>FactoryBean</code>，如果是的话则返回<code>getObject</code>方法创建的对象，并且这个对象并不是容器初始化时创建的，而是使用<code>context.getBean()</code>方法时才创建。</p><p>如果想要获取<code>FactoryBean</code>实例，需要这样写:</p><p><code>MapperFactoryBean mapper = context.getBean(&quot;&amp;mapper&quot;, MapperFactoryBean.class)</code> ；</p><p>即在bean的名字ID前加上&amp;符号。</p><h4 id="容器功能实现的各个阶段"><a href="#容器功能实现的各个阶段" class="headerlink" title="容器功能实现的各个阶段"></a>容器功能实现的各个阶段</h4><p>Spring的IoC容器启动过程中，它会以某种方式加载Configuration Metadata（通常也就是XML格式的配置信息），然后根据这些信息绑定整个系统的对象，最终组装成 一个可用的基于轻量级容器的应用系统。 </p><p>Spring的IoC容器实现以上功能的过程，基本上可以按照类似的流程划分为两个阶段，即容器启动阶段和Bean实例化阶段，如下图所示：</p><p><img src="https://img.hznu.asia/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringIOC/%E5%AE%B9%E5%99%A8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5.png"></p><h5 id="容器启动阶段"><a href="#容器启动阶段" class="headerlink" title="容器启动阶段"></a>容器启动阶段</h5><p>容器启动伊始，首先会通过某种途径加载配置文件。</p><p>在大部分情况下，容器需要依赖某些工具类（<code>BeanDefinitionReader</code>）对加载的配置文件进行解析和分析，并将分析后的信息编组为相应BeanDefinition，最后把这些保存了bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器启动工作就完成了。</p><p>总地来说，该阶段所做的工作可以认为是准备性的，重点更加侧重于对象管理信息的收集。当然， 一些验证性或者辅助性的工作也可以在这个阶段完成。</p><h5 id="Bean实例化阶段"><a href="#Bean实例化阶段" class="headerlink" title="Bean实例化阶段"></a>Bean实例化阶段</h5><p>经过第一阶段，现在所有的bean定义信息都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中。<strong>当某个请求方通过容器的getBean方法明确地请求某个对象，或者因依赖关系容器需要隐式地调用getBean方法时，就会触发第二阶段的活动。</strong></p><p>该阶段，容器会首先检查所请求的对象之前是否已经初始化。如果没有，则会根据注册的 BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖。如果该对象实现了某些回调接口，也会根据回调接口的要求来装配它。当该对象装配完毕之后，容器会立即将其返回请求方使用。</p><h4 id="Bean的实例化与BeanWrapper"><a href="#Bean的实例化与BeanWrapper" class="headerlink" title="Bean的实例化与BeanWrapper"></a>Bean的实例化与BeanWrapper</h4><p>容器在内部实现的时候，采用“策略模式”来决定采用何种方式初始化bean实例。 通常，可以通过反射或者CGLIB动态字节码生成来初始化相应的bean实例或者动态生成其子类。</p><h5 id="Aware接口"><a href="#Aware接口" class="headerlink" title="Aware接口"></a>Aware接口</h5><p>当对象实例化完成并且相关属性以及依赖设置完成之后，Spring容器会检查当前对象实例是否实现了一系列的以Aware命名结尾的接口定义。如果是，则将这些Aware接口定义中规定的依赖注入给当前对象实例。</p><p>这些Aware接口为如下几个：</p><ul><li><code>org.springframework.beans.factory.BeanNameAware</code>。如果Spring容器检测到当前对象实例实现了该接口，会将该对象实例的bean定义对应的beanName设置到当前对象实例。 </li><li><code>org.springframework.beans.factory.BeanClassLoaderAware</code>。如果容器检测到当前对象实例实现了该接口，会将对应加载当前bean的Classloader注入当前对象实例。默认会使用加载<code>org.springframework.util.ClassUtils</code>类的Classloader。 </li><li><code>org.springframework.beans.factory.BeanFactoryAware</code>。在介绍方法注入的时候，我们提到过使用该接口以便每次获取prototype类型bean的不同实例。如果对象声明实现了 BeanFactoryAware接口，BeanFactory容器会将自身设置到当前对象实例。这样，当前对象实例就拥有了一个BeanFactory容器的引用，并且可以对这个容器内允许访问的对象按照需要进行访问。</li></ul><h2 id="三-IoC之ApplicationContext"><a href="#三-IoC之ApplicationContext" class="headerlink" title="三. IoC之ApplicationContext"></a>三. IoC之ApplicationContext</h2><p>作为Spring提供的较之BeanFactory更为先进的IoC容器实现，ApplicationContext除了拥有 BeanFactory支持的所有功能之外，还进一步扩展了基本容器的功能，包括<code>BeanFactoryPostProcessor</code>、<code>BeanPostProcessor</code>以及其他特殊类型bean的自动识别、容器启动后bean实例的自动初始化、 国际化的信息支持、容器内事件发布等。</p><h4 id="统一资源加载策略"><a href="#统一资源加载策略" class="headerlink" title="统一资源加载策略"></a>统一资源加载策略</h4><p>Spring为基本的BeanFactory类型容器提供了<code>XmlBeanFactory</code>实现。相应地，它也为ApplicationContext类型容器提供了以下几个常用的实现。 </p><ul><li><code>org.springframework.context.support.FileSystemXmlApplicationContext</code>。在默认情况下，从文件系统加载bean定义以及相关资源的ApplicationContext实现。 </li><li><code>org.springframework.context.support.ClassPathXmlApplicationContext</code>。在默认情况下，从<code>Classpath</code>加载bean定义以及相关资源的ApplicationContext实现。</li><li> <code>org.springframework.web.context.support.XmlWebApplicationContext</code>。Spring提供的用于Web应用程序的ApplicationContext实现，</li></ul><h5 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h5><p>从某些程度上来说，资源查找后返回的形式多种多样，没有一个统一的抽象。理想情况下，资源查找 完成后，返回给客户端的应该是一个统一的资源抽象接口，客户端要对资源进行什么样的处理，应该 由资源抽象接口来界定，而不应该成为资源的定位者和查找者同时要关心的事情。  所以，在这个前提下 ，Spring提出了一套基于<code>org.springframework.core.io.Resource</code>和 <code>org.springframework.core.io.ResourceLoader</code>接口的资源抽象和加载策略。</p><h5 id="Spring中的Resource"><a href="#Spring中的Resource" class="headerlink" title="Spring中的Resource"></a>Spring中的Resource</h5><p>其实这个类，如果做过本地文件上传下载之类功能的话，多少应该是有接触过的，我们来举个例子。假如我们要加载一个配置文件的话，或许我们可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;...&quot;));</span><br></pre></td></tr></table></figure><p>其中ClassPathResource就是Resource的一个特定类型的实现，代表的是位于Classpath中的资源。 Resource接口可以根据资源的不同类型，或者资源所处的不同场合，给出相应的具体实现。Spring 框架在这个理念的基础上，提供了一些实现类（可以在<code>org.springframework.core.io</code>包下找到这 些实现类）。 </p><ul><li><code>ByteArrayResource</code>。将字节（byte）数组提供的数据作为一种资源进行封装，如果通过 InputStream形式访问该类型的资源，该实现会根据字节数组的数据，构造相应的ByteArrayInputStream并返回。 </li><li><code>ClassPathResource</code>。该实现从Java应用程序的ClassPath中加载具体资源并进行封装，可以使用指定的类加载器（ClassLoader）或者给定的类进行资源加载。 </li><li><code>FileSystemResource</code>。对<code>java.io.File</code>类型的封装，所以，我们可以以文件或者URL的形 式对该类型资源进行访问，只要能跟File打的交道，基本上跟FileSystemResource也可以。 </li><li><code>UrlResource</code>。通过<code>java.net.URL</code>进行的具体资源查找定位的实现类，内部委派URL进行具 体的资源操作。 </li><li><code>InputStreamResource</code>。将给定的InputStream视为一种资源的Resource实现类，较为少用。 可能的情况下，以ByteArrayResource以及其他形式资源实现代之。</li></ul><p>Resource接口代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public interface Resource extends InputStreamSource &#123;</span><br><span class="line">    boolean exists();</span><br><span class="line"></span><br><span class="line">    default boolean isReadable() &#123;</span><br><span class="line">        return this.exists();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default boolean isOpen() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default boolean isFile() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    URL getURL() throws IOException;</span><br><span class="line"></span><br><span class="line">    URI getURI() throws IOException;</span><br><span class="line"></span><br><span class="line">    File getFile() throws IOException;</span><br><span class="line"></span><br><span class="line">    default ReadableByteChannel readableChannel() throws IOException &#123;</span><br><span class="line">        return Channels.newChannel(this.getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long contentLength() throws IOException;</span><br><span class="line"></span><br><span class="line">    long lastModified() throws IOException;</span><br><span class="line"></span><br><span class="line">    Resource createRelative(String var1) throws IOException;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getFilename();</span><br><span class="line"></span><br><span class="line">    String getDescription();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口从命名也可以看出来，它可以帮助我们查询资源状态、访问资源内容，甚至根据当前资源创建新的相对资源。</p><h5 id="Spring中的ResourceLoader"><a href="#Spring中的ResourceLoader" class="headerlink" title="Spring中的ResourceLoader"></a>Spring中的ResourceLoader</h5><p>有了Resource之后，如何去查找和定位这些资源，就是<code>ResourceLoader</code>的职责所在了。</p><p>ResourceLoader有一个默认的实现类，即<code>org.springframework.core.io.DefaultResourceLoader</code>，该类默认的资源查找处理逻辑如下。</p><p> (1) 首先检查资源路径是否以<code>classpath:</code>前缀打头，如果是，则尝试构造ClassPathResource类型资源并返回。</p><p> (2) 否则，</p><ul><li>尝试通过URL，根据资源路径来定位资源，如果没有抛出MalformedURLException， 有则会构造UrlResource类型的资源并返回；</li><li>如果还是无法根据资源路径定位指定的资源，则委派 getResourceByPath(String) 方法来定位， DefaultResourceLoader 的 getResourceByPath(String)方法默认实现逻辑是，构造ClassPathResource类型的资源并返回。</li></ul><p>说到这里，可能会勾起很多人初学Spring的回忆，当时对<code>classpath:</code>一直处于懵懂状态，大概能理解他的意思，就是在该项目中查找路径，知道看到这里，才能理解他的本质吧。</p><h6 id="FileSystemResourceLoader"><a href="#FileSystemResourceLoader" class="headerlink" title="FileSystemResourceLoader"></a>FileSystemResourceLoader</h6><p>为了避免DefaultResourceLoader在最后getResourceByPath(String)方法上的不恰当处理， 我们可以使用<code>org.springframework.core.io.FileSystemResourceLoader</code>，它继承自DefaultResourceLoader，但覆写了getResourceByPath(String)方法，使之<strong>从文件系统加载资源并以 FileSystemResource类型返回。</strong>这样，我们就可以取得预想的资源类型。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Spring最初并不支持基于注解的依赖注入方式。所以，在Spring 2.5中引入这一依赖注入方式的 候，肯定要在维护整个框架设计与实现的一致性和引入这种依赖注入方式对整个框架的冲击之间做出权衡。最终的结果我们已经看到了，Spring 2.5中引入的基于注解的依赖注入从整体上保持了框架内的一致性，同时又提供了足够的基于注解的依赖注入表达能力。</p><p>虽然我们还会部分地依赖于容器的配置文件，但通过20%的工作却可以带来80%的效果， 这本身已经是最好的结果了。 不过，从实际开发角度看，如果非要使用完全基于注解的依赖注入的话，或许会遇到一些难题。</p><p>比如，对于第三方提供的类库，肯定没法给其中的相关类标注@Component之类的注解。这 时，我们可以结合使用基于配置文件的依赖注入方式。毕竟，基于XML的依赖注入方式是Spring提供的最基本、也最为强大的表达方式了！ 到目前为止，我们已经几乎讲到了Spring IoC的绝大部分核心内容了。</p><p>但是，要想真正会用，还是得动手实践才有效果。</p><p>参考引用：</p><blockquote><p>【1】<a href="https://www.cnblogs.com/wt20/p/10470178.html">https://www.cnblogs.com/wt20/p/10470178.html</a></p><p>【2】《Spring揭秘》王福强</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/Spring/">Spring</category>
      
      
      
      <comments>http://hznu.asia/2022/08/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SpringIOC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从面向对象看DDD</title>
      <link>http://hznu.asia/2022/08/14/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BDDD/</link>
      <guid>http://hznu.asia/2022/08/14/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BDDD/</guid>
      <pubDate>Sun, 14 Aug 2022 08:28:06 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;在之前两篇文章中，有一篇初步了解了什么是领域驱动设计（DDD）。这篇文章则尝试并进一步解释到底什么是面向对象，如何利用DDD进行真正面向对象的程序设计。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-再看面向对象&quot;&gt;&lt;a href=&quot;#一</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>在之前两篇文章中，有一篇初步了解了什么是领域驱动设计（DDD）。这篇文章则尝试并进一步解释到底什么是面向对象，如何利用DDD进行真正面向对象的程序设计。</p></blockquote><h2 id="一-再看面向对象"><a href="#一-再看面向对象" class="headerlink" title="一. 再看面向对象"></a>一. 再看面向对象</h2><p>“面向对象程序设计”在所有人接触 Java 时一定听过，但是绝大部分初学者应该很难理解什么才是面向对象。书本给出的定义是：<strong>面向对象程序设计(Object Oriented Programming)其本质是以建立模型体现出来的抽象思维过程和面向对象的方法。</strong></p><p>而考试的时候，也自然就是背好填上去了，想要真正理解，不是那么简单的。</p><p>对于究竟什么是面向对象，常见的说法是：数据和函数的组合。这种说法不准确，也很难让初学者理解。</p><p>另一种常见的说法是：面向对象编程时一种对真实世界进行建模的方式。这种说法则听起来有点抽象，如何对真实世界进行建模？为什么这样？有什么好处？全然不知。而且也没有回答出究竟什么是面向对象。</p><p>这时候，很多学过并且有一定经验的人便会抛出三个词：继承、封装、多态。</p><p>在初学的时候，教Java的老师也是这样和我们说的，但是也只是一带而过，考试的时候也只是背好但是无法理解。</p><p>后来，我也做过一些项目了，但是，在看过《实现领域驱动设计》这本书后，我发现：<strong>我的代码根本不是面向对象。</strong></p><p>“习惯了先建表，再写实体类。在业务代码里面，所有的代码都是把字段取出来计算，然后，再塞回去，碰到需要的对象就在service里面new一下。各种业务代码全部叠加在Service里面，里面充满着各种各样的逻辑代码，也许setter\getter随处可见，再过几个月，我自己也许也不清楚这些逻辑是什么含义，将来有一点调整，所有的代码都得跟着变。”</p><p>那么什么是面向对象呢？用这三个词来解释其实没错，错的的没有理解这三个词。在后面学习过程中，每一次看这三个词以及相关解释，我都有不一样的理解，理解的深度自然也不同。在学习过Spring Data JPA和DDD后，我们再来看下这三个词。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装，是面向对象的根基。</strong>这个特性并不是Java独有的，C语言这种非面向对象的语言也有。</p><p>为了更好理解，我们先回到面向对象刚刚诞生的时候。</p><p>“面向对象”这个词是由 Alan Kay 创造的，他是 2003 年图灵奖的获得者。</p><p>在他最初的构想中，对象就是一个细胞。当细胞一点一点组织起来，就可以组成身体的各个器官，再一点一点组织起来，就构成了人体。而当你去观察人的时候，就不用再去考虑每个细胞是怎样的。所以，面向对象给了我们一个更宏观的思考方式。</p><p>但是，这一切的前提是，每个对象都要构建好，也就是封装要做好，这就像每个细胞都有细胞壁将它与外界隔离开来，形成了一个完整的个体。</p><p>在 Alan Kay 关于面向对象的描述中，他强调对象之间只能通过消息来通信。如果按今天程序设计语言的通常做法，发消息就是方法调用，对象之间就是靠方法调用来通信的。但这个方法调用并不是简单地把对象内部的数据通过方法暴露。</p><p>在 Alan Kay 的构想中，他甚至想把数据去掉。<strong>因为，封装的重点在于对象提供了哪些行为，而不是有哪些数据。</strong></p><p>也就是说，即便我们把对象理解成数据加函数，数据和函数也不是对等的地位。函数是接口，而数据是内部的实现，正如我们一直说的那样，接口是稳定的，实现是易变的。</p><p>理解了这一点，我们来看一个很多人都有的日常编程习惯。他们编写一个类的方法是，把这个类有哪些字段写出来，然后，生成一大堆 getter 和 setter，将这些字段的访问暴露出去。</p><p><strong>这种做法的错误就在于把数据当成了设计的核心，这一堆的 getter 和 setter，就等于把实现细节暴露了出去。</strong></p><p><strong>一个正确的做法应该是，我们设计一个类，先要考虑其对象应该提供哪些行为。然后，我们根据这些行为提供对应的方法，最后才是考虑实现这些方法要有哪些字段。</strong></p><p><strong>方法的命名，体现的是你的意图，而不是具体怎么做。</strong></p><p>所以，getXXX 和 setXXX 绝对不是一个好的命名。举个例子，设计一个让用户修改密码的功能，有些人直觉的做法可能是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class User &#123; </span><br><span class="line">private String username; </span><br><span class="line">private String password; </span><br><span class="line">... // 修改密码 </span><br><span class="line">public void setPassword(final String password) &#123; </span><br><span class="line">this.password = password; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较好的做法是，把意图表现出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  private String username;</span><br><span class="line">  private String password;</span><br><span class="line">  ...</span><br><span class="line">  // 修改密码</span><br><span class="line">  public void changePassword(final String password) &#123;</span><br><span class="line">    this.password = password;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果看过我的另一篇文章（<a href="https://hznu.asia/2022/07/19/DDD%E5%88%9D%E6%8E%A2/">DDD初探</a>），应该会理解上述思想。而对于那些只有setter/getter的实体类，只能被称作“数据持有器”，而称不上是“对象”，这些实体类在《实现领域驱动设计》这本书中，也被称作是“贫血模型”。</p><p>这两段代码相比，只是修改密码的方法名变了，<strong>但二者更重要的差异是，一个在说做什么，一个在说怎么做，将意图与实现分离开来。</strong></p><p>不过，在真实的项目中，有时确实需要暴露一些数据，所以，等到确实需要暴露的时候，再去写 getter 也不迟，但是写的时候一定要问问自己为什么要加 getter。如果出现set..()的方法，也是不应该的，正确的做法是用一个表示意图的名字；其次，setter 通常意味着修改，也是不建议的做法，具体可以怎样做，可以参考<a href="https://hznu.asia/2022/07/19/DDD%E5%88%9D%E6%8E%A2/">DDD初探</a>。</p><h4 id="减少暴露接口"><a href="#减少暴露接口" class="headerlink" title="减少暴露接口"></a>减少暴露接口</h4><p>在Java中支持 public、private 这样的修饰符。程序员在日常开发中，经常会很草率地给一个方法加上 public，从而不经意间将一些本来应该是内部实现的部分暴露出去。举个例子，一个服务要停下来的时候，你可能要把一些任务都停下来，代码可能会这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Service &#123;</span><br><span class="line">  public void shutdownTimerTask() &#123;</span><br><span class="line">    // 停止定时器任务</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void shutdownPollTask() &#123;</span><br><span class="line">    // 停止轮询服务</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别人调用时，可能会这样调用这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Application &#123;</span><br><span class="line">  private Service service;</span><br><span class="line">  public void onShutdown() &#123;</span><br><span class="line">    service.shutdownTimerTask();</span><br><span class="line">    service.shutdownPollTask();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突然有一天，你发现，停止轮询任务必须在停止定时器任务之前，你就不得不要求别人改代码。而这一切就是因为我们很草率地给那两个方法加上了 public，让别人有机会看到了这两个方法。</p><p>从设计的角度来说，我们必须谨慎地问一下，这个方法真的有必要暴露出去吗？就这个例子而言，我们可以仅仅暴露一个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Service &#123;</span><br><span class="line">  private void shutdownTimerTask() &#123;</span><br><span class="line">    // 停止定时器任务</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private void shutdownPollTask() &#123;</span><br><span class="line">    // 停止轮询服务</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void shutdown() &#123;</span><br><span class="line">    this.shutdownTimerTask();</span><br><span class="line">    this.shutdownPollTask();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别人调用代码也会简单很多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Application &#123;</span><br><span class="line">  private Service service;</span><br><span class="line">  </span><br><span class="line">  public void onShutdown() &#123;</span><br><span class="line">    service.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装的重点在于对象提供了哪些行为，而不是有哪些数据。</strong>设计一个类的方法，先要考虑其对象应该提供哪些行为，然后，根据这些行为提供对应的方法，最后才是考虑实现这些方法要有哪些字段。getter 和 setter 是暴露实现细节的，尽可能不提供，尤其是 setter。</p><p>封装，除了要减少内部实现细节的暴露，还要减少对外接口的暴露。一个原则是最小化接口暴露。有了对封装的理解，即便我们用的是 C 语言这样非面向对象的语言，也可以按照这个思路把程序写得更具模块性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>说到继承，很多讲面向对象的教材一般会这么讲，给你画一棵树，父类是根节点，而子类是叶子节点，显然，一个父类可以有许多个子类。父类是干什么用的呢？就是把一些公共代码放进去，之后在实现其他子类时，可以少写一些代码。</p><p>所以，在很多人的印象中，继承就是一种代码复用的方式。但是，把实现继承当作一种代码复用的方式，并不是一种值得鼓励的做法。</p><p>一方面，继承是很宝贵的，尤其是 Java 这种单继承的程序设计语言。每个类只能有一个父类，一旦继承的位置被实现继承占据了，再想做接口继承就很难了。</p><p>另一方面，实现继承通常也是一种受程序设计语言局限的思维方式，有很多程序设计语言，即使不使用继承，也有自己的代码复用方式。<strong>所以，继承也并不是面向对象独有的。</strong></p><p>在七大设计原则中，有一个合成复用原则，提倡尽量使用组合或者聚合关系实现代码复用，少使用继承。也就是说，如果一个方案既能用组合实现，也能用继承实现，那就选择用组合实现。</p><p>到这里已经清楚了，代码复用并不是使用继承的好场景。</p><p><strong>所以，要写继承的代码时，先问自己，这是接口继承，还是实现继承？如果是实现继承，那是不是可以写成组合？</strong></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在论述多态在面向对象中的作用前，我们先来回顾下什么是多态，举个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">  // 绘图接口</span><br><span class="line">  void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Square implements Shape &#123;</span><br><span class="line">  void draw() &#123;</span><br><span class="line">    // 画一个正方形</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle implements Shape &#123;</span><br><span class="line">  void draw() &#123;</span><br><span class="line">    // 画一个圆形</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义，一个接口，多种形态。同样是一个绘图（draw）的方法，如果以正方形调用，则绘制出一个正方形；如果以圆形调用，则画出的是圆形。</p><p>前面我们提到，继承有两种，实现继承和接口继承。其中，实现继承尽可能用组合的方式替代继承。而接口继承，主要是给多态用的。</p><p>这里面的重点在于，这个继承体系的使用者，主要考虑的是父类，而非子类。就像下面这段代码里，我们不必考虑具体的形状是什么，只要调用它的绘图方法即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shape shape = new Squre();</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure><p>这种做法的好处就在于，一旦有了新的变化，比如，需要将正方形替换成圆形，除了变量初始化，其他的代码并不需要修改。不过，这是任何一本面向对象编程的教科书上都会讲的内容。</p><p>那么，问题来了。既然多态这么好，为什么很多程序员不能在自己的代码中很好地运用多态呢？因为多态需要构建出一个抽象。构建抽象，需要找出不同事物的共同点，而这是最有挑战的部分。</p><p>而遮住程序员们双眼的，往往就是他们眼里的不同之处。在他们眼中，鸡就是鸡，鸭就是鸭。</p><p>在构建抽象上，接口扮演着重要的角色。首先，接口将变的部分和不变的部分隔离开来。<strong>不变的部分就是接口的约定，而变的部分就是子类各自的实现。</strong></p><p>在软件开发中，对系统影响最大的就是变化。有时候需求一来，你的代码就要跟着改，一个可能的原因就是各种代码混在了一起。</p><p>比如，一个通信协议的调整需要你改业务逻辑，这明显就是不合理的。<strong>对程序员来说，识别出变与不变，是一种很重要的能力。</strong></p><p>其次，接口是一个边界。无论是什么样的系统，清晰界定不同模块的职责是很关键的，而模块之间彼此通信最重要的就是通信协议。这种通信协议对应到代码层面上，就是接口。</p><p><strong>所以，要想理解多态，首先要理解接口的价值，而理解接口，最关键的就是在于谨慎地选择接口中的方法。</strong></p><p><strong>这样说就能很好地理解一个编程原则了：面向接口编程。面向接口编程的价值就在于多态，也正是因为有了多态，一些设计原则，比如，开闭原则、接口隔离原则才得以成立，相应地，设计模式才有了立足之本。</strong></p><blockquote><p>面向对象起源的宏观视角：细胞-&gt;器官-&gt;人体， 日常都是跟人宏观的沟通，不用跟这个人的细胞去沟通。</p><p>细胞有细胞壁隔离封装，细胞组成的器官有各自器官的功能和边界，器官之间通过接口来沟通而不是器官内的细胞，如各个器官有各自的对外连接的血管就是提供的接口。</p><p>每个器官对外暴露的接口而不是细胞，封装思想；</p><p>各种细胞可能继承了同样的一种细胞的特性，继承思想；</p><p>这些细胞同一个行为可能有有不同的实现方式，比如有的细胞吃饭靠吞噬，有的细胞吃饭靠供血，多态思想。</p></blockquote><h2 id="二-模型分类"><a href="#二-模型分类" class="headerlink" title="二. 模型分类"></a>二. 模型分类</h2><p>模型是一种知识形式，它对知识进行了选择性的简化和有意的结构化，从而解决信息超载的问题。模型便于人们理解信息的意义，并专注核心问题。</p><p>建模过程一般由<strong>分析活动</strong>、<strong>设计活动</strong>和<strong>实现活动</strong>组成。每一次建模活动都是一次对知识的提炼和转换，并产生相应的模型，即<strong>分析模型</strong>、<strong>设计模型</strong>和<strong>实现模型</strong>。</p><p>建模过程并非是分析、设计和实现单向的前后串行过程，而是<strong>相互影响，不断切换和递进的关系</strong>。模型驱动设计的建模过程是：分析中蕴含了设计，设计中夹带了实现，甚至实现后还要回溯到设计和分析的一种<strong>迭代的</strong>、<strong>螺旋上升的</strong>演进过程。</p><p>根据分解问题的视角不同，我们日常建立的模型可以大致分为以下三类：</p><ul><li><strong>数据模型</strong>：将问题空间抽取出来的概念视为数据信息，在求解过程中关注数据实体的样式和它们之间的关系，由此建立的模型就是数据模型。</li><li><strong>服务模型</strong>：将每个问题视为目标系统为客户端提供的服务，在求解过程就会关注客户端发起的请求以及服务返回的响应，由此建立的模型就是服务模型。</li><li><strong>领域模型</strong>：围绕问题空间的业务需求，在求解过程中力求提炼出表达领域知识的逻辑概念，由此建立的模型就是领域模型。</li></ul><h2 id="三-尝试采用DDD进行系统设计"><a href="#三-尝试采用DDD进行系统设计" class="headerlink" title="三. 尝试采用DDD进行系统设计"></a>三. 尝试采用DDD进行系统设计</h2><p>本节中，将使用一个简单的例子，来论述如何采用DDD进行系统设计，并使用Sping Data JPA作为持久层，本例子中，仅仅属于入门级别的应用，不会涉及领域事件、领域服务等等。</p><p>在以往很多系统中，开发初期，往往是先根据数据库范式设计好数据库，并定义好每个表有哪些字段，定义字段的类型，大小，设计表与表之间如何关联等等，这属于典型的数据模型。但是在DDD中并不会这样做，初期并不关心数据库，而是关注如何进行领域建模，而这就是典型的面向对象思想，此时选择Spring Data JPA可以真正做到面向对象编程。</p><h3 id="3-1-什么是领域模型"><a href="#3-1-什么是领域模型" class="headerlink" title="3.1 什么是领域模型"></a>3.1 什么是领域模型</h3><p>领域模型由<strong>领域分析模型</strong>、<strong>领域设计模型</strong>以及<strong>领域实现模型</strong>共同组成，它们也分别是领域分析建模、领域设计建模和领域实现建模三个建模活动的产物。</p><p>领域模型并非由开发团队单方面输出的产物，而是由产品、领域专家和开发团队共同协作的结果。</p><p><strong>领域专家通过领域模型能够判断系统所支持的领域能力，以及由此编排出来的上层业务能力；开发团队通过领域模型能够形成基本的代码框架（包括架构分层，每层需要定义的接口，接口的命名等）。</strong></p><h3 id="3-2-如何进行建模"><a href="#3-2-如何进行建模" class="headerlink" title="3.2 如何进行建模"></a>3.2 如何进行建模</h3><p>要进行领域建模，首先就要明确限界上下文。在限界上下文内，以“领域”为中心，提炼业务服务中的领域概念，确定领域概念之间的关系，最终形成领域分析模型。领域分析模型描述了各个限界上下文中的领域概念，以及领域概念之间的关系。</p><h4 id="3-2-1-名词建模"><a href="#3-2-1-名词建模" class="headerlink" title="3.2.1 名词建模"></a>3.2.1 <strong>名词建模</strong></h4><p>找到业务服务中的名词，在统一语言指导下将其映射为领域概念。</p><h4 id="3-2-2-动词建模"><a href="#3-2-2-动词建模" class="headerlink" title="3.2.2 动词建模"></a>3.2.2 <strong>动词建模</strong></h4><p>识别动词并不是为领域模型对象分配职责、定义方法，而是<strong>将识别出来的动词当做一个领域行为</strong>，然后看它是否产生了影响系统计算的<strong>过程数据</strong>。若存在，则将这些过程数据作为领域概念放到领域分析模型中。</p><p>注意，这里的过程数据是要求会对企业运营和管理产生影响的数据，比如在常见的学生管理系统中学生提交请假申请，就会产生<strong>申请单</strong>这个过程数据，而请求流水记录、任务执行记录都不属于过程数据。因为只有<strong>申请单</strong>会对本次审批流程以及后续结果产生影响，其他不过是一次记录而已。</p><p>动词建模通过分析领域行为是否产生过程数据来找到隐藏的领域概念，弥补了名词建模的不足。对于会产生领域事件的动词，一般可以抽象出一个已完成该动作的状态，DDD拥有众多值得深入研究的方向，所以这里不继续深入探讨领域事件等。</p><h4 id="3-2-3-提取隐式概念"><a href="#3-2-3-提取隐式概念" class="headerlink" title="3.2.3 提取隐式概念"></a>3.2.3 <strong>提取隐式概念</strong></h4><p>除了“名词”和“动词”，概念中其他重要的类别也可以在模型中显式地表现出来，主要包括：<strong>约束</strong>和<strong>规格</strong>。</p><p><strong>约束</strong></p><p>约束一般是对领域概念的限制，我们可以将约束条件提取到自己的方法中，并通过方法名显式地表达约束的含义。比如学生管理系统中关于绩点运算的约束，绩点不能超过 5.0 等等。</p><p><strong>规格</strong></p><p>直接上概念可能不好理解，但是举个例子就很容易明白，规格一般有如下三种用法：</p><ul><li>（验证）验证对象，检查它是否能满足某些标准，比如学生管理系统中成绩实体在修改分数时就需要通过规约判断当前是否满足打分标准，比如已经打过分了，这时候就不能打分，要进行修改操作；</li><li>（选择）从集合中选择一个符合要求的对象，<strong>可以搭配资源库使用</strong>（暂时可以理解为持久层，但是在DDD中DAO和资源库是不一样的）；</li><li>（根据要求来创建）指定在创建新对象时必须满足某种要求（比如新建一个学生的成绩，必须保障数据库中没有成绩）。</li></ul><h4 id="3-2-4-归纳抽象"><a href="#3-2-4-归纳抽象" class="headerlink" title="3.2.4 归纳抽象"></a><strong>3.2.4 归纳抽象</strong></h4><p>对于有定语修饰的名词，要注意分辨它们是<strong>类型的差异</strong>，还是<strong>值的差异</strong>。如配送地址和家庭地址，订单状态和商品状态。如果是值的差异，类型相同，应归并为一个领域概念（如，配送地址和家庭地址）；而类型不同，则不能合并（如，订单状态和商品状态）。</p><p>当定语修饰的名词中，定语表示的是不同的限界上下文，且名词相同时（即名称相同、含义不同的领域概念），我们应该尽可能调整命名，确保含义不同的领域概念的名称不同，以避免不必要的歧义和沟通上的误解。比如：商品的订单和库存的订单在特定限界上下文内都可以命名为 order，但是如果把库存的订单改为库存的配送单 delivery 效果会更好。</p><h4 id="3-2-5-确认关系"><a href="#3-2-5-确认关系" class="headerlink" title="3.2.5 确认关系"></a>3.2.5 <strong>确认关系</strong></h4><p>根据业务需求和领域知识，判断领域概念之间是否存在关联。且对于 1:N, N:1, M:N 的关联关系，我们需要判断是否可以为这些关联关系定义一个新的类型，比如作品与读者存在 1:N 的关系，我们可以定义“订阅”这个概念来描述这种关系。</p><p>但是，我们需要尽量避免对象中的双向关系，即对象 A 关联对象 B，而对象 B 关联对象 A。当两个对象存在双向关系时，会为管理他们的生命周期带来额外的复杂度。我们应该规定一个遍历方向，来表明<strong>一个方向的关联比另一个方向的关联更有意义且更重要</strong>，比如学生管理系统中，成绩会关联课程（成绩实例中包含课程 ID），而课程不会关联成绩。当然，当双向关系是领域的一个概念时，我们还是应该保留它。</p><h4 id="3-2-6-学生管理系统的领域分析模型"><a href="#3-2-6-学生管理系统的领域分析模型" class="headerlink" title="3.2.6 学生管理系统的领域分析模型"></a>3.2.6 <strong>学生管理系统的领域分析模型</strong></h4><p>通过名词建模，动词建模和归纳抽象后，可提炼出以下领域对象：成绩（Result）、绩点（gpa）、总成绩（total result）、总绩点（total gpa）、学年（school year）、学期（semester）、课程（course）、学分（credit）、申请单（application receipt），邮件（mail），排名（rank），申请单状态（application receipt status）</p><p><img src="https://img.hznu.asia/DDD/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E7%A4%BA%E4%BE%8B.jpg"></p><p>这就是一个简单的领域建模，但是，不知道为什么这样建模也是不行的，下面我们来分析下。</p><p>在此之前，由于上一篇文章详细介绍过实体、值对象、贫血模型等，但是没有结合例子来讲解，而对于聚合、工厂、资源库、领域服务、领域事件则完全没有介绍，虽然后续也会详细介绍，但是这里也有必要简单了解一下。</p><h2 id="四-领域设计建模"><a href="#四-领域设计建模" class="headerlink" title="四. 领域设计建模"></a>四. 领域设计建模</h2><p> 领域设计建模的核心工作就是<strong>设计聚合</strong>和<strong>设计服务</strong>，在正式着手设计前，我们先简单了解一下一些术语。</p><h4 id="4-1-设计要素"><a href="#4-1-设计要素" class="headerlink" title="4.1 设计要素"></a>4.1 <strong>设计要素</strong></h4><p>领域驱动设计强调以“领域”为核心驱动力。设计领域模型时应该尽量避免陷入到技术实现的细节约束中。但很多时候我们又不得不去思考一些非领域相关的问题：</p><ul><li>领域模型对象的加载以及对象间的关系如何处理？</li><li>领域模型对象如何实现数据的持久化？</li><li>领域模型对象彼此之间如何做到弱依赖地完成状态的变更通知？</li></ul><p>这几个问题有些也是我在了解DDD时所困惑的，为了解答上述的四个问题，<strong>DDD 提供了很多的设计要素，它们能够帮助我们在不陷入到具体技术细节的情况下进行领域模型的设计</strong>。</p><h5 id="4-1-1-实体"><a href="#4-1-1-实体" class="headerlink" title="4.1.1 实体"></a>4.1.1 <strong>实体</strong></h5><p>实体的核心三要素：<strong>身份标识</strong>、<strong>属性</strong>和<strong>领域行为</strong>，其中唯一陌生的就是领域行为了。</p><p><strong>领域行为</strong>：体现了实体的动态特征。实体具有的领域行为一般可以分为：</p><ul><li><strong>变更状态的领域行为</strong>：变更状态的领域行为体现的是实体/值对象内部的状态转移，对应的方法入参为期望变更的状态。（有入参，无出参）；</li><li><strong>自给自足的领域行为</strong>：自给自足意味着实体对象只操作了自己的属性，不外求于别的对象。（无入参）；</li><li><strong>互为协作的领域行为</strong>：需要调用者提供必要的信息。（有入参，有出参）；</li><li><strong>创建行为</strong>：代表了对象在内存的从无到有。创建行为由构造函数履行，但对于创建行为较为复杂或需要表达领域语义时，我们可以在实体中定义简单工厂方法，或使用专门的工厂类进行创建。（有出参，且出参为特定实体实例）。</li></ul><h5 id="4-1-2-值对象"><a href="#4-1-2-值对象" class="headerlink" title="4.1.2 值对象"></a>4.1.2 <strong>值对象</strong></h5><p>在《实现领域驱动设计》一书中，其实并没有讲清楚或讲的很容易理解：<strong>一个领域概念到底该用值对象还是实体类型</strong>，<strong>判断依据：</strong></p><ul><li><strong>业务的参与者对它的相等判断是依据值还是依据身份标识；</strong></li><li><strong>确定对象的属性值是否会发生变化，如果变化了，究竟是产生一个完全不同的对象，还是维持相同的身份标识；</strong></li><li><strong>生命周期的管理。值对象无需进行生命周期管理。</strong></li></ul><p><strong>值对象具有不变性</strong>。值对象完成创建后，其属性和状态就不应该再进行变更了，如果需要更新值对象，则通过创建新的值对象进行替换。</p><p>由于值对象的属性是在其创建的时候就完成传入的，那么值对象所具有的领域行为大部分情况下都是“自给自足的领域行为”，即入参为空。这些领域行为一般提供以下的能力。</p><ul><li><p><strong>自我验证</strong>：验证传入值对象的外部数据是否正确，一般在创建该值对象时进行验证。</p></li><li><p><strong>自我组合</strong>：当值对象涉及到数值运算时，可以定义相同类型值对象的方法，使值对象具有自我组合能力。比如学生管理系统中，在统计成绩时会涉及学分相加的运算，因此我们可以将相加运算定义为可组合的方法，便于调用者使用。</p></li><li><p><strong>自我运算</strong>：根据业务规则对属性值进行运算的行为。</p></li></ul><p>在进行领域设计建模时，要善于运用值对象去表达细粒度的领域概念。值对象的优势有：</p><ul><li>值对象在类型层面就可以表达领域概念，而不仅仅依赖命名；</li><li>值对象可以封装领域行为，进行自我验证，自我组合，自我运算。</li></ul><h5 id="4-1-3-聚合"><a href="#4-1-3-聚合" class="headerlink" title="4.1.3 聚合"></a>4.1.3 <strong>聚合</strong></h5><p>聚合的基本特征：</p><ul><li><strong>聚合是包含了实体和值对象的一个边界。</strong></li><li>聚合内包含的实体和值对象形成一棵树，只有实体才能作为这棵树的根，因此实体一般也称作根实体。</li><li>外部对象只允许持有聚合根的引用，以起到边界控制作用。</li><li>聚合作为一个完整的领域概念整体，其内部会维护这个领域概念的完整性。</li><li>由聚合根统一对外提供履行该领域概念职责的行为方法，实现内部各个对象之间的行为协作。</li></ul><h5 id="4-1-4-工厂"><a href="#4-1-4-工厂" class="headerlink" title="4.1.4 工厂"></a>4.1.4 <strong>工厂</strong></h5><p>聚合中的工厂：一个类或方法只要封装了聚合对象的创建逻辑，都可以认为是工厂。表现形式如下：</p><ul><li>引入专门的聚合工厂（尤其适合需要通过访问外部资源来完成创建的复杂创建逻辑）</li><li>聚合自身担任工厂（简单工厂模式）</li><li>使用构建者组装聚合</li></ul><p><strong>这里工厂创建的基本单元是聚合，而非实体，注意与实体中的创建行为区分。</strong></p><h5 id="4-1-5-资源库"><a href="#4-1-5-资源库" class="headerlink" title="4.1.5 资源库"></a>4.1.5 <strong>资源库</strong></h5><p>资源库是对数据访问的一种业务抽象，用于解耦领域层与外部环境，使领域层变得更为纯粹。资源库可以代表任何可以获取资源的仓库，例如网络或其他硬件环境，而不局限于数据库。</p><p><strong>一个聚合对应一个资源库</strong>。领域驱动设计引入资源库，主要目的是管理聚合的生命周期。资源库负责聚合记录的查询与状态变更，即“增删改查”操作。资源库分离了聚合的领域行为和持久化行为，保证了领域模型对象的业务纯粹性。</p><p>值得注意的是，资源库的操作单元是聚合。当我们定义资源库的接口时，接口的入参应该为聚合的根实体。如果要访问聚合内的非根实体，也只能通过资源库获得整个聚合后，将根实体作为入口，在内存中访问封装在聚合边界内的非根实体对象。</p><blockquote><p>资源库与数据访问对象（DAO）的区别：</p><p>根本区别在于，数据访问对象在访问数据时，并无聚合的概念，也就是没有定义聚合的边界约束领域模型对象，使得数据访问对象的操作粒度可以针对领域层的任何模型对象。数据访问对象（DAO）可以自由地操作实体和值对象。没有聚合边界控制的数据访问，会在不经意间破坏领域概念的完整性，突破聚合不变量的约束，也无法保证聚合对象的独立访问与内部数据的一致性。</p><p>其次，资源库是基于领域模型对存储系统进行的抽象，因此资源库中的方法命名可以表达领域概念；而数据访问对象（DAO）是存储系统对外暴露的抽象，其方法命名更贴合数据库本身的操作。</p></blockquote><h5 id="4-1-6-领域服务"><a href="#4-1-6-领域服务" class="headerlink" title="4.1.6  领域服务"></a>4.1.6  领域服务</h5><p>聚合通过聚合根的领域行为对外提供服务，而<strong>领域服务则是对聚合根的领域行为的补充</strong>。因此，我们应该尽量<strong>优先通过聚合根的领域行为来满足业务服务</strong>。</p><p>那什么场景下我们会需要用到领域服务呢？有如下两个：</p><ul><li><strong>生命周期管理</strong>。为了避免领域知识的泄露，应用服务不会直接引用聚合生命周期相关的服务（工厂、资源库接口），而聚合根实体一般不会依赖资源库接口，此时就需要领域服务进行组合对外暴露。</li><li><strong>依赖外部资源</strong>。<strong>为了保证聚合的稳定性，聚合根实体不会依赖防腐层接口</strong>。因此，当聚合对外暴露的服务需要设计外部资源访问时，就需要通过领域服务来完成。</li></ul><h5 id="4-1-7-领域事件"><a href="#4-1-7-领域事件" class="headerlink" title="4.1.7 领域事件"></a>4.1.7 <strong>领域事件</strong></h5><p>领域事件属于领域层的领域模型对象，由限界上下文中的聚合发布，有需要的聚合（同一限界上下文/不同限界上下文）可以进行消费。而当一个事件由应用层发布，则该事件为应用事件。</p><p>引入领域事件首要目的是更好地跟踪实体状态的变更，并在状态变更时，通过事件消息的通知完成领域模型对象之间的协作。</p><p><strong>领域事件的特征</strong>：</p><ul><li>领域事件代表了领域的概念；</li><li>领域事件是已经发生的事实（表示事件的名称应该是过去时，比如 Committed）；</li><li>领域事件是不可变的领域对象；</li><li>领域事件会基于某个条件而触发。</li></ul><p><strong>领域事件的用途</strong>：</p><ul><li>发布状态变更；</li><li>发布业务流程中的阶段性成果；</li><li>异步通信。</li></ul><p>领域事件应该包含：</p><ul><li>身份标识，即事件 ID，为通用类型的身份标识；</li><li>事件发生的时间戳，便于记录和跟踪；</li><li>属性需要针对订阅者的需求，在<strong>增强事件</strong>和<strong>反向查询</strong>之间进行权衡。增强事件指属性中包含订阅者所需的所有数据；反向查询则是属性包含事件 ID，当订阅者需要数据时通过事件 ID 进行反向查询。</li></ul><h4 id="4-2-设计聚合"><a href="#4-2-设计聚合" class="headerlink" title="4.2 设计聚合"></a>4.2 设计聚合</h4><p>在领域设计模型中，聚合是最小的设计单元。</p><h5 id="4-2-1-设计的经验法则"><a href="#4-2-1-设计的经验法则" class="headerlink" title="4.2.1 设计的经验法则"></a>4.2.1 <strong>设计的经验法则</strong></h5><p>这里有四条经验法则：</p><ol><li><strong>在聚合边界内保护业务规则不变性。</strong></li><li>聚合要设计得小巧。</li><li><strong>通过身份标识符关联关系其他聚合。</strong></li><li>使用最终一致性更新其他聚合。</li></ol><p>下面展开讲述法则 1 和法则 3。</p><p><strong>法则 1</strong> <strong>在聚合边界内保护业务规则不变性</strong>。</p><p>法则 1 包含了两个关键点：</p><p>​    a) 参与维护业务规则不变性的领域概念应该置于同一个聚合内；</p><p>​    b) 在任何情况下都要保护业务规则不变性。比如，在学生管理系统中分数和绩点具有转换关系，这是业务规则的不变性，因此这两个概念被放在了同一个聚合边界内；当出现老师修改分数的场景时，需要保证绩点的换算同时被执行。由于这里绩点对象是值对象，不需要关心其生命周期管理的问题。当业务规则涉及到多个实体时，就需要通过<strong>本地事务</strong>来保证规则不变性（即实体间基于业务规则的数据一致性）。</p><p><strong>法则 3 通过身份标识符关联其他聚合。</strong></p><p>注意这里强调了<strong>关联关系</strong>，关联关系会涉及聚合 A 对聚合 B 的生命周期管理的问题，对于这种聚合间的关联关系，我们通过<strong>身份标识</strong>建立关联。而当聚合 A 引用聚合 B，但不需要对聚合 B 进行生命周期管理时，我们认为这是一种<strong>依赖关系</strong>（比如方法中的入参，而非类中的属性），对于聚合间的依赖关系，我们可以通过<strong>对象引用</strong>（聚合根实体的引用）的方式建立依赖。（PS：假设设计之初难以判断聚合之间到底是关联关系，还是依赖关系，我们就统一使用身份标识符作为关系引用即可）而这种关系，我们可以利用好Spring Data JPA作为持久层来处理，可以更方便对聚合内的实体和值对象状态进行管理。</p><h4 id="4-3-设计步骤"><a href="#4-3-设计步骤" class="headerlink" title="4.3 设计步骤"></a>4.3 设计步骤</h4><h5 id="4-3-1-设计对象图"><a href="#4-3-1-设计对象图" class="headerlink" title="4.3.1 设计对象图"></a>4.3.1 设计对象图</h5><p>分析对象是实体还是值对象。</p><h5 id="4-3-2-分解关系薄弱处"><a href="#4-3-2-分解关系薄弱处" class="headerlink" title="4.3.2 分解关系薄弱处"></a>4.3.2 <strong>分解关系薄弱处</strong></h5><p>聚合本质是一个高内聚的边界，因此我们可以根据领域对象之间关系的强弱来定义出聚合的边界。对象间的关系由强到弱可以分为：继承关系，关联关系和依赖关系。</p><h5 id="4-3-3-调整聚合边界"><a href="#4-3-3-调整聚合边界" class="headerlink" title="4.3.3 调整聚合边界"></a>4.3.3 <strong>调整聚合边界</strong></h5><p>根据<strong>业务规则</strong>调整聚合边界。为了维护业务规则的不变性，相关的实体应该至于同一个聚合边界内。</p><h5 id="4-3-4-设计服务"><a href="#4-3-4-设计服务" class="headerlink" title="4.3.4 设计服务"></a>4.3.4 <strong>设计服务</strong></h5><p>这里的服务是对<strong>应用服务</strong>、<strong>领域服务</strong>、<strong>领域行为</strong>（实体提供的方法）和<strong>端口</strong>（资源库接口、防腐层接口）的统称。</p><h5 id="4-3-5-分解任务"><a href="#4-3-5-分解任务" class="headerlink" title="4.3.5 分解任务"></a>4.3.5 分解任务</h5><p><strong>业务服务</strong>包含若干个<strong>组合服务</strong>，组合服务包含若干个<strong>原子服务</strong>。<strong>领域行为</strong>和<strong>端口</strong>都可以认为是原子服务。</p><h5 id="4-3-6-分配职责"><a href="#4-3-6-分配职责" class="headerlink" title="4.3.6 分配职责"></a>4.3.6 分配职责</h5><p><strong>应用服务：</strong>匹配业务服务，提供满足业务需求的服务接口。应用服务自身并不包含任何领域逻辑，仅负责协调领域模型对象，通过它们的领域能力组合完整一个完整的应用目标。</p><p><strong>领域服务：</strong>匹配组合服务，执行业务功能，若原子任务为无状态行为或独立变化的行为，也可以匹配领域服务。控制多个聚合与端口之间的协作，由它来承担组合任务的执行。</p><p><strong>领域行为：</strong>匹配原子服务，提供业务功能的业务实现。强调无状态和独立变化，由实体提供。</p><p><strong>端口：</strong>匹配原子服务，抽象对外资源的访问，主要的端口包括资源库接口和防腐层接口。</p><h4 id="4-4-得出模型"><a href="#4-4-得出模型" class="headerlink" title="4.4 得出模型"></a>4.4 得出模型</h4><p><img src="https://img.hznu.asia/DDD/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B%E8%81%9A%E5%90%88%E8%AE%BE%E8%AE%A1.jpg"></p><p>经过上面分析，我们便得到上述模型。但是，这也并不是标准答案，软件设计本就是一个开放性的话题，可以拥有多种设计，合理即可。</p><h4 id="4-5-服务设计"><a href="#4-5-服务设计" class="headerlink" title="4.5 服务设计"></a>4.5 服务设计</h4><p><img src="https://img.hznu.asia/DDD/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A11.jpg"></p><p><img src="https://img.hznu.asia/DDD/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A12.jpg"></p><p><img src="https://img.hznu.asia/DDD/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A13.jpg"></p><h4 id="4-6-代码分层架构"><a href="#4-6-代码分层架构" class="headerlink" title="4.6 代码分层架构"></a>4.6 代码分层架构</h4><p><img src="https://img.hznu.asia/DDD/%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E5%9B%9B%E5%B1%82%E6%9E%B6%E6%9E%84.jpg"></p><h4 id="4-7-代码骨架"><a href="#4-7-代码骨架" class="headerlink" title="4.7 代码骨架"></a>4.7 代码骨架</h4><h5 id="用户接口层"><a href="#用户接口层" class="headerlink" title="用户接口层"></a><strong>用户接口层</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── controller                             //面向视图模型&amp;资源</span><br><span class="line">│   ├── ResultController.java</span><br><span class="line">│   ├── assembler                         // 装配器，将VO转换为DTO，可以采用MapStruct实现</span><br><span class="line">│   │   └── ResultAssembler.java</span><br><span class="line">│   └── vo                                // VO(View Object)对象</span><br><span class="line">│       ├── EnterResultRequest.java</span><br><span class="line">│       └── ResponseVO.java</span><br><span class="line">├── provider                               // 面向服务行为</span><br><span class="line">├── subscriber                             // 面向事件</span><br><span class="line">└── task                                   // 面向策略</span><br><span class="line">    └── TotalResultTask.java</span><br></pre></td></tr></table></figure><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><strong>应用层</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── assembler                              // 装配器，将DTO转换为DO</span><br><span class="line">│   ├── ResultAssembler.java</span><br><span class="line">│   └── TotalResultAssembler.java</span><br><span class="line">├── dto                                    // DTO(Data Transfer Object)对象</span><br><span class="line">│   ├── cmd                                // 命令相关的DTO对象</span><br><span class="line">│   │   ├── ComputeTotalResultCmd.java</span><br><span class="line">│   │   ├── EnterResultCmd.java</span><br><span class="line">│   │   └── ModifyResultCmd.java</span><br><span class="line">│   ├── event                             // 应用事件相关的DTO对象, subscriber负责接收</span><br><span class="line">│   └── qry                               // 查询相关的DTO对象</span><br><span class="line">└── service                                // 应用服务</span><br><span class="line">    ├── ResultApplicationService.java</span><br><span class="line">    ├── event                              // 应用事件，用于发布</span><br><span class="line">    └── adapter </span><br></pre></td></tr></table></figure><h5 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a><strong>领域层</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── result                                 // 成绩聚合</span><br><span class="line">│   ├── entity                            // 成绩聚合内的实体</span><br><span class="line">│   │   └── Result.java</span><br><span class="line">│   ├── service                           // 领域服务</span><br><span class="line">│   │   ├── ResultDomainService.java</span><br><span class="line">│   │   ├── event                         // 领域事件</span><br><span class="line">│   │   ├── adapter                       // 防腐层适配器接口</span><br><span class="line">│   │   ├── factory                       // 工厂</span><br><span class="line">│   │   └── repository                    // 资源库</span><br><span class="line">│   │       └── ResultRepository.java</span><br><span class="line">│   └── valueobject                        // 成绩聚合的值对象</span><br><span class="line">│       ├── GPA.java</span><br><span class="line">│       ├── ResultUK.java</span><br><span class="line">│       ├── SchoolYear.java</span><br><span class="line">│       └── Semester.java</span><br></pre></td></tr></table></figure><h5 id="基础设施实现层"><a href="#基础设施实现层" class="headerlink" title="基础设施实现层"></a><strong>基础设施实现层</strong></h5><p>该层主要提供领域层接口（资源库、防腐层接口）和应用层接口（防腐层接口）的实现。</p><p>代码组织基本以聚合为基本单元。对于应用层的防腐层接口，则直接以 application 作为包名组织。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── application                                  // 应用层相关实现</span><br><span class="line">│   └── adapter                                 // 防腐层适配器接口实现</span><br><span class="line">│       ├── facade                              // 外观接口--统一接口</span><br><span class="line">│       └── translator                          // 转换器，DO -&gt; DTO</span><br><span class="line">├── result                                       // 成绩聚合相关实现</span><br><span class="line">│   ├── adapter</span><br><span class="line">│   │   ├── facade</span><br><span class="line">│   │   └── translator</span><br><span class="line">│   └── repository                              // 成绩聚合资源库接口实现</span><br><span class="line">│       └── ResultRepositoryImpl.java</span><br><span class="line">└── totalresult                                  // 总成绩聚合相关实现</span><br><span class="line">    ├── adapter</span><br><span class="line">    │   ├── CourseAdapterImpl.java</span><br><span class="line">    │   ├── facade</span><br><span class="line">    │   └── translator</span><br><span class="line">    └── repository</span><br><span class="line">        └── TotalResultRepositoryImpl.java</span><br></pre></td></tr></table></figure><h5 id="4-8-阿里COLA架构参考"><a href="#4-8-阿里COLA架构参考" class="headerlink" title="4.8 阿里COLA架构参考"></a>4.8 阿里COLA架构参考</h5><ul><li><p><strong>COLA 是 Clean Object-Oriented and Layered Architecture的缩写，代表“整洁面向对象分层架构”。 目前COLA已经发展到<a href="https://blog.csdn.net/significantfrank/article/details/110934799">COLA v4</a>。</strong></p></li><li><p>COLA 作为应用架构，已经被选入阿里云的 Java 应用初始化的应用架构选项之一，可以使用阿里云的应用生成器：<a href="https://start.aliyun.com/bootstrap.html">https://start.aliyun.com/bootstrap.html</a> 生成cola应用。</p></li><li><p><a href="https://github.com/alibaba/COLA">CLOAGitHub地址</a></p></li></ul><p><img src="https://img.hznu.asia/DDD/alibaba-COLA%E6%9E%B6%E6%9E%84.png"></p><h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【1】《架构整洁之道》Robert C.Martin</span><br><span class="line">【2】https://time.geekbang.org/column/article/252598 极客时间《软件设计之美》系列文章</span><br><span class="line">【3】https://mp.weixin.qq.com/s/BIYp9DNd_9sw5O2daiHmlA</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/SpringDataJPA/">SpringDataJPA</category>
      
      
      
      <comments>http://hznu.asia/2022/08/14/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9C%8BDDD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>理解Java线程池</title>
      <link>http://hznu.asia/2022/07/22/%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <guid>http://hznu.asia/2022/07/22/%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <pubDate>Fri, 22 Jul 2022 08:50:42 GMT</pubDate>
      
      
      
      
      <category domain="http://hznu.asia/categories/Java/">Java</category>
      
      
      
      <comments>http://hznu.asia/2022/07/22/%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DDD初探（1）</title>
      <link>http://hznu.asia/2022/07/19/DDD%E5%88%9D%E6%8E%A2(1)/</link>
      <guid>http://hznu.asia/2022/07/19/DDD%E5%88%9D%E6%8E%A2(1)/</guid>
      <pubDate>Tue, 19 Jul 2022 07:46:30 GMT</pubDate>
      
        
        
      <description>&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</description>
        
      
      
      
      <content:encoded><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spring Data JPA 是一个非常常见的持久层框架，它和我们如今十分流程的DDD（Domain-Driven Design，即领域驱动设计）有着许多相同的思想。DDD是一种根据领域专家的输入对软件进行建模以匹配该领域的软件设计方法。</span><br><span class="line"></span><br><span class="line">它主要是为了构建复杂领域，将业务的复杂性和技术的架构的实现解耦开来。DDD并不是一种具体的架构，而是一种方法论，通过边界的划分方法构建出清晰的领域和应用边界，让架构更加容易的进行演进。</span><br><span class="line"></span><br><span class="line">DDD在软件工程领域并不是一个非常容易理解的名词，要理解DDD需要对软件设计和软件架构等领域有一定的理解，因此，我们需要先从软件设计谈起。</span><br></pre></td></tr></table></figure><blockquote><p>Eric Evans 2003 年写了《领域驱动设计》，向行业介绍了 DDD 这套方法论，立即在行业中引起广泛的关注。但Eric 在知识传播上的能力着实一般，这本 DDD 的开山之作写作质量难以恭维，想要通过它去学好 DDD，是非常困难的。</p><p>所以，在国外的技术社区中，有很多人是通过各种交流讨论逐渐认识到 DDD 的价值所在，而在国内 DDD 几乎没怎么掀起波澜。2013 年，在 Eric Evans 出版《领域驱动设计》十年之后，DDD 已经不再是当年吴下阿蒙，有了自己一套比较完整的体系。Vaughn Vernon 将十年的精华重新整理，写了一本《实现领域驱动设计》，普通技术人员终于有机会看明白 DDD 到底好在哪里了。</p><p>所以，最近几年，国内的技术社区开始出现了大量关于 DDD 的讨论。再后来，因为《实现领域驱动设计》实在太厚，Vaughn Vernon 又出手写了一本精华本《领域驱动设计精粹》，让人可以快速上手DDD</p></blockquote><blockquote><p>我先大致看了《领域驱动设计精粹》，总共160多页，看了大概50页的样子，感觉有点云里雾里的，没有什么实质的收获，后来就开始看《实现领域驱动设计》，这本讲的细致很多，个人感觉比精粹版的更好上手一点。</p></blockquote><h2 id="一-什么才是软件设计"><a href="#一-什么才是软件设计" class="headerlink" title="一 . 什么才是软件设计"></a>一 . 什么才是软件设计</h2><p>在我们开发软件的过程中，经常会碰到许多问题，团队的成员在开发的同时也需要保证其稳定运行，但是，久而久之我们慢慢会发现软件设计的缺陷而引发的种种问题：</p><ul><li>开发人员热衷于技术并通过技术手段解决问题，而不是深入思考和设计，这会导致他们孜孜不倦地追逐技术上的新潮流。</li><li>过于重视数据库，大多数解决方案的讨论都是围绕数据库和数据模型，而不是业务流程和运作方式。</li><li>对于根据业务目标命名的对象和操作，开发人员没有给予应有的重视，这导致他们交付的软件和业务所拥有的心智模型之间产生巨大的分歧。</li><li>开发人员在用户界面和持久层组件中构建业务逻辑，此外，开发人员也经常会在业务逻辑当中执行持久化操作。</li><li>数据库查询会时常出现中断、延迟、死锁等问题，阻碍用户执行时间敏感型的业务操作。</li></ul><p>这一切都似乎发生在“设计无法带来低成本的软件！”的观念下。这种现象在如今的软件开发大环境中屡见不鲜，而大多数软件开发人员也并不知道除此之外能否有更好的选择。</p><p>但是，臆想出来的“不做设计能省钱”的观念是一个谬论，许多程序员因为各种各样的原因而忽略了设计的重要性。</p><p>然而，在DDD项目的实施过程中，开发人员需要尽量克制这种“以技术为中心”的冲动，以防无法接受以业务为中心的核心战略举措。</p><p><strong>“绝大部分的人错误地认为设计只关乎外观。人们只理解了表象—将这个盒子递给设计师，告诉他们：”把它变得好看一些！“这不是我们对设计的理解。</strong></p><p><strong>设计并不仅仅是感观，设计也是产品的工作方式。”我们不仅需要认识到设计对于产品重要性，更需要体会通过设计改变产品的内在运作方式可以有效地改善用户的体验。</strong></p><p>我们期望团队不仅仅只是观察到它的表象，更是希望通过不断地协作认知更加清晰地描绘出其背后的运作逻辑。</p><h2 id="二-如何确定你需要DDD"><a href="#二-如何确定你需要DDD" class="headerlink" title="二. 如何确定你需要DDD"></a>二. 如何确定你需要DDD</h2><p>以下是DDD的打分表，如果得分在七分以上，你或许得考虑使用DDD了</p><table><thead><tr><th>如果你的项目</th><th>得分</th><th>备注</th></tr></thead><tbody><tr><td>如果你的软件完全以数据为中心，所有操作都通过对数据库的CRUD完成，那么你并不需要DDD。此时你的团队只需要一个漂亮的数据库表编辑器。换言之，你可以指望着用户对你的数据进行直接操作，包括更新和删除数据。你并不需要提供用户界面。如果你甚至可以用一个简单的数据库开发工具来完成开发，那么，你完全没有必要在DDD上浪费时间和金钱</td><td>0</td><td>这似乎是一个傻瓜化的问题，但是要分清简单和复杂的区别却不是那么容易的。并不是说只要不是纯粹的CRUD软件，便可以采用DDD。因此我们需要采用另外的方法来判别简单和复杂…</td></tr><tr><td>如果你的系统只有25到30个业务操作，这应该是相当简单的。这意味着你的程序中不会多于30个用例流(use case flow)，并且每个用例流仅包含少量的业务逻辑。如果你可以使用Ruby on Rails或者Groovy和Grails来快速地开发出这样的系统，并且你没有感觉到由复杂性和业务变化所带来的痛苦，那么你是不需要使用DDD的。</td><td>1</td><td>这里想说的是25到30个业务方法，而不是说25到30个拥有多个方法的服务接口，后者可能是复杂的。</td></tr><tr><td>当你的系统中有30到40个用户故事或者用例流时，此时软件的复杂性便暴露出来了，你可以考虑采用DDD了。</td><td>2</td><td>通常情况下，复杂性并不能被及时发现。我们开发者很容易低估软件的复杂性。我们希望使用Ruby on Rails来开发软件并不代表我们就必须使用Ruby on Rails。而长远看来，这是不利的。</td></tr><tr><td>即便我们的软件目前并不复杂，但是之后呢？在真正的用户开始使用软件之前，我们是无法预测软件的复杂性的，但是在右边的“备注”栏中有一项可以帮助我们应对这种情况。请注意，如果有暗示说明系统已经足够复杂，这往往意味着我们的系统实际上比目前更加复杂，采用DDD吧。</td><td>3</td><td>这时我们有必要和领域专家一起探讨那些复杂的用例。如果领域专家：1.已经要求加入更复杂的功能。这表明软件已经开始变得复杂，此时单纯的CRUD是不能满足需求的。2.认为既有的功能没什么可以探讨的。此时我们的软件可能并不那么复杂。</td></tr><tr><td>软件的功能在接下来的几年里将不断变化，而你并不能预期这些变化只是些简单的改变。</td><td>4</td><td>DDD可以帮助你管理软件的复杂性，随着时间的推移，你可以对软件模型进行重构。</td></tr><tr><td>你不了解软件所要处理的领域。你的团队中也没有人曾经从事过该领域的开发工作。此时，软件很有可能是复杂的，因此你们应该讨论复杂等级。</td><td>5</td><td>你需要和领域专家一起工作了。你肯定也在前面的计分行中打了分，采用DDD吧。</td></tr></tbody></table><p>通过对以上DDD计分卡打分，我们可以得出以下结论：</p><blockquote><p>当我们在复杂性问题上犯错时，我们很难轻易地扭转颓势。</p><p>这意味着我们应该在项目计划早期便对简单性和复杂性做出判断，这将为我们节约很多时间和开销，并免除很多麻烦。</p><p>一旦我们做出了重要的架构决策，并且已经在该架构下进行了深入地开发，通常我们也被绑定在这个架构下了，所以在决定时一定要慎重。</p></blockquote><p>如果你对以上几点产生了共鸣，表明你已经在认真地思考问题了。</p><h2 id="三-名词解释"><a href="#三-名词解释" class="headerlink" title="三. 名词解释"></a>三. 名词解释</h2><h4 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h4><p><img src="https://img.hznu.asia/DDD/%E6%A6%82%E5%BF%B5%E6%80%BB%E8%A7%88%E5%9B%BE.jpg"></p><h4 id="领域"><a href="#领域" class="headerlink" title="领域"></a><strong>领域</strong></h4><p>从广义上讲，领域(Domain)即是一个组织所做的事情以及其中所包含的一切。商业机构通常会确定一个市场，然后在这个市场中销售产品和服务。每个组织都有它自己的业务范围和做事方式。这个业务范围以及在其中所进行的活动便是领域。当你为某个组织开发软件时，你面对的便是这个组织的领域。这个领域对于你来说应该是明晰的，因为你在这个领域中工作。</p><blockquote><p>在DDD中，一个领域被分成若干子域，领域模型在限界上下文中完成开发。</p></blockquote><h4 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h4><p>领域模型是关于某个特定业务领域的软件模型。通常，领域模型通过对象模型来实现，这些对象同时包含了数据和行为，并且表达了准确的业务含义。</p><blockquote><p>要真正理解领域模型没有这么简单，这里只给出一个定义，要理解这个概念需要看下面的章节</p></blockquote><h4 id="领域对象"><a href="#领域对象" class="headerlink" title="领域对象"></a>领域对象</h4><p>领域对象的概念比较广泛，除了实体、值对象和聚合根外，服务也算是领域对象。领域层和应用层分别有领域服务和应用服务。</p><h4 id="领域专家"><a href="#领域专家" class="headerlink" title="领域专家"></a>领域专家</h4><p>领域专家并不是一个职位，他可以是精通业务的任何人。他们可能了解更多的关于业务领域的背景知识，他们可能是软件产品的设计者，甚至有可能是销售员。</p><h4 id="贫血领域模型"><a href="#贫血领域模型" class="headerlink" title="贫血领域模型"></a>贫血领域模型</h4><p>参考第五小节</p><h4 id="！充血模型"><a href="#！充血模型" class="headerlink" title="！充血模型"></a>！充血模型</h4><h4 id="通用语言"><a href="#通用语言" class="headerlink" title="通用语言"></a>通用语言</h4><p>通用语言是团队自己创建的公用语言，是团队共享的语言，团队中每个人都使用相同的通用语言。</p><p><strong>通用语言也会随着时间推移而不断演化改变。通用语言也不是强加在开发者身上的晦涩业务术语，在开始的时候，通用语言可能只包含由领域专家使用的术语，但是随着时间推移，通用语言将不断壮大成长</strong>。</p><p>理解通用语言要记住下面几点：</p><ul><li>这里的“通用”意思是“普遍的”，或者“到处都存在的”。</li><li>通用语言在团队范围内使用，并且只表达一个单一的领域模型。</li><li>“通用语言”并不表示全企业、全公司或者全球性的万能的领域语言。</li><li><strong>限界上下文和通用语言间存在一对一的关系。</strong></li><li>限界上下文是一个相对较小的概念，通常比我们起初想象的要小。限界上下文刚好能够容纳下一个独立的业务领域所使用的通用语言。</li><li>只有当团队工作在一个独立的限界上下文中时，通用语言才是“通用”的。</li><li>虽然我们只工作在一个限界上下文中，但是通常我们还需要和其他限界上下文打交道，这时可以通过上下文映射图（后文会解释）对这些限界上下文进行集成。每个限界上下文都有自己的通用语言，而有时语言间的术语可能有重叠的地方。</li><li>如果你试图将某个通用语言运用在整个企业范围之内，或者更大的、夸企业的范围内，你将失败。</li></ul><h4 id="限界上下文"><a href="#限界上下文" class="headerlink" title="限界上下文"></a><strong>限界上下文</strong></h4><p>就现在来说，可以将限界上下文看成是整个应用程序之内的一个概念性边界。这个边界之内的每种领域术语，词组或句子——也即通用语言，都有确定的上下文含义。在边界之外，这些术语可能表示不同的意思。</p><blockquote><p> 要真正理解限界上下文同样没有这么简单，这里只给出一个定义，要理解这个概念需要看下面的章节</p></blockquote><h4 id="子域"><a href="#子域" class="headerlink" title="子域"></a>子域</h4><ul><li><strong>核心子领域</strong>：能够体现系统愿景，具有产品差异化和核心竞争力的业务服务；</li><li><strong>通用子领域</strong>：包含的内容缺乏领域个性，具有较强的通用性，例如权限管理和邮件管理；</li><li><strong>支撑子领域</strong>：包含的内容多为“定制开发”，其为核心子领域的功能提供了支撑。</li></ul><h4 id="核心域"><a href="#核心域" class="headerlink" title="核心域"></a>核心域</h4><blockquote><p>对于核心域，个人觉得要结合例子比较好理解，可参考第六小节的“子域和限界上下文”中提到的核心域</p></blockquote><h4 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h4><p>在战略设计中最主要的工作只有两个：</p><ul><li><p><strong>领域划分</strong></p><p>通过对业务的拆解以及公司团队的业务定位，将业务场景分解，识别出核心领域、通用域、支撑域。并确定领域的边界以及领域间关系。</p></li><li><p><strong>领域建模</strong></p><p>通过业务场景，对用户故事以及用例的分析，梳理限界上下文，确定领域边界以及上下文映射图(Context Map)，建立领域模型，分析领域事件，聚合、实体、以及值对象。</p></li></ul><h4 id="战术设计"><a href="#战术设计" class="headerlink" title="战术设计"></a>战术设计</h4><p>战术设计是DDD的最终落地实现的阶段：</p><ul><li><p><strong>服务划分</strong></p><p>通过战略设计输出各个领域与限界上下文后，可以籍此进行微服务划分与设计，一个服务可以有多个聚合。</p></li><li><p><strong>领域模型</strong></p><p>通过战略设计中的领域建模，落地值对象、实体、领域服务、领域事件</p></li><li><p><strong>资源库</strong></p><p>确定聚合根之后，建立资源库，对领域对象的CRUD都通过资源库实现</p></li><li><p><strong>工厂</strong></p><p>负责领域对象的创建，用于封装复杂或者可能变化的创建逻辑</p></li><li><p><strong>聚合</strong></p><p>根据限界上下文，封装实体与值对象，并维持业务的完整性与统一性</p></li><li><p><strong>应用服务</strong></p><p>隔离防腐层与领域层，<strong>对领域进行服务编排与转发。</strong></p></li></ul><p>通常，战术建模比战略建模复杂。</p><p><img src="https://img.hznu.asia/DDD/%E6%88%98%E7%95%A5%E5%92%8C%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1.png"></p><h4 id="问题空间"><a href="#问题空间" class="headerlink" title="问题空间"></a>问题空间<img src="https://img.hznu.asia/DDD/%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1.png"></h4><p>问题空间是领域的一部分，对问题空间的开发将产生一个新的核心域。对问题空间的评估应该同时考虑已有子域和额外所需子域。因此，<strong>问题空间是核心域和其他子域的组合。</strong></p><p>问题空间中的子域通常随着项目的不同而不同，他们各自关注于当前的业务问题，这使得子域对于问题空间的评估非常有用。子域允许我们快速地浏览领域中的各个方面，这些方面对于解决特定的问题是必要的。</p><h4 id="解决方案空间"><a href="#解决方案空间" class="headerlink" title="解决方案空间"></a>解决方案空间</h4><p><strong>解决方案空间包括一个或多个限界上下文，即一组特定的软件模型。</strong>这是因为限界上下文即是一个特定的解决方案，它通过软件的方式来实现解决方案。</p><h4 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h4><p>简单对象访问协议是交换数据的一种协议规范，是一种轻量的、简单的、基于XML的协议，它被设计成在WEB上交换结构化的和固化的信息。</p><h4 id="敏捷开发流程"><a href="#敏捷开发流程" class="headerlink" title="敏捷开发流程"></a>敏捷开发流程</h4><ol><li><strong>目标制定：</strong>通过市场调研、业务思路、风险评估制定公司规划和目标；</li><li><strong>目标拆解：</strong>公司目标拆解到各个部门；</li><li><strong>产品规划：</strong>产品研发部门根据目标制定产品关键路线图，这个路线图中分布着不同的产品特性和其完成时间；</li><li><strong>组织产品待办列表：</strong>产品规划产生的需求、客户需求、市场人员收集到的缺陷等将组成产品待办列表；</li><li><strong>需求梳理：</strong>然后产品负责人(Product Ower)对这个列表进行梳理，并在需求梳理会(Backlog Grooming Meeting)讲解具体每一个需求，团队成员根据需求的复杂程度评估每个任务的工作量，输出本次迭代的待办事项列表，完成优先级排序等工作；</li><li><strong>迭代规划：</strong>通过Sprint计划会，明确要执行的工作、冲刺目标等，</li><li><strong>迭代开发：</strong>期间会进行每日站会、性能测试、CodeReview、Demo、测试等工作；</li><li><strong>Sprint评审：</strong>由每个任务的负责人演示其完整的工作，由PO确定Sprint目标是否完成，版本什么时候对外发布，新增bug的紧急程度等等。</li><li><strong>开回顾会议</strong>：回顾会议由Scrum团队检视自身在过去的Sprint的表现，包括人 、关系、过程、工具等，思考在下一个Sprint中怎么样可以表现得更好，更高效，怎么样可以和团队合作地更愉快。</li></ol><h2 id="四-为什么需要DDD"><a href="#四-为什么需要DDD" class="headerlink" title="四. 为什么需要DDD"></a>四. 为什么需要DDD</h2><p>第一小节总结了目前软件开发过程中常常会面临的问题，而DDD战略则可以有效解决这些问题，因此，我们需要DDD有如下原因：</p><ul><li>使领域专家和开发者在一起工作，这样开发出来的软件能够准确地传达业务规则。当然，对于领域专家和开发者来说，这并不表示单单地包容对方，而是将他们组成一个密切协作的团队。</li><li>“准确传达业务规则”的意思是说，此时的软件就像如果领域专家是编码人员时所开发出来的一样。</li><li>可以帮助业务人员自我提高。没有任何一个领域专家或者管理者敢说他对业务已经了如指掌了，业务知识也需要一个长期的学习过程。在DDD中，每个人都在学习，同时每个人又是知识的贡献者。</li><li>关键在于对知识的集中，因为这样可以确保软件知识并不只是掌握在少数人手中。</li><li>在领域专家、开发者和软件本身之间不存在“翻译”，意思是当大家都使用相同的语言进行交流时，每人都能听懂他人所说。</li><li>设计就是代码，代码就是设计。设计是关于软件如何工作的，最好的编码设计来自于多次试验，这得益于敏捷的发现过程。</li><li>DDD同时提供了战略设计和战术设计两种方式。战略设计帮助我们理解哪些投入是最重要的；哪些既有软件资产是可以重新拿来使用的；哪些人应该被加到团队中？战术设计则帮助我们创建DDD模型中各个部件。</li></ul><h4 id="4-1-业务价值"><a href="#4-1-业务价值" class="headerlink" title="4.1 业务价值"></a>4.1 业务价值</h4><p>软件开发者不应该只是热衷于技术，而是应该将眼界放得更宽。不管使用什么技术，我们的目的都是提供业务价值。而如果我们采用的技术确实产生了业务价值，人们就没有理由拒绝我们在技术上的建议。如果我们提供的技术方案比其他方案更能够产生业务价值，那么我们的业务能力也将增强。</p><p>使用DDD能收获的：</p><ol><li><p><strong>一个非常有用的领域模型</strong></p></li><li><p><strong>你的业务得到了更准确的定义和理解</strong></p></li><li><p><strong>领域专家可以为软件设计做出贡献</strong></p></li><li><p><strong>更好的用户体验</strong></p></li><li><p><strong>清晰的模型边界</strong></p></li><li><p><strong>更好的企业架构</strong></p></li><li><p><strong>敏捷、选代式和持续建模</strong></p></li></ol><p>DDD强调将精力花在对业务最有价值的东西上。我们并不过度建模，而是关注业务的<strong>核心域</strong>。</p><p>有些模型是用来支撑核心域的，它们同样是重要的。但是，这些起支撑作用的模型在优先级上没有核心域高。</p><h4 id="4-2-通用语言的好处"><a href="#4-2-通用语言的好处" class="headerlink" title="4.2 通用语言的好处"></a>4.2 通用语言的好处</h4><p>当人们对自己的核心业务有了更深的了解时，业务价值自然就出来了。领域专家并不总是同意某些概念和术语，有时，分歧源自于领域专家们在其他公司工作时所积累起来的经验，而有时分歧则源自于公司内部。</p><p>不管如何，当领域专家们在起工作时，他们最终将达成一致意见，这对于整个公司来说都是件好事。开发者和领域专家共享同一套交流语言，领域专家将知识传递给开发者。</p><p><strong>开发者总是会离开的。有可能去接触一个新的核心域。也有可能跳槽到其他公司。这时培训和工作移交也将变得更加简单。而“只有少数人才了解模型”的情况将大大减少。领域专家、剩下的开发者和新进人员可以继续使用通用语言进行交流。</strong></p><h2 id="五-什么是贫血领域模型"><a href="#五-什么是贫血领域模型" class="headerlink" title="五. 什么是贫血领域模型"></a>五. 什么是贫血领域模型</h2><h4 id="5-1-贫血领域模型简介"><a href="#5-1-贫血领域模型简介" class="headerlink" title="5.1 贫血领域模型简介"></a>5.1 贫血领域模型简介</h4><table><thead><tr><th align="left">领域对象病历表</th></tr></thead><tbody><tr><td align="left">软件组件经常使用的领域对象是否包含了系统主要的业务逻辑，并且多数情况下你需要调用那些getter和setter？你可能会将这样的客户代码称为服务层(Service Layer)或者应用层(Application Layer)代码。也或者，如果这描述的是你的用户界面，请回答“Yes”，然后好好反省一下，告诚自己一定不要再这么做了。</td></tr><tr><td align="left">你的领域对象中是不是主要是些公有的getter和setter方法，并且几乎没有业务逻辑，或者甚至完全没有业务逻辑——对象嘛，主要就是用来容纳属性值的？</td></tr><tr><td align="left">提示：正确的答案是：要么两项均为”Yes”，要么均为“No”</td></tr></tbody></table><p>如果你对以上两个问题的回答都是“No”，表明你的领域对象是健康的。如果都是“Yes”，表明你的领域对象已经病得不轻了，这便是<strong>贫血对象</strong>。</p><p>如果你对其中一个回答“Yes”，而另一个回答“No”，你可能是在自欺欺人。</p><blockquote><p>正如[Fowler， Anemic]所说，贫血领域对象是不好的，因为你花了很大的成本来开发领域对象，但是从中却获益甚少。比如，由于存在对象-关系阻抗失配(Object-Relational Impedance) ，开发者需要将很多时间花在对象和数据存储之间的映射上。这样的代价太大，而收益太小。<strong>我得说，你所说的领域对象根本就不是领域对象，而只是将关系型数据库中的模型映射到了对象上而已。</strong></p><p>这样的领域对象更像是活动记录(Active Record)，此时你可以对架构做个简化，然后使用事务脚本进行开发</p></blockquote><h4 id="5-2-活动记录、事物脚本和领域模型的关系"><a href="#5-2-活动记录、事物脚本和领域模型的关系" class="headerlink" title="5.2 活动记录、事物脚本和领域模型的关系"></a>5.2 活动记录、事物脚本和领域模型的关系</h4><p>历史上，事务脚本是第一个广泛应用的业务逻辑模式。后来出现了基于表数据的表模块模式，仍然属于过程式模式，但是加入了一些面向对象思维。</p><p>在面向对象开发兴起之后，出现了基于对象的业务逻辑模式，最简单的对象模型就像是数据库表的数据模型，这里的对象就是数据库中的记录，并加了一些额外的方法，这种模式通常叫做<strong>活动记录模式</strong>。</p><p>随着业务逻辑的复杂性越大，软件的抽象程度越高，这时就应该从领域着眼，创建一个领域驱动的对象模型，这种模式通常叫做<strong>领域模型</strong>。</p><p><strong>事务脚本模式</strong>鼓励你放弃所有的面向对象设计，将业务组件直接映射到需要的用户操作上。<strong>该模式的关注点在于用于通过表现层所能执行的操作，并为每个操作编写一个专门的方法，这就是事务脚本。</strong>不过数据访问层通常被封装到另一些组件中，并不属于脚本的一部分。</p><p>事务脚本就是一个简单的过程式模型，简单是事务脚本最值得一提的优势，对于逻辑不多，时间紧迫且依赖于强大的IDE的项目，事务脚本是其理想的选择。<strong>简单既是事务脚本的最大优势，同时也成为了它最大的劣势。</strong>事务脚本有造成代码重复的潜质，你会很容易的得到一系列完成类似任务的事务，最终应用程序变成了一团混乱的子程序组合。</p><h4 id="5-3-为什么会有贫血领域模型"><a href="#5-3-为什么会有贫血领域模型" class="headerlink" title="5.3 为什么会有贫血领域模型"></a>5.3 为什么会有贫血领域模型</h4><p>如果说贫血领域对象是由设计不当造成的，为什么还有如此多的人认为他们的领域对象是健康的呢？其中一个原因是：贫血领域对象反映了一种自然的过程式的编程风格，但这并不认为这是首要原因。</p><p>软件业中有很多开发者都是学着示例代码做开发的，这并不是什么坏事，只要示例代码本身是好的。然而，通常情况是，<strong>示例代码只是用尽可能简单的方式来展示某个特定的概念或者API特性，而并不强调要遵循多好的设计原则。</strong></p><p>一些极度简化的示例代码总是包含了大量的<code>getter/setter</code>，于是这些<code>getter/setter</code>随着示例代码每天被程序员们原封不动地来回复制。还有历史的影响。Microsoft的<code>Visual Basic</code>对我们现在的软件开发产生了很大的影响。并不是说<code>Visual Basic</code>是门不好的语言和集成开发环境(IDE)，因为它的确是种高效的开发方式，并且在某些方面对软件开发产生过正面的影响。</p><p>当然，有些人可能会拒绝<code>Visual Basic</code>的直接影响，但是最终它却间接地影响着每一个程序员。再比如现在十分流行的<code>IntelliJ IDEA</code> 也可以十分便捷地生成<code>getter/setter</code>，再或者是如今十分流行的<code>Lombok</code>插件，只需要一个<code>@Data</code>注解便可以做到，但是也间接埋下了隐患。</p><p>那这和贫血领域对象有什么关系呢？<code> JavaBean</code>标准最早是用来辅助Java的可视化设计工具的旨在将Microsoft的Active X开发方式带到Java平台。Java此举希望开创一个第三方自定义控件市场，就像Visual Basic一样。此后不久，几乎所有的框架和类库都涌入到了<code>JavaBean</code>潮流中，其中包括Java本身的<code>SDK/JDK</code>和第三方类库，比如<code>Hibernate</code>。在.NET平台推出之后，这样的趋势还在继续。</p><p>在早期的Hibernate版本中，所有需要持久化的领域对象都必须暴露公有的<code>getter/setter</code>，不管是对于简单类型的属性，还是对复杂类型皆如此。</p><p>这意味着，即便你希望将自己的<code>POJO</code> (Plain Old Java Object)设计成富含行为的对象，你都必须将对象的内部暴露给<code>Hibernate</code>以保存或重建对象。诚然，你可以隐藏公有的<code>JavaBean</code>接口，但是多数开发者都懒得这样做，或者甚至都不知道为什么应该这样做。</p><p>此外，多数的Web框架依然只支持<code>JavaBean</code>规范。如果你想将一个Java对象显示在网页上，该Java对象最好是支持<code>JavaBean</code>规范的。如果你想将HTML表单中的数据传到一个Java对象中，该Java对象也最好是支持<code>JavaBean</code>规范的。市场上的许多框架都要求对象暴露公有属性。这样一来，多数开发者只能被动地接受那些贫血对象。于是我们便到了“到处都是贫血对象”的地步。</p><blockquote><p>如今Hibernate可配置：</p><p><id>和<property>的属性access可以控制类属性的访问方式，缺省为property：</property></id></p><ol><li>access=”field”：表示让hibernate通过反射的方式直接访问field，丢失封装性；</li><li>access=”property”：表示让hibernate通过类对外暴露的getter/setter访问field，推荐；</li></ol></blockquote><h4 id="5-4-代码中的贫血对象"><a href="#5-4-代码中的贫血对象" class="headerlink" title="5.4 代码中的贫血对象"></a>5.4 代码中的贫血对象</h4><p>当你在阅读一个贫血领域对象的示例代码时，你通常会看到类似如下的代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void saveCustomer(String customerId，String customerFirstName，     String customerLastName，String streetAddressl， </span><br><span class="line">String streetAddress2，String city， String stateorProvince，</span><br><span class="line">String postalCode， String country，String home Phone， </span><br><span class="line">String mobilePhone，String primaryEmailAddress， </span><br><span class="line">String secondaryEmailAddress) &#123;</span><br><span class="line">Customer customer = customerDao.readCustomer(customerId)；</span><br><span class="line">if (customer == null) &#123;</span><br><span class="line">    customer = new Customer()；</span><br><span class="line">    customer.setCustomerId(customerId)；</span><br><span class="line">    &#125;</span><br><span class="line">    customer.setCustomerFirstName(customerFirstName)；</span><br><span class="line">    customer.setCustomerLastName(customerLastName)；</span><br><span class="line">    customer，setStreetAddress1(streetAddress1)；</span><br><span class="line">    customer.setstreetAddress2(streetAddress2)；</span><br><span class="line">    customer.setcity(city)；</span><br><span class="line">    customer.setstateorProvince(stateorProvince)；</span><br><span class="line">    customer.setPostalcode(postalCode)；</span><br><span class="line">    customer.setCountry (country)；</span><br><span class="line">    customer.setHomePhone(homePhone)；</span><br><span class="line">    customer.setMobilePhone(mobilePhone)；</span><br><span class="line">    customer.setPrimaryEmailAddress(primaryEmailAddress)；</span><br><span class="line">    customer.setSecondaryEmailAddress(secondaryEmailAddress)；</span><br><span class="line">    customerDao.saveCustomer(customer)；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上代码但是却帮助我们看到了一个欠妥的设计，我们可以将其重构成更好的模型。这里我们关注的并不是如何保存Customer数据，而是如何向模型中添加业务价值，即便就这个例子本身来说意义并不大。</p></blockquote><p>以上代码完成了什么功能呢？事实上，以上代码的功能是相当强大的。</p><p>不管个Customer是新建的还是先前存在的；不管是Customer的名字变了还是他搬进了新家；不管是他的家用电话号码变了还是他有了新的移动电话；也不管他是改用Gmail还是有了新的E-mail地址，这段代码都会保存这个Customer。</p><p>但是，真是这样的吗？其实，我们并不知道saveCustomer()方法的业务场景。为什么一开始会创建这个方法？有人知道它的本来意图吗，还是它原本就是用来满足不同业务需求的？几周或几个月之后，我们便将这些忘得一干二净了。下面请看看该方法的下一个版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void savecustomer(String customerId，String customerFirstName， </span><br><span class="line">String customerLastName，String streetAddressl， </span><br><span class="line">String streetAddress2，String city， String stateorProvince，</span><br><span class="line">String postalCode， String country，String home Phone， </span><br><span class="line">String mobilePhone， String primaryEmailAddress， </span><br><span class="line">String secondaryEmailAddressCustomer)&#123;</span><br><span class="line">customer = customerDao.readCustomer(customerId)</span><br><span class="line">if (customer == nul1) &#123;</span><br><span class="line">customer = new Customer()；</span><br><span class="line">customer.setCustomerId(customerId)；</span><br><span class="line">&#125; </span><br><span class="line">if (customerFirstName != null)&#123;</span><br><span class="line">customer.setCustomerFirstName(customerFirstName)；</span><br><span class="line">&#125;</span><br><span class="line">if (customerLastName != null)&#123;</span><br><span class="line">customer. setCustomerLastName(customerLastName)；</span><br><span class="line">&#125;</span><br><span class="line">if (streetAddressl != null)&#123;</span><br><span class="line">customer.setstreetAddress1(streetAddress1)；</span><br><span class="line">&#125;</span><br><span class="line">if (streetAddress2 != null)&#123;</span><br><span class="line">customer.setStreetAddress2(streetAddress2)；</span><br><span class="line">&#125;</span><br><span class="line">if (city != null)&#123;</span><br><span class="line">customer.setcity(city)；</span><br><span class="line">&#125;</span><br><span class="line">if (stateorProvince != null)&#123;</span><br><span class="line">customer.setStateOrProvince(stateorProvince)；</span><br><span class="line">&#125;</span><br><span class="line">if (postalCode != null)&#123;</span><br><span class="line">customer.setPostalCode (postalCode)；</span><br><span class="line">&#125;</span><br><span class="line">if (country != null)&#123;</span><br><span class="line">customer.setcountry (country)；</span><br><span class="line">&#125;</span><br><span class="line">if (home Phone != null)&#123;</span><br><span class="line">customer.setHome Phone (home Phone)；</span><br><span class="line">&#125;  </span><br><span class="line">if (mobilePhone != null)&#123;</span><br><span class="line">customer. setMobilePhone (mobilePhone)；</span><br><span class="line">&#125;</span><br><span class="line">if (primaryEmailAddress != null)&#123;</span><br><span class="line">customer.setPrimaryEmailAddress (primaryEmailAddress)；</span><br><span class="line">&#125;</span><br><span class="line">if (secondaryEmailAddress != null) &#123;</span><br><span class="line">customer.setsecondaryEmailAddress(secondaryEmailAddress)；</span><br><span class="line">&#125;</span><br><span class="line">customerDao.saveCustomer (customer)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法还算不上糟糕到了极点。很多时候数据-映射(datamapping)代码将变得非常复杂，此时大量的业务逻辑便不能反映在代码里了。</p><p>现在，除了<code>customerld</code>之外，所有的参数都是可选的，我们可以在某些业务场景下使用该方法。但是，我们就能说这是好的代码吗？<strong>我们如何测试这段代码以保证在错误的业务场景下该段代码不应该保存一个Customer呢？</strong>都不用讨论过多的细节我们便知道，在很多情况下该方法是不能正常工作的。</p><p>可能数据库约束会防止对非法状态的保存，但你是不是又得去查看数据库啦？你会在Java对象属性和数据库表的列名之间辗转反侧，然后可能发现你缺少数据库约束或者约束并不完全。</p><p>你可能会查看很多客户代码，然后比较代码历史，找出<code>saveCustomer()</code>的来龙去脉。你会发现，没有人能够解释这个方法为什么会成为现在这个样子，也没有人知道究竟有多少客户代码在正确地使用<code>saveCustomer()</code>方法。要自己去搞明白这里，你需要花费大量的时间。</p><p>这个时候，领域专家是帮不上忙的，因为他们看不懂代码。即便领域专家能够看懂代码，他可能也会被这段代码搞得一头雾水。我们难道就不能用另外一种方式来改善这段代码吗？如果可以，怎么修改？</p><p>上面的<code>saveCustomer()</code>至少存在三大问题：</p><blockquote><ol><li><strong><code>saveCustomer()</code>业务意图不明确。</strong></li><li><strong>方法的实现本身增加了潜在的复杂性。</strong></li><li> <strong>Customer领域对象根本就不是对象，而只是一个数据持有器(data holder)。</strong></li></ol></blockquote><p>也许你会想，“我们的设计都是在白板上进行的啊。我们会绘制设计很多框图，只有大家都达成一致时，我们才开始编码实现。”</p><p>如果情况是这样，那么不要将设计和实现分开。<strong>在实施DDD时，设计就是代码，代码就是设计。换句话说，白板图并不是设计，而只是我们讨论模型的一种方式。</strong></p><blockquote><p><strong>事实上，我平时采用的事物脚本模式是过程式编程，真正的面向对象编程是领域模型，而我之前一直认为将业务逻辑分层，创建几个类就是面向对象编程，其实不是这样的。</strong></p></blockquote><h4 id="5-5-改造"><a href="#5-5-改造" class="headerlink" title="5.5 改造"></a>5.5 改造</h4><p>现在，我们重新设计<code>saveCustomer()</code>，来看一下上述例子通过DDD改造之后的样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Customer&#123;</span><br><span class="line">public void changePersonalName( String firstName，  String lastName)；</span><br><span class="line">public void postalAddress(PostalAddress postalAddress)；</span><br><span class="line">public void relocateTo(PostalAddress changedPostalAddress)；</span><br><span class="line">public void changeHomeTelephone(Telephone telephone)；</span><br><span class="line">public void disconnectHomeTelephone()；</span><br><span class="line">public void changeMobileTelephone(Telephone telephone)；</span><br><span class="line">public void disconnectMobileTelephone()；</span><br><span class="line">public void primaryEmailAddress(EmailAddress emailAddress)；</span><br><span class="line">public void secondaryEmailAddress(EmailAddress emailAddress)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，以上的Customer并不是一个完美的模型，然而在实施DDD时，对设计的反思正是我们所期望的。</p><p>作为一个团队，我们可以自由地讨论什么样的模型才是最好的，在对通用语言达成了一致之后，才开始着手开发。然而，即便我们可以对通用语言进行一遍又一遍地提炼，此时上面的例子已经能够反映出一个Customer应该支持的业务操作了。</p><p><strong>另外，我们还应该知道，对领域模型的修改也将导致对应用层的修改。每一个应用层的方法都对应着一个单一的用例流：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void changeCustomerPersonalName(String customerId， String         customerFirstName，String customerLastName)&#123;</span><br><span class="line">Customer customer = customerRepository.customerofId (customerId)；</span><br><span class="line">if(customer null)&#123;</span><br><span class="line">throw new IllegalstateException(&quot;Customer does notexist.&quot;)；</span><br><span class="line">&#125;</span><br><span class="line">customer.changePersonalName(customerFirstName， customerLastName)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这和最开始的<code>saveCustomer()</code>例子是不同的，在那个例子中，我们使用了同一个方法来处理多个用例流。</p><p><strong>在这个新的例子中，我们只用一个应用层方法来修改Customer的姓名，除此之外，该方法别无其他业务功能。</strong></p><p><strong>因此，在使用DDD时，我们应该对照着模型的修改相应地修改应用层。同时，这也意味着用户界面所反映的用户操作也变得更加狭窄。</strong>但是无论如何，这个特定的应用层方法不再要求我们在用户姓名参数之后跟上10个null了。</p><h4 id="5-6-常见写法举例并对其改造"><a href="#5-6-常见写法举例并对其改造" class="headerlink" title="5.6 常见写法举例并对其改造"></a>5.6 常见写法举例并对其改造</h4><p>如果我们只是对领域模型提供getter和setter会怎么样？</p><p>答案是，结果我们只是在创建纯数据模型。</p><p>看看下面的两个例子，思考一下，哪一个在设计上是欠妥的，哪一个对客户代码更有益。</p><p>在这两个例子中是一个Scrum（敏捷开发）模型，我们需要将一个待定项(Backlog Item)提交到冲刺(Sprint， 见第二节敏捷开发流程)中去。</p><p><strong>第一个例子</strong></p><p>实体类代码通常如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BacklogItem extends Entity &#123;</span><br><span class="line">private SprintId sprintId；</span><br><span class="line">private BacklogItemStatusType status；</span><br><span class="line">public void setsprintId(SprintId sprintId)&#123;</span><br><span class="line">this.sprintId = sprintId；</span><br><span class="line">&#125;</span><br><span class="line">public void setstatus(BacklogItemStatusType status)&#123;</span><br><span class="line">this.status = status；</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">backlogItem.setSprintId(sprintId)；</span><br><span class="line">backlogItem.setStatus(BacklogItemStatusType.COMMITTED)；</span><br></pre></td></tr></table></figure><p><strong>第二个例子：</strong></p><p>实体类代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class BacklogItem extends Entity&#123;</span><br><span class="line">private SprintId sprintId；</span><br><span class="line">private BacklogItemStatusType status；</span><br><span class="line">public void commitTo (Sprint aSprint)&#123;</span><br><span class="line">if (!this.isScheduledForRelease())&#123;</span><br><span class="line">throw new IllegalStateException(</span><br><span class="line">&quot;Must be scheduled for release to commit to sprint.&quot;)；</span><br><span class="line">&#125;</span><br><span class="line">if (this.isCommittedToSprint()) &#123;</span><br><span class="line">if (!aSprint.sprintId().equals(this.sprintId ()))&#123;</span><br><span class="line">this.uncommitFromSprint()；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        this.elevateStatuswith(BacklogItemStatus.COMMITTED)；</span><br><span class="line">        this.setSprintId(aSprint.sprintId())；</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backlogItem.commitTo (sprint)；</span><br></pre></td></tr></table></figure><p>第一个例子采用的是以数据为中心的方式，此时客户代码必须知道如何正确地将一个待定项提交到冲刺中，这样的模型是不能称为领域模型的。</p><p>如果客户代码错误地修改了<code>sprintld</code>，而没有修改<code>status</code>会发生什么呢？或者，如果在将来有另外个属性需要设值时又该怎么办？</p><p>我们需要认真分析客户代码来完成从客户数据到<code>BacklogItem</code>属性的映射。这种方式同时也暴露了<code>BacklogItem</code>的数据结构，并且将关注点集中在数据属性上，而不是对象行为。你可能会反驳道：” <code>setSprintld()</code>和<code>setStatus()</code>就是行为啊。”</p><p><strong>问题在于，这里的“行为”没有真正的业务价值，它并没有表明领域模型中的概念一一此处即“将待定项提交到冲刺中”。</strong></p><p>开发者在开发客户代码时，他并不清楚到底需要为<code>Backlogltem</code>的哪些属性设值，而这样的属性有可能存在很多，因为这是一个以数据为中心的模型。现在，我们来看看第二个例子。<strong>有别于第一个例子，它将行为暴露给客户，行为方法的名字清楚地表明了业务含义。</strong></p><p>这个领域的专家在建模时讨论了以下需求：</p><blockquote><p>允许将每一个待定项提交到冲刺中。只有在一个待定项位于发布计划(Release)中时才能进行提交。</p></blockquote><p>在第二个例子中，客户代码并不需要知道提交<code>Backlogltem</code>的实现细节。实现代码所表达的逻辑恰好能够描述业务行为。我们很容易地添加了几行代码，以确保在发布计划之外的待定项是不能被提交的。</p><p>虽然在第一个例子中，你可以修改getter以达到同样的目的，但此时该getter的职责便不单一了，它需要了解<code>Backlogltem</code>对象的内部状态，而不再只是对<code>sprintld</code>和<code>status</code>属性赋值。</p><blockquote><p>大白话讲我的理解：比如你需要判断这个代办项是否在发布计划中，那么你就需要使用getter取出这个“是否在发布计划的状态”判断，这样你就需要了解这个对象的内部有哪些属性，并了解属性的含义。</p><p>但是使用DDD你不需要，因为这些都是在领域建模阶段去做的。</p></blockquote><h2 id="六-领域、子域和限界上下文"><a href="#六-领域、子域和限界上下文" class="headerlink" title="六. 领域、子域和限界上下文"></a>六. 领域、子域和限界上下文</h2><h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><p>从广义上讲，领域(Domain)即是一个组织所做的事情以及其中所包含的一切。商业机构通常会确定一个市场，然后在这个市场中销售产品和服务。每个组织都有它自己的业务范围和做事方式，这个业务范围以及在其中所进行的活动便是领域。当你为某个组织开发软件时，你面对的便是这个组织的领域。这个领域对于你来说应该是很清楚的，因为你在这个领域中工作。</p><p><strong>在DDD中，一个领域被分为若干子域，领域模型在限界上下文中完成开发</strong>。事实上，在开发一个领域模型时，我们关注的通常只是这个业务系统的某个方面。试图创建一个全功能的领域模型是非常困难的，并且很容易导致失败。</p><p>其实，对领域的拆分将有助于我们成功。那么，既然领域模型不能包含整个业务系统，我们应该如何来划分领域模型？<strong>几乎所有软件的领域都包含多个子域，这和软件系统本身的复杂性没有太大关系。</strong>有时，一个业务系统的成功取决于它所提供的多种功能，而将这些功能分开对待是有好处的。</p><h4 id="子域和限界上下文"><a href="#子域和限界上下文" class="headerlink" title="子域和限界上下文"></a>子域和限界上下文</h4><p>对于如何使用子域，让我们先来看一个非常简单的例子——一个零售商在线销售产品的例子。要在这个<strong>领域</strong>中开展业务，该零售商必须向买家展示不同，类别的产品，允许买家下单和付款，还需要安排物流。</p><p>在这个领域中，零售商的领域可以分为4个主要的<strong>子域</strong>：产品目录(Product Catalog)、订单(Order)、发票(Invoicing)和物流(Shipping)。</p><p>图6.1的上半部分表示了这样一个电子商务系统。这看来是非常简单的，但是，如果我们再向其中加入一个额外的细节，以上这个例子将变得复杂起来。</p><p>思考一下，如果我们向以上的电子商务系统中再加入一个库存(Inventory)系统，如图6.1所示，情况会变得如何？我们先来看看图6.1所展示的物理子系统和逻辑子域。</p><p>该零售商的领域中只包含了三个物理系统（电子商务系统、库存系统和外部的预测系统），其中有两个是内部系统。这两个内部系统表示两个限界上下文，但是，由于现在多数软件系统并没有采用DDD，这导致了少数的几个子系统承担了太多的业务功能。</p><p><img src="https://img.hznu.asia/DDD/DDD%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%88%92%E5%88%86%E5%9B%BE.png"></p><p>​                                                                                                图 6.1</p><p><strong>在上面的电子商务限界上下文中，我们可以找出多个隐式的领域模型，因为它们并没有被很好地分离出来。这些领域模型被融合成了一个软件模型，这是不正确的做法。</strong></p><p>对于该零售商来说，与其自己开发，还不如从第三方购买这么个限界上下文，因为这样所带来的问题可能会少一些。然而，不管是谁来维护这个系统，它都将承受这个大而全的电子商务模型所带来的负面影响。</p><p>随着各个逻辑模型中不断加人新的功能，它们之间的复杂关系对于每一个模型都将是阻碍，特别是需要引人另外一个逻辑模型的时候。这些问题的原因通常都是由于软件的关注点没有得到清晰的划分所致。</p><p>更不幸的是，很多软件开发者都认为将所有东西都放在一个系统里面是一件好事。<strong>他们会想：“我对电子商务系统了如指掌，我相信这个系统可以满足任何人的需求。”这是很有迷惑性的想法，因为不管你向系统中添加多少功能，你都无法满足每一个潜在客户的需求。</strong></p><p>此外，如果不通过子域对软件模型进行划分，事情将变得更加烦琐，因为系统中的各个部分都是紧密联系在一起的。</p><p>然而，通过使用DDD战略设计工具，我们可以按照实际功能将这些交织的模型划分成逻辑上相互分离的子域，从而在一定程度上减少系统的复杂性。</p><p>逻辑子域的边界在图6.1中以虚线表示。这里，我们将第三方的模型也做了清晰地划分，但这不是我们的重点，我们的重点在于说明应该存在什么样的分离模型。</p><p>在不同的逻辑子域之间或者不同的物理限界上下文之间均画有连线，这表示它们之间存在集成关系。</p><p><strong>现在，让我们将视线从技术复杂性转向这个零售商的业务复杂性。</strong></p><p>该零售商的资金和仓库容量均有限。对于那些销量不佳的产品，该零售商不敢过量投人。如果有产品没有按照计划销售出去，那么该零售商的流动资金将出现问题。因此，它只能用有限的仓库来存储那些销量好的产品。事实上，导致库存清空的原因并不是产品销售得异常好，而是该零售商没有找到一种最优的库存管理方式。</p><p>零售商可以采用一个预测引擎，根据库存和销售历史来分析产品的需求量，从而达到优化库存系统的目的。</p><p><strong>对于小型零售商来说，增加预测引擎可能意味着开发一个新的核心域，</strong>这并不是一个容易解决的问题，但是可以大大增加竞争优势。在图6.1中的第三个限界上下文便是一个外部预测系统。</p><p>订单子域和库存限界上下文向预测系统提供历史销售数据。此外，我们还需要产品目录子域来提供全局的产品条目，这将有助于预测系统在全球范围之内对产品的销售情况进行比较。这样，预测系统可以精确地计算出产品的需求量，并指导零售商制定正确的库存计划。</p><p><strong>子域并不是一定要做得很大，也并不是需要并且包含很多功能。</strong>有时，子域可以简单到只包含一套算法，这套算法可能对于业务系统来说非常重要，但是并不包含在核心域之中。</p><p><strong>在正确实施DDD的情况下，这种简单的子域可以以模块(Module)的形式从核心域中分离出来，而不需要包含在笨重的子系统组件中。</strong>在实施DDD的时候，我们致力于将限界上下文中领域模型所用到的每一个术语都进行限界划分。这种限界主要是语言层面上的上下文边界，也是实现DDD的关键。</p><p>其次，一个限界上下文<strong>并不一定</strong>只包含在一个子域中。在图6.1中，只有库存限界上下文包含在了一个子域中。显然，这表明这个电子商务系统在开发的时候并没有正确地采用DDD。</p><p>在上面的电子商务系统中，当我们谈到其中有4个子域时，我们可以看出有些术语在这些子域中是存在冲突的。比如，“顾客”这个术语可能有多种含义。<strong>在浏览产品目录的时候，，“顾客”表示一种意思；而在下单的时候，“顾客”又表示另一种意思。原因在于：当浏览产品目录时， “顾客”被放在了先前购买情况、忠诚度、折扣这样的上下文中。而在下单时， “顾客”的上下文包括名字、产品寄送地址、订单总价和一些付款术语。</strong></p><p>如果不对”产品目录子域“和”订单子域“进行划分，那么在这个电子商务系统中，“顾客”并没有一个清晰的含义。我们甚至还可以找到很多像“顾客”这样拥有多重含义的术语。<strong>在一个好的限界上下文中，每一个术语应该仅表示一种领域概念。</strong></p><p>同样的，我们看到图6.1中库存系统仅仅包含在”库存子域“中，然而，这里也存在有歧义的术语，因为库存件可能用在不同的环境下。</p><p>比如，有的库存件已经被订购了，有的正在运送途中，有的正保存在仓库中，而有的正被移出仓库。</p><p>已经被订购但还无法销售的产品称为延期订单件；保存在仓库中的产品称为积压件；刚被购买的产品称为即将发送件；而被损坏的库存产品称为无用件。</p><p>在图6.1中，我们看不出以上这些库存概念。<strong>在DDD中，我们不能靠猜测，而应该对每个概念都给出明确的定义，并将这些明确的定义用在交流和建模中。</strong></p><p><strong>图6.1进一步表明，一个企业的限界上下文并不是孤立存在的。即便有第三方的电子商务系统可以提供一个全方位式的模型，它也不能完全满足零售商的需求。</strong>不同子域之间的实线表示集成关系，这也表明不同的模型是需要协同工作的。集成的方式有很多种，我们将在后面的上下文映射图小节讲到不同的集成方案。</p><h4 id="关注核心域"><a href="#关注核心域" class="headerlink" title="关注核心域"></a>关注核心域</h4><p>了解了子域和限界上下文，现在看看关于领域的另一个抽象视图，如图6.2所示。该抽象视图可以表示任何一个领域，甚至有可能是你正在工作的领域。和图6.1相比，这张图去除了那些具体的名字，你可以根据自己的项目情况进行填补。持续改进并且扩大业务目标将反映在不断变化的子域和子域模型中。图6.2仅仅表示某个时刻，从某个角度看的业务领域，这样的领域可能并不会驻留多久。</p><p><img src="https://img.hznu.asia/DDD/DDD%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%BB%86%E8%8A%82%E5%9B%BE.png"></p><p>​                                                                                                    图 6.2</p><p>在图6.2上半部分的领域边界，有一个叫核心域的子域。核心域是整个业务领域的一部分，也是业务成功的主要促成因素。在实施DDD的过程中，将主要关注于核心域。</p><p>图6.2中还展示了另外两种子域：支撑子域和通用子域。有时，我们会创建或者购买某个限界上下文来支撑我们的业务。<strong>如果这样的限界上下文对应着业务的某些重要方面，但却不是核心，那么它便是一个支撑子域。</strong>创建支撑子域的原因在于它们专注于业务的某个方面，否则，<strong>如果一个子域被用于整个业务系统，那么这个子域便是通用子域。</strong>我们并不能说支撑子域和通用子域是不重要的，它们是重要的，只是我们对它们的要求并不像核心域那么高。</p><h4 id="理解限界上下文"><a href="#理解限界上下文" class="headerlink" title="理解限界上下文"></a>理解限界上下文</h4><p>在很多情况下，在不同模型中存在名字相同或相近的对象，但是它们的意思却不同。当模型被一个显式的边界所包围时，其中每个概念的含义便是确定的了。因此，<strong>限界上下文主要是一个语义上的边界，我们应该通过这一点来衡量对一个限界上下文的使用正确与否。</strong></p><p><strong>有些项目试图创建一个“大而全”的软件模型，其中每个概念在全局范围之内只有一种定义，这是一个陷阱。首先，要使所有人都对某个概念的定义达成一致几乎不可能。有些项目太庞大，太复杂，以致于你根本无法将所有的利益相关方聚集到一起，更不用提达成一致了。</strong></p><p><strong>即便是那些规模相对较小的公司，要维持一个全局性的，并且经得住时间考验的概念定义也是困难的。因此，最好的方法是去正视这种不同，然后使用限界上下文对领域模型进行分离。</strong></p><p><strong>限界上下文并不旨在创建单一的项目资产，它并不是一个单独的组件、文档、或者框图，它也并不一个是JAR包。</strong></p><p>我们来看一个例子，假如有一家图书出版机构，他们在图书出版过程中，需要经历以下几个步骤：</p><ul><li>概念设计，计划出书</li><li>联系作者，签订合同</li><li>管理图书的编辑过程</li><li>设计图书布局，包括插图</li><li>将图书翻译成其他语言</li><li>出版纸质版或电子版图书市场营销</li><li>将图书卖给销售商或直接卖给读者</li><li>将图书发送给销售商或读者</li></ul><p>在以上所有阶段中，我们可以用一个单一的概念对图书建模吗？显然不行。在每个阶段中，“图书”都有不同的定义。一本书只有在和作者签订了合同之后才能拥有书名，而书名可能在编辑过程进行修改。在编辑过程中，图书包含了一系列的稿件，其中包括注释和校正等，之后会有一份最终稿件。页面布局由专门的图形设计师完成。图书印刷方使用页面布局和封面板式印制图书。市场营销员不需要编辑稿件或图书印制成品，他们可能只需要图书的简介即可。对于图书的售后物流，我们需要的是图书的标识码、物流目的地、数目、尺寸和重量等。</p><p>如果我们使用一个单一模型来处理所有这些阶段会发生什么？</p><p>概念混淆、意见分歧和争论是不可避免的，我们所交付的软件也没有多大价值。即便有时我们可能会得到一个正确的公共模型，但这种模型并不具有持久性。</p><p><strong>为了解决这个问题，我们应该为每个阶段创建各自的限界上下文。在每个限界上下文中，都存在某种类型的图书。在几乎所有的上下文中，不同类型的图书对象将共享一个身份标识(identity)，这个标识可能是在概念设计阶段创建的，</strong></p><p>在使用显式限界上下文的情况下，我们可以定期地、增量式的交付软件，同时所交付的软件又能满足特定的业务需求。</p><h4 id="限界上下文的大小"><a href="#限界上下文的大小" class="headerlink" title="限界上下文的大小"></a>限界上下文的大小</h4><p>在使用Java时，我们可能从技术层面上将一个限界上下文放在一个JAR文件中，包括WAR或EAR文件。这种做法可能受到了模块化的影响。<strong>松耦合的领域模型应该放在不同的JAR文件中，这样我们可以按照版本号对领域模型进行单独部署。</strong></p><p>对于大型的模型来说，这种做法是非常有用的。将单个大模型分成多个JAR文件也有助于版本管理.</p><p>因此，不同的高层模块，包括它们的版本和依赖都可以通过捆包/模块(bundles/modules)进行管理。</p><h4 id="限界上下文的例子"><a href="#限界上下文的例子" class="headerlink" title="限界上下文的例子"></a>限界上下文的例子</h4><p><img src="https://img.hznu.asia/DDD/%E8%BA%AB%E4%BB%BD%E4%B8%8E%E8%AE%BF%E9%97%AE%E4%B8%8A%E4%B8%8B%E6%96%87.png"></p><p>​                                                                                        图 6.3</p><p>现在看不懂上图没关系，先继续往后看，将有助于理解本图。</p><h2 id="七-上下文映射图"><a href="#七-上下文映射图" class="headerlink" title="七. 上下文映射图"></a>七. 上下文映射图</h2><h4 id="集成关系"><a href="#集成关系" class="headerlink" title="集成关系"></a>集成关系</h4><p>在DDD中，存在多种组织模式和集成模式，其中，有一种模式存在于任意两个限界上下文之间：</p><ul><li><strong>合作关系(Partnership) ：</strong>如果两个限界上下文的团队要么一起成功，要么一起失败，此时他们需要建立起一种合作关系。他们需要一起协调开发计划和集成管理。两个团队应该在接口的演化上进行合作以同时满足两个系统的需求。应该为相互关联的软件功能制定好计划表，这样可以确保这些功能在同一个发布中完成。</li><li><strong>共享内核(Shared Kernel)：</strong>对模型和代码的共享将产生一种紧密的依赖性，对于设计来说，这种依赖性可好可坏。我们需要为共享的部分模型指定个显式的边界，并保持共享内核的小型化。共享内核具有特殊的状态，在没有与另一个团队协商的情况下，这种状态是不能改变的。我们应该引人种持续集成过程来保证共享内核与通用语言(1)的一致性。</li><li><strong>客户方-供应方开发(Customer-Supplier Development) ：</strong>当两个团队处于种上游-下游关系时，上游团队可能独立于下游团队完成开发，此时下游团队的开发可能会受到很大的影响。因此，在上游团队的计划中，我们应该顾及到下游团队的需求。</li><li><strong>遵奉者(Conformist) ：</strong>在存在上游-下游关系的两个团队中，如果上游团队已经没有动力提供下游团队之所需，下游团队便孤军无助了。出于利他主义，上游团队可能向下游团队做出种种承诺，但是有很大的可能是：这些承诺是无法实现的。下游团队只能盲目地使用上游团队的模型，</li><li><strong>防腐层(Anticorruption Layer) ：</strong>在集成两个设计良好的限界上下文时，翻译层可能很简单，甚至可以很优雅地实现。但是，当共享内核、合作关系或客户方-供应方关系无法顺利实现时，此时的翻译将变得复杂。对于下游客户来说，你需要根据自己的领域模型创建一个单独的层，该层作为上游系统的委派向你的系统提供功能。防腐层通过已有的接口与其他系统交互，而其他系统只需要做很小的修改，甚至无须修改。在防腐层内部，它在你自己的模型和他方模型之间进行翻译转换。</li><li><strong>开放主机服务(Open Host Service) ：</strong>定义一种协议，让你的子系统通过该协议来访问你的服务。你需要将该协议公开，这样任何想与你集成的人都可以使用该协议。在有新的集成需求时，你应该对协议进行改进或者扩展。对于一些特殊的需求，你可以采用一次性的翻译予以处理，这样可以保持协议的简单性和连贯性。</li><li><strong>发布语言(Published Language) ：</strong>在两个限界上下文之间翻译模型需要种公用的语言。此时你应该使用一种发布出来的共享语言来完成集成交流。发布语言通常与开放主机服务一起使用。</li><li><strong>另谋他路(SeparateWay)：</strong>在确定需求时，我们应该做到坚决彻底。如果两套功能没有显著的关系，那么它们是可以被完全解耦的。集成总是昂贵的，有时带给你的好处也不大。声明两个限界上下文之间不存在任何关系，这样使得开发者去另外寻找简单的、专门的方法来解决问题。</li><li><strong>大泥球(Big Ball of Mud)：</strong>当我们检查已有系统时，经常会发现系统中存在混杂在一起的模型，它们之间的边界是非常模糊的。此时你应该为整个系统绘制一个边界，然后将其归纳在大泥球范围之列。在这个边界之内，不要试图使用复杂的建模手段来化解问题。同时，这样的系统有可能会向其他系统蔓延，应该对此保持警觉。</li></ul><h4 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h4><p>在上下文映射图中，我们使用以下缩写来表示各种关系：</p><ul><li>ACL表示防腐层</li><li>OHS表示开放主机服务</li><li>PL表示发布语言</li></ul><h4 id="简单的映射图"><a href="#简单的映射图" class="headerlink" title="简单的映射图"></a>简单的映射图</h4><p><img src="https://img.hznu.asia/DDD/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%84%E9%9B%86%E6%88%90%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p><p>​                                                                                                        图 7.1</p><p>从图7.1我们可以看到，该图有三种集成关系或模式，分别为<strong>防腐层、发布语言和开放主机服务</strong>。但是，仅仅从上面的术语定义并不能很好地理解这些含义，我们来详细解释下：</p><ul><li>开放主机服务：该模式可以通过REST实现。通常来讲，我们可以将开放主机服务看成是远程过程调用(Remote ProcedureCall， RPC)的API。同时，它也可以通过消息机制实现。</li><li>发布语言：发布语言可以通过多种方式实现，比较常见的是使用XML Schema。在使用REST服务时，发布语言用来表示领域概念，此时可以使用<code>XML</code>和<code>JSON</code>。发布语言也可以使用Google的协议缓冲(Protocol Buffer)来表示。如果你打算发布Web用户界面，你也可以使用HTML。使用REST的好处在于每个客户端都可以指明使用哪种发布语言，同时还可以指明资源的展现方法。</li><li>防腐层：在下游上下文中，我们可以为每个防腐层定义相应的领域服务(Domain Service)。同时，你也可以将防腐层用于资源库接口。在使用REST时，客户端的领域服务将访问远程的开放主机服务，远程服务器以发布语言的形式返回，下游的防腐层将返回内容翻译成本地上下文的领域对象。比如，协作上下文向身份与访问上下文请求“具有Moderator角色的用户”。所返回的数据可能是<code>XML</code>格式或<code>JSON</code>格式，然后防腐层将这些数据翻译成协作上下文中的Moderator对象，该对象是一个值对象。这个Moderator实例反映的是下游模型中的概念，而不是上游模型。</li></ul><p>在图7.1中，身份与访问上下文通过REST的方式向外发布服务。作为该上下文的客户，协作上下文通过传统的类似于RPC的方式获取外部资源。</p><p>协作上下文并不会永久性地记录下从身份与访问上下文中获取来的数据，而是在每次需要数据时重新向远程系统发出请求。显然，协作上下文高度依赖于远程服务，它不具有自治性。</p><p>并且这还存在一个问题，如果由于远程系统不可用而导致同步请求失败，那么本地系统也将跟着失败。此时本地系统将通知用户所发生的问题，并告诉用户稍后重试。系统集成通常依赖于RPC。从高层面上看，RPC与编程语言中的过程调用非常相似。</p><p>然而，和在相同进程空间中进行过程调用不同的是<strong>，远程调用更容易产生有损性能的时间延迟，并且有可能导致调用彻底失败。</strong>网络和远程系统的加载过程都是RPC产生延迟的原因。当RPC的目标系统不可用时，用户对你系统的请求也将失败。虽然REST并不是真正意义上的RPC，但它却具有与RPC相似的特征。彻底的系统失败并不多见，但<strong>它却是一个潜在的问题</strong>。</p><p><img src="https://img.hznu.asia/DDD/%E5%8D%8F%E4%BD%9C%E5%92%8C%E8%BA%AB%E4%BB%BD%E4%B8%8A%E4%B8%8B%E6%96%87%E9%9B%86%E6%88%90.png"></p><p>​                                      图7.2 协作上下文和身份与访问上下文集成时的防腐层和开放主机服务</p><p>其中一种解决方案是将系统所依赖的状态存在本地，那么我们将获得更大的自治性。有人可能认为这只是对所有的依赖对象进行缓存，但这不是DDD的真正的做法。</p><p>DDD的做法是：<strong>在本地创建一些由外部模型翻译而成的领域对象，这些对象保留着本地模型所需的最小状态集。为了初始化这些对象，我们只需要有限的RPC调用或REST请求。</strong>然而，要与远程模型保持同步，最好的方式是在远程系统中采用面向消息的通知(notification)机制。消息通知可以通过服务总线进行发布，也可以采用消息队列或者REST。</p><blockquote><p>举个简单的例子也许更好理解：假如有一个领域对象，他有一个属性，这个属性的值分为多种，每种描述的字符串都很长很长，这时候，我们可以用0、1、2…等等数字来代表这些不同的属性值并做好约定，这时候我们将这些数字代表的属性值的长长的字符串存在本地，只在RPC调用或REST请求中传递这些数字即可，大大降低开销。当然，这只是一个非常简单的例子帮助你理解DDD的做法。</p><p>而后一句提到的消息通知机制在我们目前的微服务框架中也是这样做的，目前由于只是DDD初步入门，不展开讲解。</p></blockquote><h2 id="八-架构"><a href="#八-架构" class="headerlink" title="八. 架构"></a>八. 架构</h2><p><strong>DDD的一大好处便是它并不需要使用特定的架构</strong>。由于核心域位于限界上下文中，我们可以在整个系统中使用多种风格的架构。</p><p>在选择架构风格和架构模式时，我们应该将软件质量考虑在内，而同时，避免滥用架构风格和架构模式也是重要的。质量驱动的架构选择是种风险驱动方式[Fairbanks]，即我们采用的架构是用来减少失败风险的，而不是增加失败风险。因此，我们必须对每种架构做出正确的评估。</p><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>分层架构模式被认为是所有架构的鼻祖。它支持N层架构系统，因此被广泛地应用于Web、企业级应用和桌面应用。在这种架构中，我们将一个应用程序或者系统分为不同的层次。</p><p>在分层架构中，我们将领域模型和业务逻辑分离出来，并减少对基础设施、用户界面甚至应用层逻辑的依赖，因为它们不属于业务逻辑。将一个复杂的系统分为不同的层，每层都应该具有良好的内聚性，并且只依赖于比其自身更低的层。</p><p>分层架构的一个重要原则是：每层只能与位于其下方的层发生耦合。</p><p><img src="https://img.hznu.asia/DDD/DDD%E7%9A%84%E4%BC%A0%E7%BB%9F%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.png"></p><p>​                                                                    图 8.1 DDD的传统分层架构</p><p>分层架构也分为几种：在<strong>严格分层架构</strong>(Strict Layers Architecture)中，某层只能与直接位于其下方的层发生耦合；而松散分层架构(Relaxed Layers Architecture)则允许任意上方层与任意下方层发生耦合。</p><p>由于用户界面层和应用服务通常需要与基础设施打交道，许多系统都是基于松散分层架构的。但是，较低层也是可以和较高层发生耦合的，但这只局限于采用观察者(Observer)模式或者调停者(Mediator)模式的情况。较低层是绝对不能直接访问较高层的。</p><blockquote><p>传统3层架构也是严格分层，controller-service-dao。 DDD相当于将service拆分成两层：应用层和领域层。领域内的业务逻辑在领域层里，而应用层负责跨领域逻辑处理、业务编排。</p></blockquote><p>应用服务(Application Services)位于应用层中。应用服务和领域服务(Domain Services)是不同的，因此领域逻辑也不应该出现在应用服务中。</p><p>应用服务可以用于控制持久化事务和安全认证，或者向其他系统发送基于事件的消息通知，另外还可以用于创建邮件以发送给用户。<strong>应用服务本身并不处理业务逻辑，但它却是直接面向领域模型。</strong>应用服务是很轻量的，它主要用于协调对领域对象的操作，比如聚合等等。</p><p>一种比较好的应用服务例子是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void commitBacklogI temToSprint(String aTenantId， String aBacklogItemId，</span><br><span class="line">String aSprintId)&#123;</span><br><span class="line">TenantId tenantId = new TenantId (aTenant Id)；</span><br><span class="line">BacklogItem backlogItem = backlogItemRepository.backlogitemofId(tenantId， new BacklogItemId (aBacklogItemId))；</span><br><span class="line">Sprint sprint = sprintRepository.sprintofId(tenantId， new SprintId(aSprintId))；</span><br><span class="line">backlogItem.commitTo (sprint)；</span><br></pre></td></tr></table></figure><p>如果应用服务比上述功能复杂许多，这通常意味着领域逻辑已经渗透到应用服务中了，此时的领域模型将变成贫血模型。</p><p><strong>因此，最佳实践是将应用层做成很薄的一层。当需要创建新的聚合时，应用服务应该使用工厂或聚合的构造函数来实例化对象，然后采用资源库（也可以称作持久层）对其进行持久化。</strong></p><p>在图8.1的传统分层架构中，基础设施层位于底层，持久化和消息机制便位于该层中。这里的消息包含了消息中间件所发的消息、基本的电子邮件(SMTP)或者文本消息(SMS)。可以将基础设施层中所有的组件和框架看作是应用程序的低层服务，较高层与该层发生耦合以使用这些技术。即便如此，我们依然<strong>应该避免核心的领域模型对象与基础设施层发生直接耦合。</strong>怎么办呢？</p><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p>它通过改变不同层的依赖关系达到目的，他的定义为：</p><blockquote><p>高层模块不应该依赖于低层模块，两者都应该依赖于抽象。</p><p>抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>根据该定义，低层服务(比如基础设施层)应该依赖于高层组件(比如用户界面层、应用层和领域层)所提供的接口。在架构中采用依赖倒置原则有很多种表达方式，这里我们将采用图8.2中的方式。</p><p><img src="https://img.hznu.asia/DDD/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%89%8D%E5%90%8E%E5%AF%B9%E6%AF%94%E5%9B%BE.jpg"></p><p>​                                                                                        图 8.2</p><p>我们应该将关注点放在领域层上，采用依赖倒置原则，<strong>使领域层和基础设施层都只依赖于由领域模型所定义的抽象接口。</strong>由于应用层是领域层的直接客户，它将依赖于领域层接口，并且间接地访问资源库(持久层)和由基础设施层提供的实现。</p><p>如果仔细想想，我们可能会发现，当我们在分层架构中采用依赖倒置原则时，事实上已经不存在分层的概念了。<strong>无论是高层还是低层，它们都只依赖于抽象，好像把整个分层架构给推平了一样。</strong></p><p>这样讲也许还不是很明白，我们来讲解下DDD 各层的主要职责，帮助理解这种架构：</p><img src="https://img.hznu.asia/DDD/%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E5%9B%9B%E5%B1%82%E6%9E%B6%E6%9E%84.jpg" alt="优化后的四层架构" style="zoom: 67%；"><p>​                                                                                            图 8.3</p><p>图8.3是依赖倒置后的四层架构，如果只看图8.2的话很难理解依赖倒置有什么作用，我初看也是如此，原因在于不能理解每层的职责，但是图8.3便可以将依赖倒置后的作用很好地体现出来，我们一层层来看。</p><h5 id="用户接口层"><a href="#用户接口层" class="headerlink" title="用户接口层"></a><strong>用户接口层</strong></h5><p>用户接口层负责向用户显示信息和解释用户指令，一般是终端，比如web程序、批处理、接口等。大白话讲，可以看成用户在UI界面操作后，与用户操作进行交互的层，其实就相当于我们MVC三层架构的Controller层。</p><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>应用层是很薄的一层，理论上不应该有业务规则或逻辑，主要面向用例和流程相关的操作。但应用层又位于领域层之上，因为领域层包含多个聚合，所以它可以协调多个聚合的服务和领域对象完成服务编排和组合，协作完成业务操作。<strong>而我们MVC三层架构的应用层，往往包含了大量的业务逻辑，这是不符合DDD做法的。</strong></p><p>此外，应用层也是微服务之间交互的通道，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排。<strong>从DDD角度看微服务，其实一个领域就是一个服务。</strong></p><p>另外，应用服务是在应用层的，它负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装，以粗粒度的服务通过 API 网关向前端发布。此外，<strong>应用服务还可以进行安全认证、权限校验、事务控制、发送或订阅领域事件等。</strong></p><blockquote><p>如果对应spring的约定来看，应用层是service，领域层是repository，repository其实不应该是完全的、直接的映射表的增删改查，而是应暴露聚合根，内部完成对实体、值对象的操作，但就目前而言，常见的都是把repository当成DAO在用了。</p></blockquote><blockquote><p>Repository又称作<strong>资源库</strong>，资源库是一种封装存储、查询和搜索<strong>行为</strong>的机制，它是一个模拟的对象集合</p><p>DAO是<strong>Data Access Object</strong>的缩写，是一种结构型设计模式，用于<strong>分离业务层（应用）和持久化层（数据库）</strong>，DAO模式是一种分层的思想，可以理解为数据库操作的简单封装。</p></blockquote><h5 id="领域层（DDD中很重要的一层）"><a href="#领域层（DDD中很重要的一层）" class="headerlink" title="领域层（DDD中很重要的一层）"></a>领域层（DDD中很重要的一层）</h5><p>领域层的作用是实现企业核心业务逻辑，通过各种校验手段保证业务的正确性。<strong>领域层主要体现领域模型的业务能力，它用来表达业务概念、业务状态和业务规则</strong>。</p><p>领域层包含聚合根、实体、值对象、领域服务等领域模型中的领域对象。这里我要特别解释一下其中几个领域对象的关系，以便你在设计领域层的时候能更加清楚。</p><p><strong>首先，领域模型的业务逻辑主要是由实体和领域服务来实现的，其中实体会采用充血模型来实现所有与之相关的业务功能</strong>。其次，实体和领域服务在实现业务逻辑上不是同级的，当领域中的某些功能，单一实体（或者值对象）不能实现时，领域服务就会出马，它可以组合聚合内的多个实体（或者值对象），实现复杂的业务逻辑。（这里不懂没关系，我们后面还会讲到实体、值对象和聚合等）</p><h4 id="基础层"><a href="#基础层" class="headerlink" title="基础层"></a>基础层</h4><p><strong>基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。</strong></p><p><strong>基础层包含基础服务，它采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响。</strong></p><p><strong>比如说，在传统架构设计中，由于上层应用对数据库的强耦合，很多公司在架构演进中最担忧的可能就是换数据库了，因为一旦更换数据库，就可能需要重写大部分的代码，这对应用来说是致命的。那采用依赖倒置的设计以后，应用层就可以通过解耦来保持独立的核心业务逻辑。当数据库变更时，我们只需要更换数据库基础服务就可以了，这样就将资源变更对应用的影响降到了最低。</strong></p><p>对于依赖倒置设计可能不太好理解，我们来看一个例子：</p><p>现在有Person聚合根，Person聚合包括仓储接口和仓储实现。 通过增加仓储服务，使得<strong>应用逻辑和数据库逻辑的依赖关系剥离</strong>，当换数据库的时候，只需要将仓储实现替换就可以了，这样不会对核心的业务逻辑产生影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Person聚合根</span><br><span class="line"> */</span><br><span class="line">public class Person&#123;</span><br><span class="line">  private String id；</span><br><span class="line">  private String name；</span><br><span class="line">  private int age；   </span><br><span class="line">  private boolean gender；</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 其它方法</span><br><span class="line"> */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Person仓储接口</span><br><span class="line"> */</span><br><span class="line">public interface  PersonRepositoryInterface &#123;</span><br><span class="line">  void save(Person person)；  </span><br><span class="line">  void delete(String id)；  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *Person仓储实现</span><br><span class="line"> */</span><br><span class="line">@Repository</span><br><span class="line">public class PersonRepositoryImp implements PersonRepositoryInterface &#123;</span><br><span class="line">  private PersonMapper mapper；    </span><br><span class="line">  public void save( Person person) &#123;</span><br><span class="line">      mapper.create(person)；</span><br><span class="line">  &#125;</span><br><span class="line">  public void delete((String  id) &#123;</span><br><span class="line">    mapper.delete(id)；</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">在应用逻辑中直接用仓储的接口就可以了，数据库相关的逻辑在PersonMapper里面实现。</span><br><span class="line">PersonRepositoryInterface personRepos；</span><br><span class="line">personRepos.save(person)</span><br></pre></td></tr></table></figure><p>其实<code>Spring Data JPA</code>的思想也是这样的，不依赖于数据库，采用<code>JPA</code>的实现方式，使得更换数据库相较于强依赖 <code>SQL</code> 的 <code>Mybatis</code> 会方便很多。这样来看，<code>Spring Data JPA</code>就是一个实现依赖倒置的非常好的示例。</p><blockquote><p>但是采用DDD的这种架构模式的话，当需要更换数据库的话，使用<code>Mybatis</code>时其实也是差不多的，因为他们都不依赖于数据库，区别在于使用Spring Data JPA的话，更换数据库不需要些SQL，而<code>Mybatis</code>需要重写SQL。</p></blockquote><blockquote><p>DDD在基础层是通过仓储的依赖倒置的方式来实现应用与基础资源来解耦的。也就是说应用逻辑里面不应该含有基础资源的实现代码，SQL语句等与数据相关的代码不应放在业务逻辑代码来实现。以后如果需要换数据库的话，对应用逻辑影响相对会小很多。目前来说持久化的工具<code>Mybatis</code>可能会好一些。</p></blockquote><h4 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h4><p>在六边形架构中， Alistair Cockburn提出了一种具有对称性特征的架构风格。在这种架构中，不同的客户通过“平等”的方式与系统交互。</p><p>当有一个新的访问客户时，只需要添加一个新的适配器将客户输入转化成能被系统API所理解的参数就行了。同时，系统输出，比如图形界面、持久化和消息等都可以通过不同方式实现，并且对于每种特定的输出，都有个新建的适配器负责完成相应的转化功能。</p><p>我们通常将客户与系统交互的地方称为“前端”；同样，我们将系统中获取、存储持久化数据和发送输出数据的地方称为“后端”。但是，六边形架构提倡种新的视角来看待整个系统，如图8.4所示，该架构中存在两个区域，分别是“外部区域”和“内部区域”。</p><p><strong>在外部区域中，不同的客户均可以提交输入；而内部的系统则用于获取持久化数据，并对程序输出进行存储(比如数据库)，或者在中途将输出转发到另外的地方(比如消息)</strong></p><p><img src="https://img.hznu.asia/DDD/%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="六边形架构图"></p><p>​                                                                                            图 8.4</p><p>六边形架构的功能如此强大，以致于它可以用来支持系统中的其他架构。比如，我们可能采用SOA架构、REST或者事件驱动架构；也有可能采用CQRS；或者数据网织或基于网格的分布式缓存；还有可能采用Map-Reduce这种分布式并行处理方式。</p><p>这样设计的好处很明显了，就是<strong>可以保证领域层的核心业务逻辑不会因为外部需求和流程的变动而调整</strong>，对于建立前台灵活、中台稳固的架构很有帮助。</p><p>看到这里，也许你已经有可以看出对于中台和微服务设计的关键了：领域模型和微服务的合理分层设计。</p><h4 id="面向服务架构"><a href="#面向服务架构" class="headerlink" title="面向服务架构"></a>面向服务架构</h4><p>我们可能经常会听说一个词——SOA，其实这个词的意思就是面向服务架构(Service-Oriented Architecture，)对于不同的人来说具有不同的意思。我们先看看由 ThomasErl 所定义的一些SOA原则。服务除了拥有互操作性外，还具有以下8种设计原则：</p><table><thead><tr><th>服务设计原则</th><th>概述</th></tr></thead><tbody><tr><td>服务契约</td><td>通过契约文档，服务阐述自身的目的与功能</td></tr><tr><td>松耦合</td><td>服务将依赖关系最小化</td></tr><tr><td>服务抽象</td><td>服务只发布契约，而向客户隐藏内部逻辑</td></tr><tr><td>服务重用性</td><td>一种服务可以被其他服务所重用</td></tr><tr><td>服务自治性</td><td>服务自行控制环境与资源以保持独立性，这有助于保持服务的一致性和可靠性</td></tr><tr><td>服务无状态性</td><td>服务负责消费方的状态管理，这不能与服务的自治性发生冲突</td></tr><tr><td>服务可发现性</td><td>客户可以通过服务元数据来查找服务和理解</td></tr><tr><td>服务组合性</td><td>服务一种服务可以由其他的服务组合而成，而不管其他服务的大小和复杂性如何</td></tr></tbody></table><p>我们可以将这些原则和六边形架构结合起来，此时服务边界位于最左侧，而领域模型位于中心位置，如图8.4所示。消费方可以通过REST， SOAP和消息机制获取服务。一个六边形架构系统支持多种类型的服务端点(即图8.4左上角部分)，这依赖于DDD是如何应用于SOA的。</p><p>在使用DDD时，我们所创建的限界上下文应该包含一个完整的，能很好表达通用语言的领域模型。在限界上下文中我们已经提到，我们并不希望架构对领域模型的大小产生影响。</p><p>但是，如果一个或多个技术服务端点，比如REST资源、SOAP接口或消息类型被用于决定限界上下文的大小，那么上述情况是有可能发生的。</p><p>根据SOA精神所在:</p><p><strong>1.业务价值高于技术策略</strong></p><p><strong>2.战略目标高于项目利益</strong></p><p>就像限界上下文中所讲到的，<strong>技术组件对于划分模型来说并没有那么重要</strong>。</p><h4 id="REST和DDD（重点）"><a href="#REST和DDD（重点）" class="headerlink" title="REST和DDD（重点）"></a>REST和DDD（重点）</h4><p>有了上面的基础，那么在这一小节，我们就可以好好举个REST结合DDD的例子，来帮助理解什么才是DDD的思想了，相信看完这一小节，你又会有不一样的发现。</p><p>什么是REST应该不需要介绍了，一般程序员也都经常接触。使用REST，我们可以完成许多<code>CRUD</code>操作，我们就拿这里面的<code>U</code>来说吧。<code>U</code>代表的就是<code>Update</code>操作，通用更新方法允许客户端更新资源的任何字段，然后使用新版本覆盖现有版本。但是，如果允许客户端执行这样的操作，所能提供的价值其实是很小的。</p><p><strong>服务层的关键增值之一就是在基础数据之上实施业务约束，资源总是最终要被业务约束才行。（在我看来，这就是DDD架构中的一大核心）</strong></p><p>也许咋一看这句话不是很好理解，我们来看一个银行转账的例子：</p><p>比如你现在准备开发一个转账的接口，采用<code>CRUD</code>模式的方式，那便会发生许多问题。首先，客户端不应该调用一个API，然后就把账户余额更新为他们想要的数量，如果允许这样做，那么你的代码不仅会很混乱，而且难以维护。</p><p>比如帐户可能有最低余额，于是你对那些更新方法添加了一些校验代码，以便如果帐户余额值被更改，它必须在一个指定的范围内。这样问题解决了吗？没有。任何余额调整都应被作为某种类型交易事务被记录下来才对。比如这是充值？取钱？还是一次转账？如果客户端尝试更改帐号怎么办？这是否允许？会破坏其他数据关系吗？于是你的更新（update）方法实现逻辑将会快速变成逻辑流程异常复杂的代码。</p><p>在很多系统中，其实都存在这个问题，他们的代码试图推断客户端究竟把哪些字段改变了，里面有各种各样的逻辑，这些逻辑一起在判断用户的这次更新操作是在充值、取钱还是转账（因为这些操作涉及的代码往往不止一张表，可能需要多个表共同维护，而这些代码都混在一起），代码最终就是一团糟。</p><p>这时候，领域驱动设计（DDD）给出了一个解决方案。 DDD的思路是希望软件建模应该是基于解决现实世界的问题而去设计API，在我看来，这就是一种面向对象的架构思想。它创建了一种用于描述软件的语言，这种语言是基于被称为实体或聚合的关键的业务对象来描述软件的。它还定义了比如服务（Services），值对象（ValueObject）和存储库（Repositories）之类的术语，它们共同解决特定业务领域中的问题，或者在DDD术语中被叫做“限界上下文（Bounded Context）”。当然，并不是说必须使用DDD来设计你的REST，但是，由于REST资源可以很好地映射到DDD实体，因此我发现设计REST API特别适合使用DDD。</p><p>这是什么意思？<strong>这意味着我们的API应该围绕领域对象及其提供的业务操作</strong>。业务操作是通用更新方法及其所有陷阱的关键的替代方案。我们再用前面的银行示例来说明：</p><p>对于银行API，明显的领域对象（或DDD术语中的实体）是一个帐户，它为银行帐户建模。<strong>我们不应该按照帐户的CRUD模型来定义在银行账户上执行的具体业务操作。</strong>以下是一个写操作系列很好的示例：</p><ol><li><p><strong>Open -开户</strong></p></li><li><p><strong>Close -关闭账户</strong></p></li><li><p><strong>Debit -从账户上取钱</strong></p></li><li><p><strong>Credit -往账户上加钱</strong></p></li></ol><p>如果使用我们<code>CRUD</code>思维，可能就一个或两个操作实现上述四个操作——更新账户状态为开启或关闭（取决你对开户含义的理解，其实这也是DDD使用的一个体现，应该对术语进行规范，使得一个限界上下文拥有通用语言），账户余额的更新。</p><p><strong>而我们上面四个操作是具体的，可以强制执行某些业务约束。例如，我们可能不想允许记入已关闭的账户，我们可以强制执行我们的最低余额检查作为借记操作（从账户扣除金额的操作）的一部分。在读操作方面，我们还可以提供与我们的客户用例相匹配的特定查询：</strong></p><ol><li><p><strong>Load -通过其帐户ID加载单个帐户。</strong></p></li><li><p><strong>Transaction history - 列出帐户的交易记录。</strong></p></li><li><p><strong>Customer accounts -列出给定客户ID的帐户。</strong></p></li></ol><p>现在我们知道我们的业务操作是什么了，下面是将它们映射到REST API的一个例子：</p><ol><li><p><strong>POST /account – 开户</strong></p></li><li><p><strong>PUT /account/<accountId>/close -关闭现有账户</accountId></strong></p></li><li><p><strong>PUT /account/<accountId>/debit – 从账户上取钱</accountId></strong></p></li><li><p><strong>PUT /account/<accountId>/credit – 往账户上充钱</accountId></strong></p></li><li><p><strong>GET /account/<acountId> - 通过其帐户ID加载单个帐户。</acountId></strong></p></li><li><p><strong>GET /account/<accountId>/transactions- 列出帐户的交易记录。</accountId></strong></p></li><li><p><strong>GET /accounts/query/customerId/<customerId> -列出给定客户ID的帐户。</customerId></strong></p></li></ol><p>这看起来和基本的CRUD API有很大的不同，但关键是允许的操作是特定的和明确的。这为服务实现者以及客户端带来了更好的体验。服务实现不再需要基于哪些属性更新来猜测什么业务操作是隐含的。</p><p>相反，<strong>业务操作是明确的，这样我们的代码实现也更简单，更可维护。在客户端，将变得更加的明确，什么操作可以执行，什么操作不可以执行。</strong>如果API文档记录的很好的话，例如使用Swagger来定义文档，那么每个API的限制（或约束）将变得非常明确。</p><p><strong>以这种方式定义你的API需要更多的前瞻性思考，要比简单的CRUD 生成器需要花费更多的思考，但我认为这是值得的也是必须的。</strong></p><p><strong>因此不应该按照CRUD模型来构建你的serviceAPI（REST 或其他），而应该是使用DDD，DDD可以根据领域对象和可对其执行的业务操作来定义API。</strong></p><h4 id="命令和查询职责分离——CQRS"><a href="#命令和查询职责分离——CQRS" class="headerlink" title="命令和查询职责分离——CQRS"></a>命令和查询职责分离——CQRS</h4><p>这其实就是我们经常讲到的数据库读写分离了，这个问题在今天（写这篇文档时）都是一个十分热门的问题。</p><p>从资源库（DDD术语，和第八节依赖倒置原则基础层给出的仓储服务例子一样）中查询所有需要显示的数据是困难的，特别是在需要显示来自不同聚合类型与实例的数据时。</p><p>领域越复杂，这种困难程度越大。因此，我们并不期望单单使用资源库来解决这个问题。因为我们需要从不同的资源库获取聚合实例，然后再将这些实例数据组装成一个数据传输对象(DataTransfer Object， DTO) 。或者，我们可以在同一个查询中使用特殊的查找方法将不同资源库的数据组合在一起。如果这些办法都不合适，我们可能需要在用户体验上做出妥协，使界面显示生硬地服从于模型的聚合边界。</p><p>然而，很多人都认为，这种机械式的用户界面从长远看来是不够的。那么，有没有一种完全不同的方法可以将领域数据映射到界面显示中呢？答案是CQRS (Cammand-Query Responsibility Segregation) 。 CQRS是将紧缩(Stringent)对象(或者组件)设计原则和命令-查询分离(CQS)应用在架构模式中的结果。</p><p>Bertrand Meyer对CQRS模式有以下评述：</p><blockquote><p>一个方法要么是执行某种动作的命令，要么是返回数据的查询，而不能两者皆是。</p></blockquote><p>在对象层面，这意味着：</p><ol><li><p>如果一个方法修改了对象的状态，该方法便是一个命令(Command)，它不应该返回数据。在Java中，这样的方法应该声明为void</p></li><li><p>如果一个方法返回了数据，该方法便是一个查询(Query)，此时它不应该通过直接的或间接的手段修改对象的状态。在Java中，这样的方法应该以其返回的数据类型进行声明。</p></li></ol><p>这样的指导原则是非常直接明了的，同时具有实践和理论基础作为支撑。但是，在DDD的架构模式中，我们为什么应该使用CQRS呢，又如何使用呢？</p><p>在领域模型中——比如限界上下文中所讨论的领域模型——我们通常会看到同时包含有命令和查询的聚合。同时，我们也经常在资源库中看到不同的查找方法，这些方法对对象属性进行过滤。</p><p>但是在CQRS中，我们将忽略这些看似常态的情形，我们将通过不同的方式来查询用于显示的数据。现在，对于同一个模型，考虑将那些纯粹的查询功能从命令功能中分离出来。聚合将不再有查询方法，而只有命令方法。资源库也将变成只有add()或save()方法，(分别支持创建和更新操作)，同时只有一个查询方法，比如fromld()。这个唯一的查询方法将聚合的身份标识作为参数，然后返回该聚合实例。资源库不能使用其他方法来查询聚合，比如对属性进行过滤等。</p><p>在将所有查询方法移除之后，我们将此时的模型称为命令模型(Command Model)。但是我们仍然需要向用户显示数据，为此我们将创建第二个模型，该模型专门用于优化查询，我们称之为查询模型(Query Model)，如图8.5所示。</p><p><img src="https://img.hznu.asia/DDD/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%A8%A1%E5%9E%8B.png" alt="读写分离模型"></p><p>​                                                                                                    图 8.5</p><p>在CQRS中，来自客户端的命令通过单独的路径抵达命令模型，而查询操作则采用不同的数据源，这样的好处在于可以优化对查询数据的获取，比如用于展现、用于接口或报告的数据。</p><p>命令模型上每个方法在执行完成时都将发布领域事件(在后面会讲到)。这里举个小例子体会下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BacklogItem extends ConcurrencySafeEntity&#123;</span><br><span class="line">public void commitTo (Sprint aSprint)&#123;</span><br><span class="line">...</span><br><span class="line">DomainEvent Publisher.</span><br><span class="line">instance()</span><br><span class="line">.publish(new BacklogItemCommitted (this.tenant()，</span><br><span class="line">   this.backlogItemId()，    this.sprintId ()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的DomainEventPublisher是一个轻量级的基于观察者(Observer)模式的组件，更多的细节会在后面的领域事件部分讲到。</p></blockquote><p>在命令模型更新之后，如果我们希望查询模型也得到相应的更新，那么从命令模型中发布的领域事件便是关键所在。</p><p>简单来说，你在命令模型发起一条更新操作的命令后，就得及时更新查查询模型，要不然查出来数据就不一致，这时候领域事件就可以看成用于通知更新查询模型的。</p><blockquote><p>对于读写分离还有许多方面值得研究，比如保证实现数据一致性等等问题，这里就不展开讲解了。</p></blockquote><h2 id="九-实体"><a href="#九-实体" class="headerlink" title="九. 实体"></a>九. 实体</h2><p>因为在软件开发中，数据库依然占据着主导地位。我们首先考虑的是数据的属性(对应数据库的列)和关联关系(外键关联)，而不是富有行为的领域概念，开发者趋向于将关注点放在数据上，而不是领域上。</p><p>这样做的结果是将数据模型直接反映在对象模型上，导致那些表示领域模型的实体(Entity)包含了大量的getter和setter方法。另外，还存在大量的工具可以帮助我们生成这样的实体模型。虽然在实体模型中加入getter和setter并不是什么大错，但这却不是DDD的做法。</p><h4 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h4><p>实体的核心三要素：<strong>身份标识</strong>、<strong>属性</strong>和<strong>领域行为</strong>。</p><p><strong>身份标识</strong>：身份标识的主要目的是管理实体的生命周期。身份标识可分为：通用类型和领域类型。<strong>通用类型 ID 没有业务含义；而领域类型 ID 则组装了业务逻辑，建议使用值对象作为领域类型 ID。</strong></p><p><strong>属性</strong>：实体的属性用来说明主体的静态特征，并持有数据与状态。属性分为：原子属性和组合属性。组合属性可以是实体，也可以是值对象，取决于该属性是否需要身份标识。我们应该尽可能将实体的属性定义为组合属性，以便于在实体内部形成各自的抽象层次。</p><p><strong>领域行为</strong>：体现了实体的动态特征。实体具有的领域行为一般可以分为：</p><ul><li><strong>变更状态的领域行为</strong>：变更状态的领域行为体现的是实体/值对象内部的状态转移，对应的方法入参为期望变更的状态。（有入参，无出参）；</li><li><strong>自给自足的领域行为</strong>：自给自足意味着实体对象只操作了自己的属性，不外求于别的对象。（无入参）；</li><li><strong>互为协作的领域行为</strong>：需要调用者提供必要的信息。（有入参，有出参）；</li><li><strong>创建行为</strong>：代表了对象在内存的从无到有。创建行为由构造函数履行，但对于创建行为较为复杂或需要表达领域语义时，我们可以在实体中定义简单工厂方法，或使用专门的工厂类进行创建。（有出参，且出参为特定实体实例）。</li></ul><h4 id="领域唯一标识"><a href="#领域唯一标识" class="headerlink" title="领域唯一标识"></a>领域唯一标识</h4><p>唯一标识从字面意思来看很好理解，比如我们的身份证号等等都可以作为唯一标识。</p><p>以下是一些常用的创建实体身份标识的策略，从简单到复杂依次为:</p><ul><li>用户提供一个或多个初始唯一值作为程序输人，程序应该保证这些初始值是唯一的。</li><li>程序内部通过某种算法自动生成身份标识，此时可以使用一些类库或框架，当然程序自身也可以完成这样的功能。</li><li>程序依赖于持久化存储，比如数据库，来生成唯一标识。</li><li>另一个限界上下文(系统或程序)已经决定出了唯一标识，这作为程序的输入，用户可以在一组标识中进行选择。</li></ul><h5 id="用户提供唯一标识"><a href="#用户提供唯一标识" class="headerlink" title="用户提供唯一标识"></a>用户提供唯一标识</h5><p>这个其实很好理解，举个简单的例子，用户输入的自己的身份证号便可以作为唯一标识，当然，在用户输入后，身份证号和名字等肯定是要先去匹配验证是否正确的。</p><h5 id="应用程序生成唯一标识"><a href="#应用程序生成唯一标识" class="headerlink" title="应用程序生成唯一标识"></a>应用程序生成唯一标识</h5><p>有很多可靠的方法都可以自动生成唯一标识，但是如果应用程序处于集群环境或者分布在不同的计算节点中，我们就需要额外小心了。有些方法可以生成完全唯一的标识，比如UUID (Universally Unique Identifier) 或者GUID (GloballyUnique Identifier) 。以下是生成唯一标识的另一种方法，其中每一步生成的结果都将添加到最终的文本标识中：</p><ol><li><p>计算节点的当前时间，以毫秒记</p></li><li><p>计算节点的IP地址</p></li><li><p>虚拟机(Java)中工厂对象实例的对象标识</p></li><li><p>虚拟机(Java)中由同一个随机数生成器生成的随机数以上可以产生一个128位的唯一值。</p></li></ol><p>通常该唯一值通过一个32字节或36字节的16进制数的字符串来表示。在使用36字对，我们可以用连字符(-)来连接以上各个步骤所生成的结果，比如<code>f36ab21c-67dc-5274-c642-Ide2f4d5e72a</code>。但无论如何，这都是个很大的唯一标识，并且不具有可读性。</p><p>在Java中，以上方法被标准的<code>UUID</code>生成器所替代了(自从Java 1.5)，相应的Java类是<code>java.util.UUID</code>。该类支持4种不同的唯一标识生成算法，这些算法都基于Leach-Salz变量。使用Java标准API，我们可以简单地生成伪随机的唯一标识:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String rawId = java，util，UUID.randomUUID().toString ();</span><br></pre></td></tr></table></figure><p>以上代码使用了第4类算法，该算法采用高度加密的伪随机数生成器，而该生成器又基于<code>java.security.SecureRandom</code>生成器。</p><p>除了上面几种，还有<strong>持久化机制生成唯一标识</strong>和<strong>另一个限界上下文获取标识</strong>，这里就不一一讲解了。</p><h5 id="委派标识"><a href="#委派标识" class="headerlink" title="委派标识"></a>委派标识</h5><p>基于领域实体概念分析确定的唯一身份标识，我们可以称为<strong>领域实体标识</strong>。</p><p> 而在有些ORM工具，比如Hibernate、EF，它们有自己的方式来处理对象的身份标识。它们倾向于使用数据库提供的机制，比如使用一个数值序列来生成识。在ORM中，委派标识表现为int或long类型的实体属性，来作为数据库的主键。很显然，<strong>委派标识是为了迎合ORM而创建的，且委派标识和领域实体标识无任何关系。</strong></p><p>那既然ORM需要委派标识，我们就可以<strong>创建一个实体基类来统一指定委派标识</strong>。而这个实体基类又被称为<strong>层超类型</strong>。</p><p>日常中往往会不加思索地把一个自增ID或者GUID等当成实体ID，这其实是不好的。实体ID往往是具备业务意义上的唯一性，是负责与其它边界上下文内的实体（或聚类）进行关联的方式。<br> 具备业务含义的唯一性很重要，它使得不同边界上下文之间的映射变得更加简单、直观，也更容易维护，同时唯一性也更具象化。<br> 如交易所对订单ID的约定就非常的明确，看到ID就知道它代表啥了，比如：订单是从哪个证券通道过来的，是哪一天的订单。这样设计的好处有很多：</p><ol><li>允许不同通道（证券公司）各自设计系统软件，但是这不会破坏交易所对订单号唯一性要求。</li><li>交易所通过订单ID就能根据事先约定的规则识别出是否是一个有效的订单号，对于不存在的或者无效的机构ID的订单号（注册制），可以快速进入异常处置流程。</li><li>清结算时也很容易进行核对。</li></ol><h4 id="层超类型"><a href="#层超类型" class="headerlink" title="层超类型"></a>层超类型</h4><p>首先定义层超类型接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class IdentifiedDomainobject implements Serializable&#123;</span><br><span class="line">private long id = -1;</span><br><span class="line">public IdentifiedDomainObject()&#123;</span><br><span class="line">super ();</span><br><span class="line">&#125; </span><br><span class="line">protected long id ()&#123;</span><br><span class="line">return this.id;</span><br><span class="line">&#125; </span><br><span class="line">protected void setId(long anId)&#123;</span><br><span class="line">this.id= anId;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>IdentifiedDomainObject</code>便是层超类型，这是一个抽象基类，通过protected关键字，它向客户端隐藏了委派主键。<strong>所有实体都扩展自该抽象基类。</strong></p><p>在实体所处的模块之外，客户端不用关心id这个委派标识。我们甚至可以将protected换为private，Hibernate既可以通过getter和setter方法来访问属性，也可以通过反射机制直接访问对象属性，故无论是使用protected还是private都是无关紧要的。</p><p><strong>通过这样一种方式，我们进行约定，所有的实体必须继承自<code>IdentifiedDomainObject</code>，即可实现委托标识的统一定义。</strong></p><h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h4><p>解决了实体的唯一身份标识问题后，我们就可以保证其生命周期中的连续性，不管其如何变化。</p><p>那可变性说的是什么呢？<strong>可变性是实体的状态和行为。</strong><br> 而实体的状态和行为就要对具体的业务模型加以分析，提炼出通用语言，再基于通用语言来抽象成实体对应的属性或方法。</p><p>我们举一个例子：</p><blockquote><p>当顾客从购物车点击结算时创建订单，初始状态为未支付状态，支付成功后切换到正常状态，此时可对订单做发货处理并置为已发货状态。当顾客签收后，将订单关闭。</p></blockquote><p>从以上的通用语言的描述中（在通用语言的术语中，名词用于给概念命名，形容词用于描述这些概念，而动词则表示可以完成的操作。）<br> 我们可以提取订单的相关状态和行为：</p><ul><li>订单状态：未支付、正常、已发货、关闭。针对状态，我们需定义一个状态属性即可。</li><li>订单的行为：支付、发货和关闭。针对行为，我们可以在实体中定义方法或创建单独的领域服务来处理。</li></ul><p>而这些行为和状态都是用于领域建模非常重要的组成部分。</p><p>实体既然存在状态和行为，就必然会与事件有所牵连。比如订单支付成功后，需要知会商家发货。这时我们就要追踪订单状态的变化，而追踪变化最实用的方法就是领域事件。关于领域事件，我们后续再讲。</p><h2 id="十-值对象"><a href="#十-值对象" class="headerlink" title="十. 值对象"></a>十. 值对象</h2><p>值对象虽然经常被掩盖在实体的阴影之下，但它却是非常重要的DDD部件。</p><p>值对象我们要分开来看，其包含两个词：值和对象。值是什么？比如，数字（1、2、3.14），字符串（“hello world”、“DDD”），金额（￥50、$50），地址（深圳市南山区科技园）它们都是一个值，这个值有什么特点呢，固定不变，表述一个具体的概念。对象又是什么？一切皆为对象，是对现实世界的抽象，用来描述一个具体的事物。那<strong>值对象=值+对象=将一个值用对象的方式进行表述，来表达一个具体的固定不变的概念</strong>。</p><p>所以了解值对象，我们关键要抓住关键字——<strong>值</strong>。</p><p>认识值类型的优点值类型用于度量和描述事物，我们可以非常容易地对值对象进行创建、测试、使用，优化和维护。</p><p><strong>我们应该尽量使用值对象来建模而不是实体对象，你可能对此非常惊讶。即便一个领域概念必须建模成实体，在设计时也应该更偏向于将其作为值对象容器，而不是子实体容器。这并不是源自于无端的偏好，而是因为我们可以非常容易地对值对象进行创建、测试、使用、优化和维护。</strong></p><p>这样讲也许有点晦涩，初学想要理解并区分实体和值对象没有那么简单，我们就先来对比一下两者。</p><h2 id="十一-实体和值对象的区别"><a href="#十一-实体和值对象的区别" class="headerlink" title="十一. 实体和值对象的区别"></a>十一. 实体和值对象的区别</h2><h3 id="再看实体"><a href="#再看实体" class="headerlink" title="再看实体"></a>再看实体</h3><p>前面对实体进行了一些讲解，在看完什么是值对象后，我们再从几个不同的角度来看实体，并将它于值对象加以区分。</p><h4 id="实体的业务形态"><a href="#实体的业务形态" class="headerlink" title="实体的业务形态"></a>实体的业务形态</h4><p>在 DDD 不同的设计过程中，实体的形态是不同的。在战略设计时，实体是领域模型的一个重要对象。领域模型中的实体是多个属性、操作或行为的载体。你可以这么理解，实体和值对象是组成领域模型的基础单元。</p><h4 id="实体的代码形态"><a href="#实体的代码形态" class="headerlink" title="实体的代码形态"></a>实体的代码形态</h4><p>在代码模型中，实体的表现形式是实体类，这个类包含了实体的属性和方法，通过这些方法实现实体自身的业务逻辑。<strong>在 DDD 里，这些实体类通常采用充血模型，与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现。</strong></p><h4 id="实体的运行形态"><a href="#实体的运行形态" class="headerlink" title="实体的运行形态"></a>实体的运行形态</h4><p>实体以 DO（领域对象）的形式存在，每个实体对象都有唯一的 ID。我们可以对一个实体对象进行多次修改，修改后的数据和原来的数据可能会大不相同。但是，由于它们拥有相同的 ID，它们依然是同一个实体。比如商品是商品上下文的一个实体，通过唯一的商品 ID 来标识，不管这个商品的数据如何变化，商品的 ID 一直保持不变，它始终是同一个商品。</p><h4 id="实体的数据库形态"><a href="#实体的数据库形态" class="headerlink" title="实体的数据库形态"></a>实体的数据库形态</h4><p>与传统数据模型设计优先不同，DDD 是先构建领域模型，针对实际业务场景构建实体对象和行为，再将实体对象映射到数据持久化对象。</p><p>在领域模型映射到数据模型时，一个实体可能对应 0 个、1 个或者多个数据库持久化对象。大多数情况下实体与持久化对象是一对一。</p><p>在某些场景中，有些实体只是暂驻静态内存的一个运行态实体，它不需要持久化。比如，基于多个价格配置数据计算后生成的折扣实体。</p><p>而在有些复杂场景下，实体与持久化对象则可能是一对多或者多对一的关系。比如，用户 user 与角色 role 两个持久化对象可生成权限实体，一个实体对应两个持久化对象，这是一对多的场景。</p><p>再比如，有些场景为了避免数据库的联表查询，提升系统性能，会将客户信息 customer 和账户信息 account 两类数据保存到同一张数据库表中，客户和账户两个实体可根据需要从一个持久化对象中生成，这就是多对一的场景。</p><h3 id="再看值对象"><a href="#再看值对象" class="headerlink" title="再看值对象"></a>再看值对象</h3><p>在《实现领域驱动设计》一书中对值对象的定义：通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。在 DDD 中用来描述领域的特定方面，并且是一个没有标识符的对象，叫作值对象。</p><p>也就说，<strong>值对象描述了领域中的一件东西，这个东西是不可变的，它将不同的相关属性组合成了一个概念整体。</strong>当度量和描述改变时，可以用另外一个值对象予以替换。它可以和其它值对象进行相等性比较，且不会对协作对象造成副作用。</p><p>上面这两段对于定义的阐述，如果你还是觉得有些晦涩，我们不妨“翻译”一下，用更通俗的语言把定义讲清楚。</p><p><strong>简单来说，值对象本质上就是一个集合。集合里面有若干个用于描述目的、具有整体概念和不可修改的属性。那这个集合存在的意义又是什么？在领域建模的过程中，值对象可以保证属性归类的清晰和概念的完整性，避免属性零碎。</strong></p><p>这里举个简单的例子，先看下面这张图：</p><p><img src="https://img.hznu.asia/DDD/%E5%80%BC%E5%AF%B9%E8%B1%A1%E8%AE%B2%E8%A7%A3%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpg"></p><p>人员实体原本包括：姓名、年龄、性别以及人员所在的省、市、县和街道等属性。这样显示地址相关的属性就很零碎了对不对？现在，我们可以将“省、市、县和街道等属性”拿出来构成一个“地址属性集合”，这个集合就是值对象了。</p><h4 id="值对象的业务形态"><a href="#值对象的业务形态" class="headerlink" title="值对象的业务形态"></a>值对象的业务形态</h4><p>值对象是 DDD 领域模型中的一个基础对象，它跟实体一样都来源于事件风暴所构建的领域模型，都包含了若干个属性，它与实体一起构成聚合。我们对照实体，来看值对象的业务形态，这样更好理解。</p><p><strong>本质上，实体是看得到、摸得着的实实在在的业务对象，实体具有业务属性、业务行为和业务逻辑。而值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。</strong></p><p>值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征。在值对象中也有部分共享的标准类型的值对象，它们有自己的限界上下文，有自己的持久化对象，可以建立共享的数据类微服务，比如数据字典。</p><h4 id="值对象的代码形态"><a href="#值对象的代码形态" class="headerlink" title="值对象的代码形态"></a>值对象的代码形态</h4><p>值对象在代码中有这样两种形态。如果值对象是单一属性，则直接定义为实体类的属性；如果值对象是属性集合，则把它设计为 Class 类，Class 将具有整体概念的多个属性归集到属性集合，这样的值对象没有 ID，会被实体整体引用。我们看一下下面这段代码，person 这个实体有若干个单一属性的值对象，比如 Id、name 等属性；同时它也包含多个属性的值对象，比如地址 address。</p><p><img src="https://img.hznu.asia/DDD/%E5%80%BC%E5%AF%B9%E8%B1%A1%E8%AE%B2%E8%A7%A3%E4%BB%A3%E7%A0%81%E5%9B%BE.jpg"></p><h4 id="值对象的运行形态"><a href="#值对象的运行形态" class="headerlink" title="值对象的运行形态"></a>值对象的运行形态</h4><p>实体实例化后的 DO 对象的业务属性和业务行为非常丰富，但值对象实例化的对象则相对简单和乏味。<strong>除了值对象数据初始化和整体替换的行为外，其它业务行为就很少了。</strong></p><p>值对象嵌入到实体的话，有这样两种不同的数据格式，也可以说是两种方式，分别是<strong>属性嵌入的方式</strong>和<strong>序列化大对象</strong>的方式。引用单一属性的值对象或只有一条记录的多属性值对象的实体，可以采用属性嵌入的方式嵌入。引用一条或多条记录的多属性值对象的实体，可以采用序列化大对象的方式嵌入。</p><p>比如，人员实体可以有多个通讯地址，多个地址序列化后可以嵌入人员的地址属性。值对象创建后就不允许修改了，只能用另外一个值对象来整体替换。如果听着有些晦涩，我们看看下面的例子。</p><p>案例 1：以属性嵌入的方式形成的人员实体对象，地址值对象直接以属性值嵌入人员实体中。</p><p><img src="https://img.hznu.asia/DDD/%E4%B8%8D%E7%94%A8%E5%80%BC%E5%AF%B9%E8%B1%A1%E6%97%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84.jpg"></p><p>案例 2：以序列化大对象的方式形成的人员实体对象，地址值对象被序列化成大对象 Json 串后，嵌入人员实体中。</p><p><img src="https://img.hznu.asia/DDD/%E7%94%A8%E5%80%BC%E5%AF%B9%E8%B1%A1%E6%97%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84.jpg"></p><h4 id="值对象的数据库形态"><a href="#值对象的数据库形态" class="headerlink" title="值对象的数据库形态"></a>值对象的数据库形态</h4><p><strong>DDD 引入值对象是希望实现从“数据建模为中心”向“领域建模为中心”转变，减少数据库表的数量和表与表之间复杂的依赖关系，尽可能地简化数据库设计，提升数据库性能。</strong></p><p>如何理解用值对象来简化数据库设计呢？传统的数据建模大多是根据数据库范式设计的，每一个数据库表对应一个实体，每一个实体的属性值用单独的一列来存储，一个实体主表会对应 N 个实体从表。</p><p>而值对象在数据库持久化方面简化了设计，它的数据库设计大多采用非数据库范式，<strong>值对象的属性值和实体对象的属性值保存在同一个数据库实体表中。</strong></p><p>举个例子，还是基于上述人员和地址那个场景，实体和数据模型设计通常有两种解决方案：</p><ul><li>第一是<strong>把地址值对象的所有属性都放到人员实体表</strong>中，创建人员实体，创建人员数据表；</li><li>第二是创建人员和地址两个实体，同时创建人员和地址两张表。</li></ul><p>第一个方案会破坏地址的业务涵义和概念完整性，第二个方案增加了不必要的实体和表，需要处理多个实体和表的关系，从而增加了数据库设计的复杂性。</p><p>那到底应该怎样设计，才能让业务含义清楚，同时又不让数据库变得复杂呢？我们可以综合这两个方案的优势，扬长避短。</p><p>在领域建模时，我们可以把<strong>地址作为值对象，人员作为实体</strong>，这样就可以保留地址的业务涵义和概念完整性。而在数据建模时，我们可以将地址的属性值嵌入人员实体数据库表中，只创建人员数据库表。这样既可以兼顾业务含义和表达，又不增加数据库的复杂度。</p><p>值对象就是通过这种方式，简化了数据库设计，总结一下就是：在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时，我们可以<strong>将值对象嵌入实体（而不是将所有属性嵌入）</strong>，减少实体表的数量，简化数据库设计。</p><p>另外，也有 DDD 专家认为，要想发挥对象的威力，就需要优先做领域建模，弱化数据库的作用，只把数据库作为一个保存数据的仓库即可。即使违反数据库设计原则，也不用大惊小怪，只要业务能够顺利运行，就没什么关系。</p><h4 id="值对象的优势和局限"><a href="#值对象的优势和局限" class="headerlink" title="值对象的优势和局限"></a>值对象的优势和局限</h4><p>值对象是一把双刃剑，它的优势是可以简化数据库设计，提升数据库性能。但如果值对象使用不当，它的优势就会很快变成劣势。</p><p>值对象采用<strong>序列化大对象的方法简化了数据库设计</strong>，减少了实体表的数量，可以简单、清晰地表达业务概念。</p><p><strong>这种设计方式虽然降低了数据库设计的复杂度，但却无法满足基于值对象的快速查询，会导致搜索值对象属性值变得异常困难。</strong></p><p>值对象采用属性嵌入的方法提升了数据库的性能，但如果实体引用的值对象过多，则会导致实体堆积一堆缺乏概念完整性的属性，这样值对象就会失去业务涵义，操作起来也不方便。所以，在使用值对象时，也要考虑他的劣势。</p><h3 id="实体和值对象的关系"><a href="#实体和值对象的关系" class="headerlink" title="实体和值对象的关系"></a>实体和值对象的关系</h3><p><strong>值对象和实体在某些场景下可以互换</strong>，很多 DDD 专家在这些场景下，其实也很难判断到底将领域对象设计成实体还是值对象。</p><p>可以说，值对象在某些场景下有很好的价值，但是并不是所有的场景都适合值对象。</p><p>其实，DDD 引入值对象还有一个重要的原因，就是DDD 提倡从领域模型设计出发，而不是先设计数据模型。前面讲过了，传统的数据模型设计通常是一个表对应一个实体，一个主表关联多个从表，当实体表太多的时候就很容易陷入无穷无尽的复杂的数据库设计，领域模型就很容易被数据模型绑架。</p><p>可以说，值对象的诞生，在一定程度上，和实体是互补的。我们还是以前面的图示为例：</p><p><img src="https://img.hznu.asia/DDD/%E5%80%BC%E5%AF%B9%E8%B1%A1%E8%AE%B2%E8%A7%A3%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpg"></p><p>在领域模型中人员是实体，地址是值对象，地址值对象被人员实体引用。</p><p>在数据模型设计时，地址值对象可以作为一个属性集整体嵌入人员实体中，组合形成上图这样的数据模型；也可以以序列化大对象的形式加入到人员的地址属性中，前面表格有展示。</p><p>从这个例子中，我们可以看出，<strong>同样的对象在不同的场景下，可能会设计出不同的结果。</strong></p><p><strong>有些场景中，地址会被某一实体引用，它只承担描述实体的作用，并且它的值只能整体替换，这时候你就可以将地址设计为值对象，比如收货地址。而在某些业务场景中，地址会被经常修改，地址是作为一个独立对象存在的，这时候它应该设计为实体，比如行政区划中的地址信息维护。</strong></p><p>所有，这时候就不得不再提起一开始讲到的DDD中的限界上下文了，它就是对这些容易混淆的东西加以约束，也可以说是对领域进行区分了。</p><blockquote><p>实体和值对象的目的都是抽象聚合若干属性以简化设计和沟通，有了这一层抽象，我们在使用人员实体时，不会产生歧义，在引用地址值对象时，不用列举其全部属性，在同一个限界上下文中，大幅降低误解、缩小偏差，两者的区别如下： </p><p>①两者都经过属性聚类形成，实体有唯一性，值对象没有。在本文案例的限界上下文中，人员有唯一性，一旦某个人员被系统纳入管理，它就被赋予了在事件、流程和操作中被唯一识别的能力，而值对象没有也不必具备唯一性。 </p><p>②实体着重唯一性和延续性，不在意属性的变化，属性全变了，它还是原来那个它；值对象着重描述性，对属性的变化很敏感，属性变了，它就不是那个它了。 </p><p>③战略上的思考框架稳定不变，战术上的模型设计却灵活多变，实体和值对象也有可能随着系统业务关注点的不同而更换位置。比如，如果换一个特殊的限界上下文，这个上下文更关注地址，而不那么关注与这个地址产生联系的人员，那么就应该把地址设计成实体，而把人员设计成值对象。</p><p>来源：极客时间《DDD实战课》下评论区，作者ID：DZ</p></blockquote><blockquote><p>参考引用：</p><p>【1】 《实现领域驱动设计》Vaughn Vernon</p><p>【2】https：//time.geekbang.org/column/article/89049 “先做好DDD再谈微服务吧，那只是一种部署形式”</p><p>【3】https：//<a href="http://www.cnblogs.com/kingofkai/p/5889099.html">www.cnblogs.com/kingofkai/p/5889099.html</a></p><p>【4】https：//mp.weixin.qq.com/s/BIYp9DNd_9sw5O2daiHmlA</p><p>【5】<a href="https://time.geekbang.org/column/article/156849%EF%BC%9Futm_source=related_read&amp;utm_medium=article&amp;utm_term=related_read">https://time.geekbang.org/column/article/156849？utm_source=related_read&amp;utm_medium=article&amp;utm_term=related_read</a></p><p>【6】<a href="https://time.geekbang.org/column/article/158248%EF%BC%9Futm_source=related_read&amp;utm_medium=article&amp;utm_term=related_read">https://time.geekbang.org/column/article/158248？utm_source=related_read&amp;utm_medium=article&amp;utm_term=related_read</a> 极客时间DDD实战课系列文章 欧创新</p><p>【7】<a href="https://cloud.tencent.com/developer/article/1082817">https://cloud.tencent.com/developer/article/1082817</a></p><p>【8】 <a href="https://www.jianshu.com/p/ee2579d0000b">https://www.jianshu.com/p/ee2579d0000b</a></p><p>【9】 <a href="https://www.jianshu.com/p/f5e55e278f15">https://www.jianshu.com/p/f5e55e278f15</a></p><p>【10】<a href="https://www.jianshu.com/p/42fc274ff409">https://www.jianshu.com/p/42fc274ff409</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/DDD/">DDD</category>
      
      
      
      <comments>http://hznu.asia/2022/07/19/DDD%E5%88%9D%E6%8E%A2(1)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring AOP的应用---系统操作日志的实现--基于AspectJ</title>
      <link>http://hznu.asia/2022/07/02/Spring-AOP%E7%9A%84%E5%BA%94%E7%94%A8-%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E7%9A%84%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8EAspectJ/</link>
      <guid>http://hznu.asia/2022/07/02/Spring-AOP%E7%9A%84%E5%BA%94%E7%94%A8-%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E7%9A%84%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8EAspectJ/</guid>
      <pubDate>Sat, 02 Jul 2022 13:02:13 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;一-AOP的种类和关系&quot;&gt;&lt;a href=&quot;#一-AOP的种类和关系&quot; class=&quot;headerlink&quot; title=&quot;一. AOP的种类和关系&quot;&gt;&lt;/a&gt;一. &lt;strong&gt;AOP&lt;/strong&gt;的种类和关系&lt;/h2&gt;&lt;p&gt;目前主流的AOP 框架有2个，</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="一-AOP的种类和关系"><a href="#一-AOP的种类和关系" class="headerlink" title="一. AOP的种类和关系"></a>一. <strong>AOP</strong>的种类和关系</h2><p>目前主流的AOP 框架有2个，分别是spring aop 和aspectJ，前者是纯Java 实现的，不需要专门的编译过程和类加载器，在运行期间可以通过代理的方式向目标内植入增强的代码。</p><p>而AspectJ是一个基于Java语言的AOP框架。在Spring 2.0 开始，引入了对AspectJ 的支持，并提供了一个专门的编译器在编译时提供横向代码的植入。</p><p><img src="https://img.hznu.asia/AOP%E6%A6%82%E5%BF%B5%E5%9B%BE%E8%A7%A3.jpg"></p><h2 id="二-AOP常见术语"><a href="#二-AOP常见术语" class="headerlink" title="二. AOP常见术语"></a>二. AOP常见术语</h2><p><strong>1. 通知（Advice）</strong></p><p>切面在某个具体的连接点采取的行为或行动，称为通知。切面的核心逻辑代码都写在通知中，有人也称之为增强或者横切关注点。通知是切面功能的具体实现，通常是业务代码以外的需求，如日志、验证等，这些被模块化的特殊对象。</p><p>简单来说，假如你有某个你想要的功能，比如上面说的安全，事物，日志等。你给先定义好把，然后在想用的地方在某个地方用注解或者在xml中配置好，你想在哪里用这个事先定义好的模块化的内容。</p><blockquote><p>前置通知：org.springframework.aop.MethodBeforeAdvice<br>后置通知：org.springframework.aop.AfterReturningAdvice<br>异常通知：org.springframework.aop.ThrowsAdvice<br>环绕通知：org.aopalliance.intercept.MethodInterceptor</p></blockquote><p><strong>2. 连接点（JoinPoint）</strong></p><p>连接点就是 Spring AOP允许你使用通知（使用事先定义好的模块化的功能）的地方，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，<strong>Spring AOP 只支持方法连接点</strong>。</p><p>其他如 aspectJ 还可以让你在构造器或属性注入时都行，只要记住，<strong>和方法有关的前前后后（抛出异常），都是连接点。</strong></p><p><strong>3. 切入点（Pointcut）</strong></p><p>切入点是一个连接点的过滤条件，AOP 通过切点定位到特定的连接点。每个类都拥有多个连接点：例如 UserService类中的所有方法实际上都是连接点，即连接点是程序类中客观存在的事物。</p><p>类比：<strong>连接点相当于数据库中的记录，切点相当于查询条件</strong>。切点和连接点不是一对一的关系，<strong>一个切点匹配多个连接点</strong>，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p><p>比如你的一个类里，有15个方法，那就有几十个连接点了，但是你并不想在所有方法附近都使用通知（使用叫织入，后文会讲），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。</p><p><strong>4. 切面（Aspect）</strong></p><p>切面其实是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切入点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等干什么事），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p><p><strong>5. 引入（introduction）</strong></p><p>允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗？</p><p><strong>6. 目标（target）</strong></p><p>引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。</p><p><strong>7. 织入(weaving)</strong></p><p>把切面应用到目标对象来创建新的代理对象的过程。</p><h2 id="三-基于XML方式的实现"><a href="#三-基于XML方式的实现" class="headerlink" title="三. 基于XML方式的实现"></a>三. 基于XML方式的实现</h2><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a><strong>切入点表达式</strong></h4><p>　　作用: 知道对哪个类里面的哪个方法进行增强</p><p>　　语法结构: execution([权限修饰符] [返回类型] [类全路径] <a href="%5B%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%5D">方法名称</a>)</p><p>　　举例说明:</p><p>　　<strong>1. 对com.hznu.class 类里面的 add 方法进行增强:</strong></p><p>　　　　execution(* com.hznu.class.add(..))</p><p>　　　　说明: *表示包括public, private等所有修饰符, (..)表示所有参数</p><p>　　<strong>2. 对com.hznu.class 类里面的所有方法进行增强:</strong></p><p>　　　　execution(* com.hznu.class.*(..))</p><p>　　<strong>3. 对com.hznu包里面的所有类中的所有方法进行增强:</strong></p><p>　　　　execution(* com.hznu.<em>.</em>(..))</p><h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><ol><li>创建xml文件: (创建context和aop的名称空间; 开启注解扫描; 开启生成Aspect代理对象)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--开启注解扫描--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.hznu.aspect1&quot;&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--开启Aspect生成代理对象, 即找到带@aspect注解的类, 生成其代理对象--&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建被增强类 User.java: </li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//被增强的类</span><br><span class="line">@Component</span><br><span class="line">public class User &#123;</span><br><span class="line">    public void basic()&#123;</span><br><span class="line">        System.out.println(&quot;Basic method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建增强类 UserPro.java: </li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//增强的类</span><br><span class="line">@Component</span><br><span class="line">//生成代理对象</span><br><span class="line">@Aspect</span><br><span class="line">public class UserPro &#123;</span><br><span class="line"></span><br><span class="line">    //前置通知 使用切入点表达式, value可省略</span><br><span class="line">    @Before(value = &quot;execution(* com.hznu.aspect1.User.basic(..))&quot;)</span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;Before.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //最终通知, 在方法调用之后执行, 不管有无异常都执行</span><br><span class="line">    @After(value = &quot;execution(* com.hznu.aspect1.User.basic(..))&quot;)</span><br><span class="line">    public void After()&#123;</span><br><span class="line">        System.out.println(&quot;After.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //后置通知/返回通知, 在方法return值后执行, 有异常则不执行</span><br><span class="line">    @AfterReturning(value = &quot;execution(* com.hznu.aspect1.User.basic(..))&quot;)</span><br><span class="line">    public void AfterReturning()&#123;</span><br><span class="line">        System.out.println(&quot;AfterReturning.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //异常通知, 在方法产生异常时执行(可在被增强方法中通过1/0手动触发异常来触发)</span><br><span class="line">    @AfterThrowing(value = &quot;execution(* com.hznu.aspect1.User.basic(..))&quot;)</span><br><span class="line">    public void AfterThrowing()&#123;</span><br><span class="line">        System.out.println(&quot;AfterThrowing.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //环绕通知</span><br><span class="line">    @Around(value = &quot;execution(* com.hznu.aspect1.User.basic(..))&quot;)</span><br><span class="line">    public void Around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable&#123;</span><br><span class="line">        //方法之前执行内容</span><br><span class="line">        System.out.println(&quot;Around-Before.&quot;);</span><br><span class="line">        //被增强的方法执行</span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        //方法之后执行内容</span><br><span class="line">        System.out.println(&quot;Around-After&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>测试</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;com/hznu/aspect1/bean.xml&quot;);</span><br><span class="line">        User user = context.getBean(&quot;user&quot;, User.class);</span><br><span class="line">        user.basic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行结果</li></ol><p><img src="https://img.hznu.asia/AOP%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h2 id="四-项目中利用AOP注解实现日志"><a href="#四-项目中利用AOP注解实现日志" class="headerlink" title="四. 项目中利用AOP注解实现日志"></a>四. 项目中利用AOP注解实现日志</h2><h4 id="Jar包一览"><a href="#Jar包一览" class="headerlink" title="Jar包一览"></a>Jar包一览</h4><p>下图为AspectJ的主要一些注解，平时项目开发我一般都使用Spring + AspectJ</p><p><img src="https://img.hznu.asia/AOP%E7%9A%84Jar%E5%8C%85.png"></p><ol start="2"><li>定义 SysOperLog 实体类</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class SysOperLog</span><br><span class="line">&#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    /** 日志主键 */</span><br><span class="line">    @TableId(value = &quot;id&quot;, type = IdType.AUTO)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    /** 操作模块 */</span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    /** 业务类型（0其它 1新增 2修改 3删除） */</span><br><span class="line">    // &quot;0=其它,1=新增,2=修改,3=删除,4=授权,5=导出,6=导入,7=强退,8=生成代码,9=清空数据&quot;</span><br><span class="line">    private Integer businessType;</span><br><span class="line"></span><br><span class="line">    /** 业务类型数组 */</span><br><span class="line">    private Integer[] businessTypes;</span><br><span class="line"></span><br><span class="line">    /** 请求方法 */</span><br><span class="line">    private String method;</span><br><span class="line"></span><br><span class="line">    /** 请求方式 */</span><br><span class="line">    private String requestMethod;</span><br><span class="line"></span><br><span class="line">    /** 操作类别（0其它 1后台用户 2手机端用户） */</span><br><span class="line">    private Integer operatorType;</span><br><span class="line"></span><br><span class="line">    /** 操作人员 */</span><br><span class="line">    private String operName;</span><br><span class="line"></span><br><span class="line">    /** 部门名称 */</span><br><span class="line">    private String deptName;</span><br><span class="line"></span><br><span class="line">    /** 请求url */</span><br><span class="line">    private String operUrl;</span><br><span class="line"></span><br><span class="line">    /** 操作地址 */</span><br><span class="line">    private String operIp;</span><br><span class="line"></span><br><span class="line">    /** 请求参数 */</span><br><span class="line">    private String operParam;</span><br><span class="line"></span><br><span class="line">    /** 返回参数 */</span><br><span class="line">    private String jsonResult;</span><br><span class="line"></span><br><span class="line">    /** 操作状态（0正常 1异常） */</span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line">    /** 错误消息 */</span><br><span class="line">    private String errorMsg;</span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义自定义注解Log</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123; ElementType.PARAMETER, ElementType.METHOD &#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Log</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 模块</span><br><span class="line">     */</span><br><span class="line">    public String title() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 功能</span><br><span class="line">     */</span><br><span class="line">    public BusinessType businessType() default BusinessType.OTHER;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作人类别</span><br><span class="line">     */</span><br><span class="line">    public OperatorType operatorType() default OperatorType.MANAGE;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否保存请求的参数</span><br><span class="line">     */</span><br><span class="line">    public boolean isSaveRequestData() default true;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否保存响应的参数</span><br><span class="line">     */</span><br><span class="line">    public boolean isSaveResponseData() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>项目中定义日志切面</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作日志记录处理</span><br><span class="line"> * </span><br><span class="line"> * @author huangrui</span><br><span class="line"> */</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAspect</span><br><span class="line">&#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AsyncLogService asyncLogService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理完请求后执行</span><br><span class="line">     *</span><br><span class="line">     * @param joinPoint 切点</span><br><span class="line">     */</span><br><span class="line">    @AfterReturning(pointcut = &quot;@annotation(controllerLog)&quot;, returning = &quot;jsonResult&quot;) </span><br><span class="line">    public void doAfterReturning(JoinPoint joinPoint, Log controllerLog, Object jsonResult)</span><br><span class="line">    &#123;</span><br><span class="line">        handleLog(joinPoint, controllerLog, null, jsonResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 拦截异常操作</span><br><span class="line">     * </span><br><span class="line">     * @param joinPoint 切点</span><br><span class="line">     * @param e 异常</span><br><span class="line">     */</span><br><span class="line">    @AfterThrowing(value = &quot;@annotation(controllerLog)&quot;, throwing = &quot;e&quot;)</span><br><span class="line">    public void doAfterThrowing(JoinPoint joinPoint, Log controllerLog, Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        handleLog(joinPoint, controllerLog, e, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void handleLog(final JoinPoint joinPoint, Log controllerLog, final Exception e, Object jsonResult)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            // *========数据库日志=========*//</span><br><span class="line">            SysOperLog operLog = new SysOperLog();</span><br><span class="line">            operLog.set...(...);  // 此处省略与本文无关代码   </span><br><span class="line">            // 保存数据库</span><br><span class="line">            asyncLogService.saveSysLog(operLog);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception exp)</span><br><span class="line">        &#123;</span><br><span class="line">            // 记录本地异常日志</span><br><span class="line">            log.error(&quot;==前置通知异常==&quot;);</span><br><span class="line">            log.error(&quot;异常信息:&#123;&#125;&quot;, exp.getMessage());</span><br><span class="line">            exp.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取注解中对方法的描述信息 用于Controller层注解</span><br><span class="line">     * </span><br><span class="line">     * @param log 日志</span><br><span class="line">     * @param operLog 操作日志</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public void getControllerMethodDescription(JoinPoint joinPoint, Log log, SysOperLog operLog, Object jsonResult) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置action动作</span><br><span class="line">        operLog.setBusinessType(log.businessType().ordinal());</span><br><span class="line">        // 设置标题</span><br><span class="line">        operLog.setTitle(log.title());</span><br><span class="line">        // 设置操作人类别</span><br><span class="line">        operLog.setOperatorType(log.operatorType().ordinal());</span><br><span class="line">        // 是否需要保存request，参数和值</span><br><span class="line">        if (log.isSaveRequestData())</span><br><span class="line">        &#123;</span><br><span class="line">            // 获取参数的信息，传入到数据库中。</span><br><span class="line">            setRequestValue(joinPoint, operLog);</span><br><span class="line">        &#125;</span><br><span class="line">        // 是否需要保存response，参数和值</span><br><span class="line">        if (log.isSaveResponseData() &amp;&amp; StringUtils.isNotNull(jsonResult))</span><br><span class="line">        &#123;</span><br><span class="line">            operLog.setJsonResult(StringUtils.substring(com.alibaba.fastjson.JSON.toJSONString(jsonResult), 0, 2000));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取请求的参数，放到log中</span><br><span class="line">     * </span><br><span class="line">     * @param operLog 操作日志</span><br><span class="line">     * @throws Exception 异常</span><br><span class="line">     */</span><br><span class="line">    private void setRequestValue(JoinPoint joinPoint, SysOperLog operLog) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        String requestMethod = operLog.getRequestMethod();</span><br><span class="line">        if (HttpMethod.PUT.name().equals(requestMethod) || HttpMethod.POST.name().equals(requestMethod))</span><br><span class="line">        &#123;</span><br><span class="line">            String params = argsArrayToString(joinPoint.getArgs());</span><br><span class="line">            operLog.setOperParam(StringUtils.substring(params, 0, 2000));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>controller中使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> @Log(title = &quot;查询信息&quot;, operatorType = OperatorType.MOBILE)</span><br><span class="line"> @GetMapping(&quot;list&quot;)</span><br><span class="line"> public Response list() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心大致流程其实就是这样：</strong></p><ol><li><p>定义好一个实体类，主要就是用于保存日志到数据库中。（比如我们上面第三步new SysOperLog()，并且set了一些参数）</p></li><li><p>定义自定义注解Log，包含的参数参考上述第二步。</p></li><li><p>定义一个切面类，用@Aspect标识。这里主要关注两个注解：@AfterReturning 和 @AfterThrowing。一个是在自定义注解@Log标识的方法结束返回后调用，一个是在异常抛出后调用。</p><p>也就是说，在所有使用@Log标识的方法执行完后，都会调用 LogAspect 这个切面类中 被 @AfterReturning 注解作用的代码。@AfterThrowing也是同样的道理。</p></li><li><p>在Controller中使用注解@Log，并且定义好其参数。</p></li></ol><h2 id="五-JointPoint到底是什么"><a href="#五-JointPoint到底是什么" class="headerlink" title="五. JointPoint到底是什么"></a>五. JointPoint到底是什么</h2><p>在上文中，我们会看的这样一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@AfterReturning(pointcut = &quot;@annotation(controllerLog)&quot;, returning = &quot;jsonResult&quot;) </span><br><span class="line">public void doAfterReturning(JoinPoint joinPoint, Log controllerLog, Object jsonResult)&#123;</span><br><span class="line">handleLog(joinPoint, controllerLog, null, jsonResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里有一个JoinPoint类，JoinPoint是AOP的术语，称为“连接点”，而连接点在执行的时候可以看成当前请求类。什么意思呢？我们用上面的示例代码解释下：</p><p>比如现在有一个controller，里面有一个如下方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Log(title = &quot;查询信息&quot;, operatorType = OperatorType.MOBILE)</span><br><span class="line">@GetMapping(&quot;list&quot;)</span><br><span class="line">public Response list(@RequestParam(value = &quot;phone&quot;, required = false) String phone,</span><br><span class="line">                     @RequestParam(value = &quot;nickName&quot;, required = false) String nickName,</span><br><span class="line">                     @RequestParam(value = &quot;schoolId&quot;, required = false) String schoolId,</span><br><span class="line">                     @RequestParam(value = &quot;gender&quot;, required = false) String gender,</span><br><span class="line">                     @RequestParam(value = &quot;stealth&quot;, required = false) String stealth) &#123;</span><br><span class="line">        List&lt;User&gt; users = personalInformationService.list(phone, nickName, schoolId, gender, stealth);</span><br><span class="line">        return Response.success(users);</span><br></pre></td></tr></table></figure><p>上面的方法被 <code>@Log</code> 注解标识了，那么他就会执行我们在上文第四部分代码中的 <code>LogAspect</code> 类，那么这个<code>controller</code> 方法在执行完成后，则会执行我们本部分开头的那段代码，然后我们就可以在这个切面中做我们想做的事情，正如第四部分一样，对日志信息进行了处理。</p><p>在执行本部分开头代码的时候，<code>doAfterReturning</code> 方法第一个参数是 <code>JoinPoint joinPoint</code>，而<code>jointPoint</code> 里面包含的，就是我们 <code>controller</code> 里的 <code>list</code> 方法。我们debug看下里面包含哪些内容：</p><p><img src="https://img.hznu.asia/SpringAOP%E4%B9%8BJointPoint%E7%9A%84Debug%E5%9B%BE.png"></p><p>我们一个个来看下：</p><ul><li>joinPoint.getArgs();</li></ul><p>此方法是获取 <code>controller</code> 里的 <code>list</code> 方法里的请求参数，比如我用 <code>PostMan</code> 发起一个请求，请求参数里面包含 <code>phone</code> 这个字段，如下：</p><p><img src="https://img.hznu.asia/SpringAOP%E4%B9%8BJointPoint%E7%9A%84Postman%E8%AF%B7%E6%B1%82Args%E5%9B%BE.png"></p><p>那么我们的debug界面的 <code>args</code> 里就能看到这个参数，这里的<code>args</code> 是一个数组的形式</p><p><img src="https://img.hznu.asia/SpringAOP%E4%B9%8BJointPoint%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AF%B7%E6%B1%82Args%E5%9B%BE.png"></p><p>所以我们可以得出， <code>joinPoint.getArgs()</code> 获取的就是连接点（指的就是被注解标识，被请求 <code>controller</code> 里的 <code>list</code> 方法，后文统一称为连接点）的参数。</p><ul><li>joinPoint.getSignature();</li></ul><p>返回正在请求的方法的描述，可参考本部分第一张图</p><ul><li>joinPoint.getTarget();</li></ul><p>返回目标 object，可参考本部分第一张图</p><ul><li>joinPoint.getThis();</li></ul><p>返回代理 object，可参考本部分第一张图</p><ul><li>joinPoint.toString();</li></ul><p>打印建议方法的有用描述，可参考本部分第一张图</p><p><strong>所以，经过debug分析来看，<code>JoinPoint</code> 类的主要作用就是可以让我们在Advice中获取被增强方法相关的所有信息。</strong></p><h2 id="六-可能存在的疑惑"><a href="#六-可能存在的疑惑" class="headerlink" title="六. 可能存在的疑惑"></a>六. 可能存在的疑惑</h2><ol><li>LogAspect 类如何知道自定义注解 @Log 作用了哪些方法，又是如和获取他们的？</li></ol><p>这里主要有两种方法，一种是通过反射，获取包含 @Log注解的类或方法。另一种就是通过 @annotation，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@AfterThrowing(value = &quot;@annotation(controllerLog)&quot;, throwing = &quot;e&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@annotation：就是用于匹配当前执行方法持有指定注解的方法</span><br></pre></td></tr></table></figure><h2 id="参考引用："><a href="#参考引用：" class="headerlink" title="参考引用："></a>参考引用：</h2><blockquote></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/Spring/">Spring</category>
      
      
      <category domain="http://hznu.asia/tags/Spring-AOP/">Spring AOP</category>
      
      
      <comments>http://hznu.asia/2022/07/02/Spring-AOP%E7%9A%84%E5%BA%94%E7%94%A8-%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E7%9A%84%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8EAspectJ/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>程序中Error和Exception的区别和处理方式</title>
      <link>http://hznu.asia/2022/06/29/%E7%A8%8B%E5%BA%8F%E4%B8%ADError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</link>
      <guid>http://hznu.asia/2022/06/29/%E7%A8%8B%E5%BA%8F%E4%B8%ADError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</guid>
      <pubDate>Wed, 29 Jun 2022 03:23:50 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;一-异常的分类&quot;&gt;&lt;a href=&quot;#一-异常的分类&quot; class=&quot;headerlink&quot; title=&quot;一. 异常的分类&quot;&gt;&lt;/a&gt;一. 异常的分类&lt;/h2&gt;&lt;p&gt;在 Java 中所有异常类型都是内置类 java.lang.Throwable 类的子类，即 T</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="一-异常的分类"><a href="#一-异常的分类" class="headerlink" title="一. 异常的分类"></a>一. 异常的分类</h2><p>在 Java 中所有异常类型都是内置类 java.lang.Throwable 类的子类，即 Throwable 位于异常类层次结构的顶层。Throwable 类下有两个异常分支 Exception 和 Error，而Exception分为 ”检查异常（非运行时异常）“ 和 ”不检查异常（运行时异常，RuntimeException）“。如下图所示：</p><p><img src="https://img.hznu.asia/%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E5%88%86%E7%B1%BB.png"></p><h4 id="1-1-Error-和-Exception-的异同点"><a href="#1-1-Error-和-Exception-的异同点" class="headerlink" title="1.1 Error 和 Exception 的异同点"></a>1.1 Error 和 Exception 的异同点</h4><p><strong>相同点：</strong> </p><p>1、Exception 和 Error 都集成了同一个类 Throwable。因为在Java中只有继承了Throwable类的实例才可以被抛出或者捕获。 </p><p><strong>不同点：</strong> </p><p>1、Error 会导致程序处于非正常的，不可恢复的状态，比如JVM自身的问题，OutOfMemoyError 等。 </p><p>２、Exception分为两种：可检查异常和不可检查异常。 在编译阶段显示捕获的异常称为可检查异常，比如IO异常。 在运行时被捕获的异常称为不可检查异常，比如空指针、数组越界。</p><h4 id="1-2-检查异常和非检查异常"><a href="#1-2-检查异常和非检查异常" class="headerlink" title="1.2 检查异常和非检查异常"></a>1.2 检查异常和非检查异常</h4><p><strong>检查异常：</strong>没有继承RuntimeException的Exception属于检查异常，这类问题在编译期就可以确定的问题，如<strong>FileNotFoundException、IOException</strong>。编译器对检查异常的处理要求：</p><ul><li>try..catch捕获。</li><li>不断向上抛出，交由jvm来处理。 </li></ul><p><strong>非检查异常：</strong>继承了RuntimeException的Exception，非检查异常也叫<strong>运行时异常</strong>，这类问题大部分属于逻辑问题，如<strong>数组越界、空指针异常</strong>，只有运行时才能知道的问题，异常在编译时不会检查。通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p><h4 id="类比解释"><a href="#类比解释" class="headerlink" title="类比解释"></a>类比解释</h4><p>假如你开车上山，车坏了，你拿出工具箱修一修，修好继续上路（Exception被捕获，从异常中恢复，继续程序的运行），车坏了，你不知道怎么修，打电话告诉修车行，告诉你是什么问题，要车行过来修。（在当前的逻辑背景下，你不知道是怎么样的处理逻辑，把异常抛出去到更高的业务层来处理）。你打电话的时候，要尽量具体，不能只说我车动不了了。那修车行很难定位你的问题。（要补货特定的异常，不能捕获类似Exception的通用异常）。还有一种情况是，你开车上山，山塌了，这你还能修吗？（Error：导致你的运行环境进入不正常的状态，很难恢复）</p><h2 id="二-异常处理准则"><a href="#二-异常处理准则" class="headerlink" title="二. 异常处理准则"></a>二. 异常处理准则</h2><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  // 业务代码</span><br><span class="line">  // …</span><br><span class="line">  Thread.sleep(1000L);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">  // Ignore it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码尽管很短，但是已经<strong>违反了两个准则</strong>。</p><ol><li><strong>尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常，在这里是 Thread.sleep() 抛出的 InterruptedException。</strong></li></ol><blockquote><p>这是因为在日常的开发和合作中，我们读代码的机会往往超过写代码，软件工程是门协作的艺术，所以我们有义务让自己的代码能够直观地体现出尽量多的信息，而泛泛的 Exception 之类，恰恰隐藏了我们的目的。另外，我们也要保证程序不会捕获到我们不希望捕获的异常。比如，你可能更希望 RuntimeException 被扩散出来，而不是被捕获。</p><p>进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确程序处理 OutOfMemoryError。</p></blockquote><ol start="2"><li><strong>不要生吞（swallow）异常。这是异常处理中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况。</strong></li></ol><blockquote><p>生吞异常，往往是基于假设这段代码可能不会发生，或者感觉忽略异常是无所谓的，但是千万不要在产品代码做这种假设。<strong><em>如果我们不把异常抛出来，或者也没有输出到日志（Logger）之类，程序可能在后续代码以不可控的方式结束</em>。</strong>没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。</p></blockquote><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   // 业务代码</span><br><span class="line">   // …</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码作为一段实验代码，它是没有任何问题的，但是在产品代码中，通常都不允许这样处理。</p><blockquote><p>我们先来看看printStackTrace()的文档，开头就是“Prints this throwable and its backtrace to the standard error stream”。简单说，就是 在命令行打印异常信息在程序中出错的位置及原因。</p><p>问题就在这里，在稍微复杂一点的生产系统中，标准出错（STERR）不是个合适的输出选项，因为你很难判断出到底输出到哪里去了。</p><p>尤其是对于分布式系统，如果发生异常，无法找到堆栈轨迹（stacktrace），这纯属是为诊断设置障碍。所以，最好使用产品日志，详细地输出到日志系统里。</p></blockquote><h4 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void readPreferences(String fileName)&#123;</span><br><span class="line">  InputStream in = new FileInputStream(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 fileName 是 null，那么程序就会抛出 NullPointerException，但是由于没有第一时间暴露出问题，堆栈信息可能非常令人费解，往往需要相对复杂的定位。这个 NPE 只是作为例子，实际产品代码中，可能是各种情况，比如获取配置失败之类的。在发现问题的时候，第一时间抛出，能够更加清晰地反映问题。</p><p>我们可以修改一下，让问题“throw early”，对应的异常信息就非常直观了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void readPreferences(String filename) &#123;</span><br><span class="line">  Objects.requireNonNull(filename);</span><br><span class="line">  InputStream in = new FileInputStream(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于“catch late”，其实是我们经常苦恼的问题，捕获异常后，需要怎么处理呢？最差的处理方式，就是我前面提到的“生吞异常”，本质上其实是掩盖问题。如果实在不知道如何处理，可以选择保留原有异常的 cause 信息，直接再抛出或者构建新的异常抛出去。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。</p><p><strong>所以，catch late，就是尽量晚的处理异常，在越外层处理越好。</strong></p><h4 id="关于-Checked-Exception（非运行时异常）"><a href="#关于-Checked-Exception（非运行时异常）" class="headerlink" title="关于 Checked Exception（非运行时异常）"></a>关于 Checked Exception（非运行时异常）</h4><p>业界有一种争论（甚至可以算是某种程度的共识），Java 语言的 Checked Exception 也许是个设计错误，反对者列举了几点：</p><ul><li>Checked Exception 的假设是我们捕获了异常，然后恢复程序。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception 的使用，已经大大偏离了最初的设计目的。</li><li>Checked Exception 不兼容 functional 编程，如果你写过 Lambda/Stream 代码，相信深有体会。</li></ul><blockquote><p>比如对于运行时异常，可以使用 list1.stream().filter(Objects::nonNull).map(); 判断非空</p><p>而对于 FileNotFoundException、IOException 等非运行时异常，则无法使用Lambda 和 Stream</p></blockquote><p>但是，很多人也觉得没有必要矫枉过正，因为确实有一些异常，比如和环境相关的 IO、网络等，其实是存在可恢复性的，而且 Java 已经通过业界的海量实践，证明了其构建高质量软件的能力。</p><h2 id="三-性能分析"><a href="#三-性能分析" class="headerlink" title="三. 性能分析"></a>三. 性能分析</h2><ul><li>try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，<strong>尽量不要一个大的 try 包住整段的代码</strong>；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</li><li><strong>Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作</strong>。如果发生的非常频繁，这个开销可就不能被忽略了。</li></ul><blockquote><p><strong>异常实例的构造十分昂贵。这是由于在构造异常实例时，Java 虚拟机便需要生成该异常的栈轨迹（stack trace）。该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。</strong></p></blockquote><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><ol><li><strong>NoClassDefFoundError 和 ClassNotFoundException 有什么区别？</strong></li></ol><p>NoClassDefFoundError 是个Error，是指一个class在编译时存在，在运行时找不到了class文件了；ClassNotFoundException 是个Exception，是使用类似Class.foName()等方法时的checked exception。</p><p>类的加载分为显式加载(用字符串为类名加载类，抛出ClassNotFoundException)和隐式加载(不是通过显式方法调用，由引用、实例化或继承导致装入类。通常这种错误在编译阶段会发现，报错为找不到符号。如果编译时能找到这个类，但运行时找不到这个类，就抛出NoClassDefFoundError)</p><ol start="2"><li>throw 和 throws 的区别？</li></ol><p><strong>throw</strong></p><p> 1、throw是语句抛出一个异常，一般是在<strong>代码块的内部</strong>，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常 </p><p>2、定义在方法体内 </p><p>3、创建的是一个异常对象 </p><p>4、确定了发生哪种异常才可以使用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final String upload(String baseDir, MultipartFile file) throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            return upload(baseDir, file, MimeTypeUtils.DEFAULT_ALLOWED_EXTENSION);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new IOException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>throws</strong> </p><p>1、<strong>在方法参数列表后</strong>，throws后可以跟着多个异常名，表示抛出的异常用逗号隔开 </p><p>2、<strong>表示向调用该类的位置抛出异常，不在该类解决</strong> </p><p>3、可能发生哪种异常 throws用在方法声明后面，跟的是异常类名，throw用在方法体内，跟的是异常对象名。 throws可以跟多个异常类名，用逗号隔开，throw只能抛出一个异常对象名。 throws表示抛出异常，由该方法的调用者来处理，throw表示抛出异常，由方法体内的语句处理。 throws表示出现异常的一种可能性，并不一定会发生这些异常，throw则是抛出了异常，执行throw则一定抛出了某种异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void openFile() throws FileNotFoundException&#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考引用：</p><blockquote><p>【1】 <a href="https://time.geekbang.org/column/article/6849?cid=100006701">https://time.geekbang.org/column/article/6849?cid=100006701</a> </p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/Java/">Java</category>
      
      
      <category domain="http://hznu.asia/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</category>
      
      
      <comments>http://hznu.asia/2022/06/29/%E7%A8%8B%E5%BA%8F%E4%B8%ADError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络--运输层那点事</title>
      <link>http://hznu.asia/2022/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E9%82%A3%E7%82%B9%E4%BA%8B/</link>
      <guid>http://hznu.asia/2022/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E9%82%A3%E7%82%B9%E4%BA%8B/</guid>
      <pubDate>Tue, 21 Jun 2022 01:52:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;写在前面：本篇博客是在看完《计算机网络：自顶向下方法》运输层一章写的，但是写着写着感觉东西实在太多，重要的点也很多。因此只挑选一些常见且相对重要的点记录下来。遇到问题，还是建议去翻一翻本章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概念</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>写在前面：本篇博客是在看完《计算机网络：自顶向下方法》运输层一章写的，但是写着写着感觉东西实在太多，重要的点也很多。因此只挑选一些常见且相对重要的点记录下来。遇到问题，还是建议去翻一翻本章。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="运输层协议"><a href="#运输层协议" class="headerlink" title="运输层协议"></a>运输层协议</h4><p>​        运输层协议是<strong>在端系统中而不是在路由器</strong>中实现的。</p><p>​        在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层报文段实现的方法（可能）是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。然后，在发送端系统中，运输层将这些报文段传递给网络层，网络层将其封装成网络层分组（即数据报）并向目的地发送。</p><p>​        注意到下列事实是重要的：网络路由器仅作用于该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。运输层则处理接收到的报文段，使该报文段中的数据为接收应用进程使用</p><h4 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h4><blockquote><p>​        考虑有两个家庭，一家位于美国东海岸，一家位于美国西海岸，每家有12个孩子。 东海岸家庭的孩子们是西海岸家庭孩子们的堂兄弟姐妹。这两个家庭的孩子们喜欢彼此通信，每个人每星期要互相写一封信，每封信都用单独的信封通过传统的邮政服务传送。</p><p>​         因此，每个家庭每星期向另一家发送144封信。（如果他们有电子邮件的话，这些孩子可以 省不少钱！）每一个家庭有个孩子负责收发邮件，西海岸家庭是Ann而东海岸家庭是Bill。 每星期Ann去她的所有兄弟姐妹那里收集信件，并将这些信件交到每天到家门口来的邮政 服务的邮车上。当信件到达西海岸家庭时，Ann也负责将信件分发到她的兄弟姐妹手上。 在东海岸家庭中的Bill也负责类似的工作。</p><p>​        在这个例子中，邮政服务为两个家庭间提供逻辑通信，邮政服务将信件从一家送往另 一家，而不是从一个人送往另一个人。在另一方面，Ann和Bill为堂兄弟姐妹之间提供了 逻辑通信，Arm和Bill从兄弟姐妹那里收取信件或到兄弟姐妹那里交付信件。注意到从堂 兄弟姐妹们的角度来看，Ann和Bill就是邮件服务，尽管他们只是端到端交付过程的一部 分（即端系统部分）。在解释运输层和网络层之间的关系时，这个家庭的例子是一个非常 好的类比。</p><p><strong>应用层报文 = 信封上的字符</strong> </p><p><strong>进程 = 堂兄弟姐妹</strong> </p><p><strong>主机（又称为端系统）= 家庭</strong> </p><p><strong>运输层协议 = Ann和Bill</strong> </p><p><strong>网络层协议 = 邮政服务（包括邮车）</strong></p></blockquote><h4 id="为什么需要TCP协议"><a href="#为什么需要TCP协议" class="headerlink" title="为什么需要TCP协议"></a>为什么需要TCP协议</h4><p>​        不少人应该听说过TCP/IP协议，并且对此有一定的了解。其中，TCP协议处于运输层，而IP协议处于网络层。</p><p>​        其中，IP的服务模型是尽力而为交付服务， 这意味着IP尽它“最大的努力”在通信的主机之间交付报文段，但它并不做任何确保。特别是，它不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性。由于这些原因，IP被称为不可靠服务。由此，就需要TCP来做可靠性传输保障了。</p><p>​        TCP协议是运输层中非常重要的一个协议，除了提供可靠性传输之外，TCP还提供拥塞控制等功能，后文会展开讲解。</p><h4 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h4><p>​        在接收端，运输层检查这些字段，标识出接收套 接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工 作称为多路分解。</p><p>​        在源主机从不同套接字中收集数据块，并为每个数据 块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将报文段传递到网络 层，所有这些工作称为多路复用。</p><h4 id="流行应用即下面的运输层协议"><a href="#流行应用即下面的运输层协议" class="headerlink" title="流行应用即下面的运输层协议"></a>流行应用即下面的运输层协议</h4><table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">下面的运输协议</th></tr></thead><tbody><tr><td align="center">电子邮件</td><td align="center">SMTP</td><td align="center">TCP</td></tr><tr><td align="center">远程终端访问</td><td align="center">Telnet</td><td align="center">TCP</td></tr><tr><td align="center">Web</td><td align="center">HTTP</td><td align="center">TCP</td></tr><tr><td align="center">文件传输</td><td align="center">FTP</td><td align="center">TCP</td></tr><tr><td align="center">远程文件服务器</td><td align="center">NFS</td><td align="center">通常UDP</td></tr><tr><td align="center">流式多媒体</td><td align="center">通常专用</td><td align="center">UDP或TCP</td></tr><tr><td align="center">因特网电话</td><td align="center">通常专用</td><td align="center">UDP或TCP</td></tr><tr><td align="center">网络管理</td><td align="center">SNMP</td><td align="center">通常UDP</td></tr><tr><td align="center">名字转换</td><td align="center">DNS</td><td align="center">通常UDP</td></tr></tbody></table><h4 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h4><table><thead><tr><th>对比点</th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多交互通信</td><td>一对一</td></tr><tr><td>首部开销</td><td>首部开销小，8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td>使用场景</td><td>实用应用（IP电话、视频会议等）</td><td>文件传输等</td></tr></tbody></table><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>TCP和UDP都是运输层常用的协议，两者之间各有优劣</p><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><ol><li><p>TCP为什么要三次握手？</p></li><li><p>套接字和报文的区别是什么？</p></li></ol><blockquote><p>TCP的分组称为报文段</p></blockquote><ol start="3"><li>拥塞控制和流量控制服务的区别</li></ol><h2 id="参考引用："><a href="#参考引用：" class="headerlink" title="参考引用："></a>参考引用：</h2><blockquote><p>【1】计算机网络–自顶向下方法（第七版） </p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</category>
      
      
      <category domain="http://hznu.asia/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</category>
      
      
      <comments>http://hznu.asia/2022/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E9%82%A3%E7%82%B9%E4%BA%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>吉他入门</title>
      <link>http://hznu.asia/2022/05/13/%E5%90%89%E4%BB%96%E5%85%A5%E9%97%A8/</link>
      <guid>http://hznu.asia/2022/05/13/%E5%90%89%E4%BB%96%E5%85%A5%E9%97%A8/</guid>
      <pubDate>Fri, 13 May 2022 10:57:01 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://img.hznu.asia/%E5%BC%A6%E5%92%8C%E6%89%8B.png&quot;&gt;&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://img.hznu.asia/%E5%BC%A6%E5%92%8C%E6%89%8B.png"></p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E5%90%89%E4%BB%96/">吉他</category>
      
      
      
      <comments>http://hznu.asia/2022/05/13/%E5%90%89%E4%BB%96%E5%85%A5%E9%97%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>理解进程与线程</title>
      <link>http://hznu.asia/2022/04/27/%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <guid>http://hznu.asia/2022/04/27/%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <pubDate>Wed, 27 Apr 2022 07:53:20 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;一-进程&quot;&gt;&lt;a href=&quot;#一-进程&quot; class=&quot;headerlink&quot; title=&quot;一. 进程&quot;&gt;&lt;/a&gt;一. 进程&lt;/h2&gt;&lt;p&gt;进程（Process）是系统进行资源分配和调度的基本单位，是操作系统结构的基础。大白话讲，进程本质上是正在执行的一个程序</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="一-进程"><a href="#一-进程" class="headerlink" title="一. 进程"></a>一. 进程</h2><p>进程（Process）是系统进行资源分配和调度的基本单位，是操作系统结构的基础。大白话讲，进程本质上是正在执行的一个程序，并且，<strong>如果一个程序如果运行了两遍，则算作两个进程</strong>。</p><p>与每个进程相关的是地址空间，这是从某个最小值的存储位置（通常是0）到某个最大值的存储位置的列表。在这个地址空间中，进程可以读写。该地址空间存放有可执行程序、程序的数据以及程序的堆栈。</p><h5 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h5><p>在许多操作系统中，与一个进程有关的所有信息，除了该进程自身的地址空间的内容外，均存放在操作系统的一张表中，称为<strong>进程表</strong>，进程表是数组（或链表）结构，当前存在的进程都要占有其中一项。</p><p>所以，一个（挂起的）进程包括：进程的地址空间以及对应的进程表项（其中包括寄存器以及稍后重启该进程所需要的许多其他信息）。</p><h4 id="进程的组成："><a href="#进程的组成：" class="headerlink" title="进程的组成："></a>进程的组成：</h4><p><strong>进程是由程序控制块（PCB）、程序段、数据段组成。</strong></p><p>操作系统是通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需的各种信息，如进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息。</p><p>程序段：程序代码存放的位置。</p><p>数据段：程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量就存放在数据段内。</p><p><img src="http://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84" alt="http://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84"></p><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>在非常简单的系统中，比如微波炉中的控制器以及类似的系统，因为只为一个应用程序而设计，所以在启动时，所有在之后运行过程中需要的程序便已经存在。但是在更为复杂的操作系统中，需要有一种方式来创建或消耗进程。</p><p>主要有四种主要事件会创建进程：</p><p>​    1）系统初始化</p><p>​    2）正在运行的程序执行了创建进程的系统调用</p><p>​    3）用户请求创建一个新进程</p><p>​    4）一个批处理作业的初始化</p><p>启动操作系统时，通常会创建若干进程，其中有些是前台进程，也就是同用户交互并完成其相关指令的进程。还有些则是后台进程，这些与用户没有关系，比如一个接受电子邮件的进程，其大部分时间处于睡眠状态，但是当电子邮件到达时便被唤醒。这些停留在后台处理的进程称为<strong>守护进程</strong>。在大型系统中有很多守护进程，比如在Unix中，可以用<code>ps</code>指令列出正在运行的进程；在<code>Windows</code>中，则可以使用任务管理器。</p><p>在多处理机中，让每个进程在不同的CPU上运行会使整个作业运行得更快。进程创建的方式有许多种，在所有的情形中，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程做的工作是：执行一个用来创建新进程的系统调用，这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定在该进程中运行地程序。</p><p>此外，不同的操作系统也有不同的进程创建方式。</p><h5 id="Unix操作系统创建进程"><a href="#Unix操作系统创建进程" class="headerlink" title="Unix操作系统创建进程"></a>Unix操作系统创建进程</h5><p>在Unix操作系统中，只有一个系统调用可以创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用fork后，这两个进程（父进程和子进程）拥有相同的内存映像和相同的打开文件。通常，子进程接着执行<code>execve</code>或一个类似的系统调用，用于修改其内存映像并运行一个新的程序。之所以安排两步，是为了在fork后但在<code>execve</code>之前允许该子进程处理其文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。</p><h5 id="Windows操作系统创建进程"><a href="#Windows操作系统创建进程" class="headerlink" title="Windows操作系统创建进程"></a>Windows操作系统创建进程</h5><p>在，Windows中，情形正好相反，一个<code>Win32</code>函数调用<code>CreateProcess</code>既处理进程的创建，也负责把正确的程序装入新的进程。除了<code>CreateProcess</code>，Win32中大约有100个其他的函数用于处理进程的管理、同步以及相关的事物。</p><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><p>进程在创建之后，以下行为将引起终止：</p><p>​    1）正常退出（自愿的）</p><p>​    2）出错退出（自愿的）</p><p>​    3）严重错误（非自愿）</p><p>​    4）被其他进程杀死（非自愿）</p><p>其中第二个原因时<strong>进程发现了错误</strong>，比如用户输入 cc <code>foo.c</code> 编译程序 <code>foo.c</code>，但是该文件不存在，于是编译器退出。</p><p>第三个原因时<strong>由进程引起的错误</strong>，比如执行了一条非法指令，或者引用了一段不存在的内存或除数为0等等。</p><h4 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h4><h5 id="Unix中的结构"><a href="#Unix中的结构" class="headerlink" title="Unix中的结构"></a>Unix中的结构</h5><p>在Unix中，进程和它的所有子进程以及后裔共同组成了一个进程组。</p><p>Unix在初始化自己时，一个称为<code>init</code>的特殊进程出现在启动镜像中，当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录，如果有一个用户登录成功，该登录进程就执行一个<code>shell</code>准备接收命令。所接收的这些命令会启动更多的进程，以此类推。这样，在整个系统中，所有的进程都属于以<code>init</code>为根的一棵树。</p><h5 id="Windows中的结构"><a href="#Windows中的结构" class="headerlink" title="Windows中的结构"></a>Windows中的结构</h5><p>相反, Windows中没有进程层次的概念,所有的进程都是地位相同的。唯一类似于进程层次的暗示是在创建进程的时候,父进程得到一个特别的令牌(称为句柄),该句柄可以用来控制子进程。但是,它有权把这个令牌传送给某个其他进程,这样就不存在进程层次了。在UNIX中,进程就不能剥夺其子继承的“继承权”。 </p><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p>进程分三种状态：</p><p>​    1）就绪态（该时刻进程实际占用CPU）</p><p>​    2）就绪态（可运行，但因为其他进程正在运行而暂时停止）</p><p>​    3）阻塞态（除非某种外部事件发生，否则进程不能运行）</p><p><img src="https://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p><p>前两种状态在逻辑上是类似的。处于这两种状态的进程都可以运行,只是对于第二种状态暂时没有CPU分配给它。第三种状态与前两种状态不同,处于该状态的进程不能运行,即使CPU空闲也不行。</p><h4 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h4><p>为了实现进程模型,操作系统维护着一张表格(一个结构数组),即进程表(process table)。每个进程占用一个进程表项 (有些作者称这些表项为进程控制块) 该表项包含了进程状态的重要信息,包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息,以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息,从而保证该进程随后能再次启动,就像从未被中断过一样。 </p><p><img src="https://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E8%A1%A8%E5%AD%97%E6%AE%B5.png"></p><p>在了解进程表后,就可以对在单个(或每一个) CPU上如何维持多个顺序进程的错觉做更多的阐述。<strong>与每一I/O类关联的是一个称作中断向量(interrupt vector)的位置(靠近内存底部的固定区域)。它包含中断服务程序的人口地址。假设当一个磁盘中断发生时,用户进程3正在运行,则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈,计算机随即跳转到中断向量所指示的地址。这些是硬件完成的所有操作,然后软件,特别是中断服务例程就接管一切剩余的工作。</strong> </p><p>其实这个操作，说白了，就是先保存到寄存器，再将一个或多个寄存器压入进程堆栈，再把进程存到进程表中。</p><p>所有的中断都从保存寄存器开始,对于当前进程而言,通常是保存在进程表项中。随后,会从堆栈中删除由中断硬件机制存人堆栈的那部分信息,并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。</p><h2 id="二-线程"><a href="#二-线程" class="headerlink" title="二. 线程"></a>二. 线程</h2><h4 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h4><p>需要线程的几个理由：</p><p>​    1）人们需要多线程的主要原因是,在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程,程序设计模型会变得更简单。</p><p>​    2）第二个关于需要多线程的理由是,由于线程比进程更轻量级,所以它们比进程更容易(即更快)创建,也更容易撤销。在许多系统中,创建一个线程较创建一个进程要快10~100倍。在有大量线程需要动态和快速修改时,具有这一特性是很有用的。</p><p>​    3）需要多线程的第三个原因涉及性能方面的讨论。若多个线程都是CPU密集型的,那么并不能获得性能上的增强,但是如果存在着大量的计算和大量的I/0处理,拥有多个线程允许这些活动彼此重叠进行,从而会加快应用程序执行的速度。最后,在多CPU系统中,多线程是有益的,在这样的系统中,真正的并行有了实现的可能。</p><ul><li><p>​    <strong>CPU密集型程序：</strong>程序中进行大量的数据运算处理，花费了绝大部分时间在计算上。最佳线程数 = CPU核心数 + 1，+1 是为防止有线程被阻塞，CPU可以调    用其他线程。</p></li><li><p>​    <strong>IO密集型程序：</strong>多任务并行处理，程序中大量进行IO操作，对CPU要求并不高，因此执行流个数没有太大要求。</p><p>​    最佳线程数  = 1/CPU利用率 = 1 + (I/O耗时) / (CPU耗时)；一般为CPU核心数的两倍。</p></li></ul><h4 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h4><p>在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。 </p><p><strong>进程中的不同线程</strong>不像不同进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写或甚至清除另一个线程的堆栈。线程之间是没有保护的，原因是: </p><p>1)不可能</p><p>2)也没有必要。</p><p>这与不同进程是有差别的。不同的进程会来自不同的用户，它们彼此之间可能有敌意，一个进程总是由某个用户所拥有，该用户创建多个线程应该是为了它们之间的合作而不是彼此间争斗。除了共享地址空间之外，所有线程还共享同一个打开文件集、子进程、定时器以及相关信号等，如图212所示。这样,对于三个没有关系的线程而言，应该使用下图第一列的结构，而在三个线程实际完成同一个作业，并彼此积极密切合作的情形中，下图第二列则比较合适。 </p><table><thead><tr><th align="center">每个进程中的内容</th><th align="center">每个线程中的内容</th></tr></thead><tbody><tr><td align="center">地址空间<br>全局变量<br>打开文件<br>子进程<br>即将发生的定时器<br>信号与信号处理程序<br>账户信息</td><td align="center">程序计数器<br>寄存器<br>堆栈<br>状态</td></tr></tbody></table><p><strong>线程概念试图实现的是：共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。</strong></p><h4 id="在用户空间实现线程"><a href="#在用户空间实现线程" class="headerlink" title="在用户空间实现线程"></a>在用户空间实现线程</h4><p><strong>有两种主要的方法实现线程包：在用户空间中和内核中。</strong>这两种方法各有利弊，不过也有混合实现的方式。</p><p>在用户空间管理线程时，每个进程需要有其专用的线程表(thread table)，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈、指针、寄存器和状态等。该线程表由运行时系统管理，当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。</p><p>当某个线程做了一些会引起在本地阻塞的事情之后,例如,等待进程中另一个线程完成某项工作,它调用一个运行时系统的过程,这个过程检查该线程是否必须进人阻塞状态。如果是,它在线程表中保存该线程的寄存器(即它本身的),查看表中可运行的就绪线程,并把新线程的保存值重新装入机器的寄存器中。</p><p>只要堆栈指针和程序计数器一被切换，新的线程就又自动投入运行。如果机器有一条保存所有寄存器的指令和另一条装入全部寄存器的指令，那么整个线程的切换可以在几条指令内完成。进行类似,于这样的线程切换至少比陷入内核要快一个数量级(或许更多)，这是使用用户级线程包的极大的优点。</p><h4 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h4><p>内核的线程表保存了每个线程的寄存器、状态和其他信息。这些信息和在用户空间中(在运行时系·统中)的线程是一样的,但是现在保存在内核中。这些信息是传统内核所维护的每个单线程进程信息(即进程状态)的子集。另外,内核还维护了传统的进程表,以便跟踪进程的状态。</p><p>由于在内核中创建或撤销线程的代价比较大,某些系统采取“环保”的处理方式,回收其线程。当某个线程被撤销时,就把它标志为不可运行的,但是其内核数据结构没有受到影响。稍后,在必须创建一个新线程时,就重新启动某个旧线程,从而节省了一些开销。在用户级线程中线程回收也是可能的,但是由于其线程管理的代价很小,所以没有必要进行这项工作。</p><p><strong>存在的问题：</strong></p><ol><li>为什么在内核中创建或撤销线程的代价比较大</li></ol><p><strong>参考引用：</strong></p><blockquote></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</category>
      
      
      <category domain="http://hznu.asia/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</category>
      
      
      <comments>http://hznu.asia/2022/04/27/%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringDataJPA的前世今生</title>
      <link>http://hznu.asia/2022/04/23/SpringDataJPA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</link>
      <guid>http://hznu.asia/2022/04/23/SpringDataJPA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</guid>
      <pubDate>Sat, 23 Apr 2022 05:47:11 GMT</pubDate>
      
        
        
      <description>&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</description>
        
      
      
      
      <content:encoded><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前言：</span><br><span class="line">Java 持久层框架访问数据库的方式大致分为两种：一种以 SQL 核心，封装一定程度的 JDBC 操作，比如： MyBatis。</span><br><span class="line">另一种是以 Java 实体类为核心，将实体类的和数据库表之间建立映射关系，也就是我们说的 ORM 框架，如：Hibernate、Spring Data JPA。</span><br></pre></td></tr></table></figure><p><strong>在了解<code>Spring Data JPA</code>前，有必要先了解几个概念——<code>JPA</code>、<code>Hibernate</code>和<code>Spring Data JPA</code>。</strong></p><h2 id="一-JPA-、Hibernate-和-Spring-Data"><a href="#一-JPA-、Hibernate-和-Spring-Data" class="headerlink" title="一. JPA 、Hibernate 和 Spring Data"></a>一. JPA 、Hibernate 和 Spring Data</h2><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p>​        <code>Spring Data JPA</code>是建立的JPA的基础之上， 那么什么是JPA？</p><p>​        我们都知道不同的数据库厂商都有自己的实现类，后来统一规范也就有了数据库驱动，Java在操作数据库的时候，底层使用的其实是<code>JDBC</code>，而<code>JDBC</code>是一组操作不同数据库的规范。我们的Java应用程序，只需要调用<code>JDBC</code>提供的<code>API</code>就可以访问数据库了，而JPA也是类似的道理。</p><pre><code>     JPA全称是`Java Persistence API`（Java持久层API），它是Sun公司在JavaEE 5中提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：`Hibernate`。</code></pre><p>​        需要注意的是JPA统一了Java应用程序访问ORM框架的规范。</p><p>​        JPA为我们提供了以下规范：</p><p>​            1. ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。</p><p>​            2. JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发人员不用再写SQL了。</p><p>​            3. JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密藕合。</p><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><p>​        Hibernate是Java中的对象关系映射解决方案。对象关系映射或ORM框架是将应用程序数据模型对象映射到关系数据库表的技术。Hibernate 不仅关注于从 Java 类到数据库表的映射，也有 Java 数据类型到 SQL 数据类型的映射。</p><h4 id="Hibernate-和-JPA是什么关系呢？"><a href="#Hibernate-和-JPA是什么关系呢？" class="headerlink" title="Hibernate 和 JPA是什么关系呢？"></a><strong>Hibernate 和 JPA是什么关系呢？</strong></h4><p>​        上面我们介绍到JPA是Java EE 5规范中提出的Java持久化接口，而Hibernate是一个ORM框架。</p><h4 id="JPA和Hibernate的关系："><a href="#JPA和Hibernate的关系：" class="headerlink" title="JPA和Hibernate的关系："></a><strong>JPA和Hibernate的关系：</strong></h4><p>​        • JPA是一个规范，<strong>而不是框架</strong></p><p>​        • Hibernate是JPA的一种实现，<strong>是一个框架</strong></p><h3 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><h4 id="Spring-Data是什么？"><a href="#Spring-Data是什么？" class="headerlink" title="Spring Data是什么？"></a><strong>Spring Data是什么？</strong></h4><p>​        Spring Data是Spring 社区的一个子项目，主要用于简化数据（关系型&amp;非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。</p><p>​        • 它提供很多模板操作</p><p>​                – Spring Data Elasticsearch</p><p>​                – Spring Data MongoDB</p><p>​                – Spring Data Redis</p><p>​                – Spring Data Solr</p><p>​        • 强大的 Repository 和定制的数据储存对象的抽象映射</p><p>​        • 对数据访问对象的支持</p><p>​        <code>Spring Data JPA</code>是在实现了JPA规范的基础上封装的一套 JPA 应用框架，虽然ORM框架都实现了JPA规范，但是在不同的ORM框架之间切换仍然需要编写不同的代码，而使用<code>Spring Data JPA</code>能够方便大家在不同的ORM框架之间进行切换而不需要更改代码。<code>Spring Data JPA</code>旨在通过将统一ORM框架的访问持久层的操作，来提高开发的效率。</p><h4 id="Spring-Data-JPA和Hibernate的关系"><a href="#Spring-Data-JPA和Hibernate的关系" class="headerlink" title="Spring Data JPA和Hibernate的关系"></a>Spring Data JPA和Hibernate的关系</h4><p>​        <code>Hibernate</code>其实是JPA的一种实现，而<code>Spring Data JPA</code>是一个JPA数据访问抽象。<strong>也就是说Spring Data JPA不是一个实现或JPA提供的程序，它只是一个抽象层，主要用于减少为各种持久层存储实现数据访问层所需的样板代码量。但是它还是需要JPA提供实现程序，其实Spring Data JPA底层就是使用的 Hibernate实现。</strong></p><p><em><strong>总结就是：</strong></em></p><p><em><strong>• Hibernate是 JPA的一种实现，是一个框架</strong></em></p><p><em><strong>• Spring Data JPA是一种 JPA的抽象层，底层依赖 Hibernate</strong></em></p><p><img src="http://img.hznu.asia/202008270940571879.png" alt="http://img.hznu.asia/202008270940571879.png"></p><h2 id="二-ORM思想简介"><a href="#二-ORM思想简介" class="headerlink" title="二. ORM思想简介"></a>二. ORM思想简介</h2><p>​        前文提到， Spring Data JPA 底层是Hibernate ，而Hibernate 又是基于ORM思想的框架，因此，这里有必要对ORM做一个简单的介绍，以便理解后文。</p><p><strong>在探究什么是<code>ORM</code>之前，首先需要搞清楚几个概念：持久化和持久层。</strong></p><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>​        即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、<code>XML</code>中等等。</p><p>​        <code>Hibernate ORM</code>关心的是帮助应用程序实现持久性。持久性仅仅意味着我们希望应用程序的数据比应用程序进程的寿命更长。用<code>Java</code>术语来说，我们希望一些对象的状态超出<code>JVM</code>所能管控的范围，以便稍后可以使用相同的状态。</p><h4 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h4><p>​        即专注于实现数据持久化应用领域的某个特定系统的一个<strong>逻辑层面</strong>，将数据使用者和数据实体相关联。</p><h4 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h4><p>​        <code>ORM</code>即对象-关系映射（Object Relational Mapping），指的是在单个组件中负责所有实体域对象的持久化，封装数据库访问细节。它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的<code>SQL</code>语句打交道，只要像平时操作对象一样操作它就可以了 。</p><p>​        它是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。</p><p>​        <strong>采用 <code>ORM</code>框架后，应用程序不再直接访问底层数据库，而是以面向对象的方式来操作持久化对象，而<code>ORM</code>则将这些面向对象的操作转换成底层的 SQL 操作。</strong></p><p><img src="http://img.hznu.asia/A6970EEE-7490-4300-B50C-D3E368AFFAD5.png"></p><h4 id="常用的ORM中间件"><a href="#常用的ORM中间件" class="headerlink" title="常用的ORM中间件"></a>常用的ORM中间件</h4><p>​        开发<code>ORM</code>中间件需要十分专业的知识，因此一般在企业应用开发过程中都使用第三方提供的<code>ORM</code>中间件。下面列出了一些常用的<code>ORM</code>软件可供参考使用：</p><table><thead><tr><th align="center">ORM软件</th><th align="center">URL</th></tr></thead><tbody><tr><td align="center">Hibernate</td><td align="center"><a href="http://www.hibernate.org/">http://www.hibernate.org/</a></td></tr><tr><td align="center">Mybatis</td><td align="center"><a href="http://www.mybatis.org/">http://www.mybatis.org/</a></td></tr><tr><td align="center">Torque</td><td align="center"><a href="http://db.apache.org/torque/">http://db.apache.org/torque/</a></td></tr><tr><td align="center">JRelationalFramework</td><td align="center"><a href="http://jrf.sourceforge.net/">http://jrf.sourceforge.net</a></td></tr></tbody></table><p>​        <strong>不管是哪类<code>ORM</code>产品，首先需要保证的就是不能渗透到应用中，应用的上层组件应该和<code>ORM</code>中间件保持独立。</strong></p><p>​        有些<code>ORM</code>中间件要求在实体域对象中引入它们的类和接口，这会影响实体域对象的可移植性，如果日后想改用其他的<code>ORM</code>中间件，必须改写实体域对象的程序代码。另外,即使<code>ORM</code>中间件没有渗透到实体域对象中,应用程序中负责处理业务逻辑的过程域对象必须通过ORM中间件的API去访问数据库。每个<code>ORM</code>软件都有各自的<code>API</code>，如果一个应用程序起初使用了<code> Hibernate</code>,日后如果要改为使用<code>MyBatis</code>,就必须重新编写访问 <code>ORM</code> 中间件的代码。</p><p>​        为了削弱应用程序对特定<code>ORM</code>中间件的依赖性,<code>Oracle</code> 公司制定了统一的Java对象持久化 <code>API</code>(<code>Java Persistence API</code>,<code>JPA</code>)。<code>JPA</code>成为了各种<code> ORM</code>框架的标准<code>API</code>。<code>JPA</code>充分吸收了现有的包括<code>Hibernate</code>在内的<code>ORM</code>软件的优点,具有易于使用和伸缩性强的优势。应用程序可通过<code>JPA</code>来对实体域对象进行持久化。</p><h2 id="三-半自动ORM与全自动ORM框架"><a href="#三-半自动ORM与全自动ORM框架" class="headerlink" title="三. 半自动ORM与全自动ORM框架"></a>三. 半自动ORM与全自动ORM框架</h2><p>​        目前主流的持久层开发框架都是基于ORM思想的，但是ORM框架也有全自动化和半自动化之分。笔者认为，两者没有优劣之分，两者都有其适用的使用场景，对这两者都有一个较为深刻的理解也是很有必要的。</p><p>​        目前，主流的全自动ORM框架为Hibernate ，半自动ORM框架为Mybatis，那么，全自动和半自动的区别是什么呢？</p><h4 id="为什么说-Mybatis是半自动-ORM框架，而-Hibenate是全自动-ORM框架？"><a href="#为什么说-Mybatis是半自动-ORM框架，而-Hibenate是全自动-ORM框架？" class="headerlink" title="为什么说 Mybatis是半自动 ORM框架，而 Hibenate是全自动 ORM框架？"></a>为什么说 <code>Mybatis</code>是半自动 ORM框架，而 <code>Hibenate</code>是全自动 ORM框架？</h4><p>​        我们先来看看在持久层框架出现以前我们是如何对数据库进行操作的？</p><p>​        毋庸置疑，我们都使用 JDBC(Java Database Connectivity) 对数据库进行操作。操作步骤如下：</p><p>​        1. 加载驱动程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(driverClass)</span><br><span class="line">//加载MySql驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</span><br></pre></td></tr></table></figure><p>​        2. 获取数据库连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/imooc&quot;, &quot;root&quot;, &quot;root&quot;);</span><br></pre></td></tr></table></figure><pre><code>      3.  创建 `Statement` / `PerparedStatement` 对象</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn.createStatement();</span><br><span class="line">conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure><p>​    4. 操作数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.executeQuery(&quot;...&quot;);</span><br></pre></td></tr></table></figure><ol start="5"><li>关闭连接</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h5 id="Mybatis的实现机制"><a href="#Mybatis的实现机制" class="headerlink" title="Mybatis的实现机制"></a>Mybatis的实现机制</h5><p>1、读取 Mybatis的全局配置文件 mybatis-config.xml</p><p>2、创建 SqlSessionFactory会话工厂</p><p>3、创建 SqlSession会话</p><p>4、执行查询操作</p><p>mybatis-config.xml文件中包括一系列配置信息，其中包括标签 <mapper>，此标签配置了映射节点，映射节点内部定义了SQL语句。</mapper></p><p><strong>Mybatis将 SQL的定义工作独立出来，让用户自定义，而 SQL的解析，执行等工作交由 Mybatis处理执行。</strong></p><h5 id="Hibenate-的实现机制"><a href="#Hibenate-的实现机制" class="headerlink" title="Hibenate 的实现机制"></a>Hibenate 的实现机制</h5><p>1、构建 Configuration实例，初始化该实例中的变量</p><p>2、加载 hibenate.cfg.xml 文件到内存</p><p>3、通过 hibenate.cfg.xml 文件中的 mapping 节点配置并加载 xxx.hbm.xml 文件至内存</p><p>4、利用 Configuration实例构建 SessionFactory 实例</p><p>5、由SessionFactory 实例构建 session实例</p><p>6、由 session实例创建事务操作接口 Transaction 实例</p><p>7、执行查询操作</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><strong>传统的 JDBC是手工的，需要程序员加载驱动、建立连接、创建 Statement 对象、定义SQL语句、处理返回结果、关闭连接等操作。</strong></p><p><strong>Hibernate 是自动化的，内部封装了JDBC，并且还将 SQL 语句封装了，理念是即使开发人员不懂SQL语言也可以进行开发工作，向应用程序提供调用接口，直接调用即可。</strong></p><p><strong>Mybatis 是半自动化的，是介于 JDBC和 Hibernate之间的持久层框架，也是对 JDBC 进行了封装，不过将SQL的定义工作独立了出来交给用户实现，负责完成剩下的SQL解析，处理等工作。</strong></p><h2 id="四-Spring-Data-JPA-的前世今生"><a href="#四-Spring-Data-JPA-的前世今生" class="headerlink" title="四. Spring Data JPA 的前世今生"></a>四. Spring Data JPA 的前世今生</h2><p>由于如今EJB很少使用，许多人对此完全没有概念，因此在了解Spring Data JPA发展史之前，有必要对EJB做一个稍微详细一点的介绍，从而能对为什么如今更流行Hibernate和Spring Data JPA有一个更为清晰的认识。</p><h4 id="EJB-的演变史"><a href="#EJB-的演变史" class="headerlink" title="EJB 的演变史"></a>EJB 的演变史</h4><p>​        EJB (Enterprise Java Beans) 是基于分布式事务处理的企业级应用程序的组件。Sun公司发布的文档中对EJB的定义是：<strong>EJB是用于开发和部署多层结构的、分布式的、面向对象的Java应用系统的跨平台的构件体系结构</strong>。</p><p>​        由于 IBM 和 Sun Microsystems 等EJB提倡者力推其前景，起初一些大公司纷纷采用EJB部署他们的系统。然而随后各种问题便接踵而至，对 EJB 的恶评短时间内激增。</p><p>​        在实际运用中被发现，如果使用EJB来封装业务逻辑会带来性能上的下降。这是因为，<strong>最早的EJB规范只允许客户端通过特定协议</strong>（如<code>CORBA</code>进行远程方法调用）<strong>来调用</strong>，即使大部分实际应用根本就不需要分布式计算。直到EJB 2.0才引入了本地接口，以支持可以开发不通过网络就能直接本地调用的EJB系统。</p><p>​        尽管如此，EJB的广泛普及仍然为其复杂度所制约。尽管已经有一些高质量的集成开发工具可以协助开发人员通过自动编码解决一部分重复作业，但这并不能降低学习此项技术的难度。另一方面，“草根阶层”的编程爱好者们发起了一场旨在使用 “轻量级”技术以代替复杂的EJB的运动。这些技术包括<code>Hibernate</code>（用于提供数据持久化和对象-关系映射）及<code>Spring</code>框架（用于封装业务逻辑）。</p><p>​        EJB规范起初的一个主要价值—对分布式应用进行事务管理—在随后的实践中被一致认为几乎没能派上用场。对于企业级应用来说，Spring和Hibernate等简化框架更加实用。因此，EJB 3.0规范（JSR 220）为了迎合这个趋势相比于其之前的版本进行了一次激进的大跳跃。</p><p>​        <strong>受到Spring 影响，EJB 3.0也使用所谓的“传统简单Java对象POJO”；同时，支持依赖注入来简化全异系统的集成与配置。</strong></p><p>​        <strong>Hibernate的创始人Gavin King参与了这一新版规范的制订，并对EJB大加提倡。Hibernate的许多特性也被引入到Java持久化API当中，从而取代原来的实体bean。EJB 3.0规范大幅采用Java注解（annotation）来对代码进行元数据修饰，从而消减了此前EJB编程的冗杂性。</strong></p><p>​        <strong>相应地，EJB 3.0几乎成为了一个全新的API，与此前的数版可谓毫无相似度可言</strong>。    </p><p>​        在技术不断演变过程中，出现过众多璀璨的“新星”，而每一个产品的诞生也都和时代的需要有关。其实，在Hibernate和EJB演变的过程中，两者之间也有众多联系。</p><h4 id="EJB-和-Hibernate-的爱恨情仇"><a href="#EJB-和-Hibernate-的爱恨情仇" class="headerlink" title="EJB 和 Hibernate 的爱恨情仇"></a>EJB 和 Hibernate 的爱恨情仇</h4><p>​        在Java世界，Hibernate是最引人关注的一个话题。从Gavin King加入EJB3.0，负责制订EJB3.0的持久层规范；到Gavin King非正式退出JDO，并且充满个人情绪的攻击JDO2.0规范；到《Hibernate in Action》的发行；再到Hibernate3 Alpha的发布；最后再到最近JBoss 3.0 PR的发布(使用Hibernate3实现Entity Bean)。可以说这其中的每一步都引起业界的关注。</p><p>​        自从Gavin King加入JBoss之后，Hibernate已经由一个民间的开源软件走上了兼容EJB EntityBean的道路。Gavin King在EJB3.0 EG中充当了一个非常重要的角色，只要对比一下EJB3.0的EntityBean和Hibernate3，真相就会大白，<strong>虽然API接口不同，但是 EntityBean的设计理念完全来自于Hibernate。</strong></p><p>​        虽然EJB3.0的EntityBean在相当程度上来源于Hibernate，但是毕竟是不同的API接口，因此Hibernate和EJB3.0 EntityBean究竟是怎样的一种关系，是很多人心中的疑问。</p><p>​        2004年10月8日JBoss发布的EJB3.0 PR揭开了答案。Gavin King对Hibernate3进行了简单的封装，将EJB 3.0 EntityBean API调用转换为内部Hibernate3自己的API，从而实现EJB3.0 EntityBean的兼容。</p><p>​        EJB3.0不承诺脱离容器调用，如果你想使用EJB3.0，则必须运行在某个EJB Vendor提供的容器内，例如你使用JBoss提供的容器，那么你调用的是EntityBean API，这些调用请求会被转换为Hibernate API的调用请求。<strong>这意味着Hibernate实际上提供了两套API：一套是Hibernate原生API；另一套是兼容EJB3.0 EntityBean API。</strong></p><p>​        对于那些需要分布式调用支持，需要EJB容器的开发人员来说，他们选择后一套API；对于不需要EJB容器的开发人员来说，他们选择前一套 API。这就是Hibernate既定的发展策略，也是奠定其如今地位地关键。</p><p>​        Spring Data JPA演变成如今的样子是一个漫长的过程。在了解完什么是EJB以及其与Hibernate的关联后，要完全了解Spring Data JPA的形成过程，还得从技术架构的演变谈起。</p><h4 id="技术架构的演变"><a href="#技术架构的演变" class="headerlink" title="技术架构的演变"></a>技术架构的演变</h4><p>第一种：Session Bean ⇿ Entity Bean ⇿ DB        (EJB架构)<br>                                         ↓</p><p>第二种：Session Bean ⇿ DAO ⇿  JDBC ⇿ DB   （JDBC架构）<br>                                         ↓</p><p>第三种：Session Bean ⇿ DAO ⇿ Hibernate ⇿ DB   （Hibernate 架构）</p><p>首先我们对上面3个架构来简单分析下：<br><strong>1、内存消耗：</strong></p><p>​        采用JDBC的第二种架构是最省内存的，Hibernate的第三种架构次之，EJB的第一种架构最差。 </p><p><strong>2、运行效率：</strong></p><p>​        如果JDBC的代码写的非常优化，那么JDBC架构运行效率最高，但是实际项目中，这一点几乎做不到，这需要程序员非常精通JDBC，运用Batch语句批量处理，调整PreapredStatement的Batch Size和Fetch Size等参数，以及在必要的情况下采用结果集cache等等，<strong>而一般情况下程序员是做不到这一点的。</strong></p><p>​        因此Hibernate架构表现出最快的运行效率。</p><p>​        EJB的架构效率会差的很远，EJB效率低的一大原因就是通过RMI调用，RMI是一种Java的远程调用方法调用技术，要通过TCP/IP，比本地函数调用的开销要慢很多，此外entity bean效率低的还有更主要的原因，就是由于entity bean的结构造成的。由于使用entity bean每查找一行数据要进行两次数据库操作（一次是找出主键，另一次是通过主键找出数据），因此使数据库访问的效率大打折扣。 </p><p><strong>3、开发效率：</strong></p><p>​        在有JBuilder（一款Java可视化开发工具）支持下以及简单的项目，EJB架构开发效率最高，JDBC次之，Hibernate最差。但是在大的项目，特别是持久层关系映射很复杂的情况下，Hibernate效率很高，JDBC次之，而EJB架构由于其使用复杂性等原因很可能会失败。</p><p>​        从上面的结构演变来看，变化都是集中在Session Bean至DB之间的，而中间无非是从 Entity Bean 到 JDBC 再到 Hibernate ，这几种都是集中在对数据库的操作上，当然EJB不仅仅只是数据库操作，但是EJB 在各个方面都不占优势。因此，我们再来<strong>对这三种涉及的数据库相关操作展开分析</strong>，来对技术为什么会演变成如今的样子一探究竟。</p><p>​        (1) JDBC：多数Java开发人员是用JDBC来和数据库进行通信，它可以通过DAO模式进行改善和提高。但这种方式在大型应用程序中不容易操作使用，且维护起来相当困难。 </p><p>​        (2) EJB： EJB通常是在数据持久技术上的第二个选择，它是通过Entity Beans来对数据进行持久化。首先就需要购买一个价位合理的EJB容器一J2EE应用服务器，也可以采用开源项目的免费EJB容器，比如JBOSS。但是很多商业EJB容器的性能和技术支持不太好，在EJB中实现JDBC也比较复杂。 </p><p>​        (3)  Hibernate： Hibernate这种持久框架在某些方面有很大的不同，它不需要任何容器，提供简单易用的API。作为一个良好的ORM ，它有如下特点： </p><p>​                1. 透明地提供对象与关系数据库的映射，以统一的接口方式支持多种数据源，可以方便地进行切换。 </p><p>​                2. 缓存机制，缓存机制和锁定策略使针对数据库操作大大减少，提高系统运行效率地同时降低了对数据库的直接冲击。 </p><p>​                3. 开源免费的License，开源免费的特性使得使用人员可以自主研究源代码，并能够对系统提出建议或直接对源代码加以改进。 </p><p>​                4. 轻量级封装，避免引入过多复杂的问题，方便调试，减轻程序员的负担。 </p><p>​                5. 具有可移植性，基于JPA规范开发，使其无需手写SQL便可实现众多数据库相关操作并具有可移植性。 </p><p>​                ……</p><p>​        从上面可以看出，Hibernate相较于EJB和JDBC的结构来说，拥有众多优势，这也是如今Hibernate相较于其他两种架构更流行的原因。</p><h4 id="Hibernate-兼容-JPA"><a href="#Hibernate-兼容-JPA" class="headerlink" title="Hibernate 兼容 JPA"></a>Hibernate 兼容 JPA</h4><p>​        JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。</p><p>​        前面提到，JPA是Java EE 5规范中提出的Java持久化接口，而Hibernate是一个ORM框架，Hibernate是 JPA的一种实现。JPA是需要框架来实现其功能的，Hibernate就是JPA实现框架中很强的一个，应该说是目前最主流的一个框架。从功能上来说，JPA就是Hibernate功能的一个子集。</p><p>​        Hibernate 从3.2开始，就开始兼容JPA。Hibernate3.2获得了Sun TCK的JPA(Java Persistence API) 兼容认证。只要熟悉Hibernate或者其他ORM框架，在使用JPA时会发现其实非常容易上手。</p><h4 id="Spring-Data-JPA问世"><a href="#Spring-Data-JPA问世" class="headerlink" title="Spring Data JPA问世"></a>Spring Data JPA问世</h4><p>​        Hibernate 在 3.2 的时候提供了 JPA 的实现，其余的 JPA 的供应商还有诸如 OpenJPA、 Toplink等；Spring 在做持久化这一块的工作，开发了 Spring-data-xxx 这一系列包，如： Spring-data-jpa， Spring-data-redis， Spring-data-mongodb 等等，这些都是 Spring 提供的基于 JPA 和其他一些 NOSQL 的 Repository。</p><p>​        <strong>Spring Data JPA 是在 JPA 规范的基础下提供了 Repository 层的实现，但是使用哪一款 ORM 需要你自己去决定；相比我们更为熟悉的 Hibernate 和 MyBatis， Spring Data JPA 可以看做更高层次的抽象。</strong></p><h4 id="再看什么是Spring-Data-JPA"><a href="#再看什么是Spring-Data-JPA" class="headerlink" title="再看什么是Spring Data JPA"></a>再看什么是Spring Data JPA</h4><p><strong>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展。Spring Data JPA让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现。</strong></p><h2 id="五-Spring-Data-JPA的简单使用"><a href="#五-Spring-Data-JPA的简单使用" class="headerlink" title="五. Spring Data JPA的简单使用"></a>五. Spring Data JPA的简单使用</h2><h3 id="Spring-Data-JPA基本概念介绍"><a href="#Spring-Data-JPA基本概念介绍" class="headerlink" title="Spring Data JPA基本概念介绍"></a>Spring Data JPA基本概念介绍</h3><h4 id="实体类和数据库表的映射配置"><a href="#实体类和数据库表的映射配置" class="headerlink" title="实体类和数据库表的映射配置"></a>实体类和数据库表的映射配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">** 所有的注解都是使用JPA的规范提供的注解，</span><br><span class="line"> ** 所以在导入注解包的时候，一定要导入javax.persistence下的</span><br><span class="line"> */</span><br><span class="line">@Entity //声明实体类</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@Table(name=&quot;cst_customer&quot;) //建立实体类和表的映射关系</span><br><span class="line">public class Customer &#123;</span><br><span class="line"></span><br><span class="line">@Id//声明当前私有属性为主键</span><br><span class="line">@GeneratedValue(strategy=GenerationType.IDENTITY) //配置主键的生成策略</span><br><span class="line">@Column(name=&quot;cust_id&quot;) //指定和表中cust_id字段的映射关系</span><br><span class="line">private Long custId;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_name&quot;) //指定和表中cust_name字段的映射关系</span><br><span class="line">private String custName;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_source&quot;)//指定和表中cust_source字段的映射关系</span><br><span class="line">private String custSource;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_industry&quot;)//指定和表中cust_industry字段的映射关系</span><br><span class="line">private String custIndustry;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_level&quot;)//指定和表中cust_level字段的映射关系</span><br><span class="line">private String custLevel;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_address&quot;)//指定和表中cust_address字段的映射关系</span><br><span class="line">private String custAddress;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_phone&quot;)//指定和表中cust_phone字段的映射关系</span><br><span class="line">private String custPhone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用注解说明"><a href="#常用注解说明" class="headerlink" title="常用注解说明"></a>常用注解说明</h4><blockquote><p>@Entity</p><p>​      作用：指定当前类是实体类。</p><p>@Table</p><p>​    作用：指定实体类和表之间的对应关系。</p><p>​    属性：name：指定数据库表的名称</p><p>@Id</p><p>​    作用：指定当前字段是主键。</p><p>@GeneratedValue</p><p>​    作用：指定主键的生成方式。。</p><p>​    属性：strategy ：指定主键生成策略。</p><p>@Column</p><p>​     作用：指定实体类属性和数据库表之间的对应关系</p><p>​     属性：</p><p>​        name：指定数据库表的列名称。</p><p>​        unique：是否唯一 </p><p>​        nullable：是否可以为空 </p><p>​        inserttable：是否可以插入 </p><p>​        updateable：是否可以更新 </p><p>​        columnDefinition: 定义建表时创建此列的DDL </p><p>​        secondaryTable: 从表名。如果此列不建在主表上（默认建在主表），该属性定义该列所在从表的名字搭建开发环境（主键所在的表是主表。 外键所在的表是从表）</p></blockquote><h5 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h5><p>通过annotation（注解）来映射hibernate实体的,基于annotation的hibernate主键标识为@Id, 其生成规则由@GeneratedValue设定的.这里的@id和@GeneratedValue都是JPA的标准用法。</p><p>JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO。</p><p>具体说明如下：</p><p>**IDENTITY: **主键由数据库自动生成（主要是自动增长型）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Id  </span><br><span class="line">@GeneratedValue(strategy = GenerationType.IDENTITY) </span><br><span class="line">private Long custId;</span><br></pre></td></tr></table></figure><p>​    </p><p><strong>SEQUENCE</strong>：根据底层数据库的序列来生成主键，条件是数据库支持序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Id  </span><br><span class="line">@GeneratedValue(strategy = GenerationType.SEQUENCE,generator=&quot;payablemoney_seq&quot;)  </span><br><span class="line">@SequenceGenerator(name=&quot;payablemoney_seq&quot;, sequenceName=&quot;seq_payment&quot;)  </span><br><span class="line">private Long custId;</span><br><span class="line"></span><br><span class="line">//@SequenceGenerator源码中的定义</span><br><span class="line">@Target(&#123;TYPE, METHOD, FIELD&#125;)   </span><br><span class="line">@Retention(RUNTIME)  </span><br><span class="line">public @interface SequenceGenerator &#123;  </span><br><span class="line">    //表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中</span><br><span class="line">    String name();  </span><br><span class="line">    //属性表示生成策略用到的数据库序列名称。</span><br><span class="line">    String sequenceName() default &quot;&quot;;  </span><br><span class="line">    //表示主键初识值，默认为0</span><br><span class="line">    int initialValue() default 0;  </span><br><span class="line">    //表示每次主键值增加的大小，例如设置1，则表示每次插入新记录后自动加1，默认为50</span><br><span class="line">    int allocationSize() default 50;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AUTO</strong>：主键由程序控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Id  </span><br><span class="line">@GeneratedValue(strategy = GenerationType.AUTO)  </span><br><span class="line">private Long custId;</span><br></pre></td></tr></table></figure><p><strong>TABLE</strong>：使用一个特定的数据库表格来保存主键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Id  </span><br><span class="line">@GeneratedValue(strategy = GenerationType.TABLE, generator=&quot;payablemoney_gen&quot;)  </span><br><span class="line">@TableGenerator(name = &quot;pk_gen&quot;,  table=&quot;tb_generator&quot;,  pkColumnName=&quot;gen_name&quot;,  </span><br><span class="line">valueColumnName=&quot;gen_value&quot;,  pkColumnValue=&quot;PAYABLEMOENY_PK&quot;,  allocationSize=1  ) </span><br><span class="line">private Long custId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//@TableGenerator的定义：</span><br><span class="line">@Target(&#123;TYPE, METHOD, FIELD&#125;)    </span><br><span class="line">@Retention(RUNTIME)  </span><br><span class="line">public @interface TableGenerator &#123;  </span><br><span class="line">    //表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中</span><br><span class="line">    String name();  </span><br><span class="line">    //表示表生成策略所持久化的表名，例如，这里表使用的是数据库中的“tb_generator”。</span><br><span class="line">    String table() default &quot;&quot;;  </span><br><span class="line">    //catalog和schema具体指定表所在的目录名或是数据库名</span><br><span class="line">    String catalog() default &quot;&quot;;  </span><br><span class="line">    String schema() default &quot;&quot;;  </span><br><span class="line">    //属性的值表示在持久化表中，该主键生成策略所对应键值的名称。例如在“tb_generator”中将“gen_name”作为主键的键值</span><br><span class="line">    String pkColumnName() default &quot;&quot;;  </span><br><span class="line">    //属性的值表示在持久化表中，该主键当前所生成的值，它的值将会随着每次创建累加。例如，在“tb_generator”中将“gen_value”作为主键的值 </span><br><span class="line">    String valueColumnName() default &quot;&quot;;  </span><br><span class="line">    //属性的值表示在持久化表中，该生成策略所对应的主键。例如在“tb_generator”表中，将“gen_name”的值为“CUSTOMER_PK”。 </span><br><span class="line">    String pkColumnValue() default &quot;&quot;;  </span><br><span class="line">    //表示主键初识值，默认为0。 </span><br><span class="line">    int initialValue() default 0;  </span><br><span class="line">    //表示每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50。</span><br><span class="line">    int allocationSize() default 50;  </span><br><span class="line">    UniqueConstraint[] uniqueConstraints() default &#123;&#125;;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//这里应用表tb_generator，定义为 ：</span><br><span class="line">CREATE TABLE  tb_generator (  </span><br><span class="line">id NUMBER NOT NULL,  </span><br><span class="line">gen_name VARCHAR2(255) NOT NULL,  </span><br><span class="line">gen_value NUMBER NOT NULL,  </span><br><span class="line">PRIMARY KEY(id)  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="Spring-Data-JPA完整体验"><a href="#Spring-Data-JPA完整体验" class="headerlink" title="Spring Data JPA完整体验"></a>Spring Data JPA完整体验</h4><p>由于现在大多数时候，都会结合SpringBoot等框架来进行开发，因此本例采用和SpringBoot结合使用的场景来讲解。</p><p>首先在maven中引入依赖包（若使用gradle可自行在官网查询）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>​        先看一个简单的例子，实现增删查改的功能；从例子中我们可以发现，可以通过方法名称的定义，就可以达到 SQL 的效果:</p><p>比如 findByName(String name) 就相当于 select * from user where name = ?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface UserCrudRepository extends CrudRepository&lt;User, String&gt;&#123;    </span><br><span class="line">User findOne(String userid);    </span><br><span class="line">List&lt;User&gt; findByName(String name);    </span><br><span class="line">List&lt;User&gt; findByNameAndAgeLessThan(String name, int age);    </span><br><span class="line">void deleteByNameAndAgeLessThan(String name, int age);    </span><br><span class="line">List&lt;User&gt; findDistinctByName(String name);    </span><br><span class="line">List&lt;User&gt; findByNameIgnoreCase(String name);    </span><br><span class="line">User findFirstByOrderByUseridDesc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h4><p>Spring Date JPA提供了几个接口：</p><ul><li>Repository：最顶层的接口，是一个空的接口，目的是为了统一所有Repository的类型，且能让组件扫描的时候自动识别。</li><li>CrudRepository：是Repository的子接口，提供CRUD的功能。</li><li>PagingAndSortingRepository ：是CrudRepository的子接口，添加分页和排序的功能。</li><li>JpaRepository ：是PagingAndSortingRepository的子接口，增加了批量操作等功能。</li></ul><h4 id="完整体验"><a href="#完整体验" class="headerlink" title="完整体验"></a>完整体验</h4><h5 id="yml配置项"><a href="#yml配置项" class="headerlink" title="yml配置项"></a>yml配置项</h5><p>首先如本节开头所述，在maven中引入依赖，然后在application.yml中编写如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring：</span><br><span class="line">jpa:</span><br><span class="line">    show-sql: true </span><br><span class="line">    database: mysql</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update // 每次运行程序，没有表格会新建表格，表内有数据 不会清空，只会更新</span><br><span class="line">    open-in-view: false</span><br></pre></td></tr></table></figure><p>创建三个实体类：Intent（意图）、Question（问题）、Answer（答案），其中 Intent 和 Question 为一对多关系， Intent 和 Answer 也为一对多关系。</p><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;intent&quot;)</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line">public class Intent &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy= GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;id&quot;, length = 11)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;intentName&quot;, length = 500, nullable = false)</span><br><span class="line">    private String intentName;</span><br><span class="line"></span><br><span class="line">    @OneToMany(targetEntity = Question.class,fetch=FetchType.EAGER,cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JsonIgnoreProperties(value = &#123;&quot;intent&quot;&#125;)</span><br><span class="line">    private Set&lt;Question&gt; questionList = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @OneToMany(targetEntity = Answer.class,fetch=FetchType.EAGER,cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JsonIgnoreProperties(value = &#123;&quot;intent&quot;&#125;)</span><br><span class="line">    private Set&lt;Answer&gt; answerList = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;create_time&quot;, nullable = false)</span><br><span class="line">    @CreatedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;update_time&quot;, nullable = false)</span><br><span class="line">    @LastModifiedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;deleted&quot;, insertable = false, columnDefinition=&quot;int default 0&quot;)</span><br><span class="line">    private Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;answer&quot;)</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line">public class Answer implements Serializable &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy= GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;id&quot;, length = 11)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;answer&quot;, length = 1000, nullable = false)</span><br><span class="line">    private String answer;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JoinColumn(name = &quot;intent_id&quot;, referencedColumnName = &quot;id&quot;)</span><br><span class="line">    private Intent intent;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;create_time&quot;, nullable = false)</span><br><span class="line">    @CreatedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;update_time&quot;, nullable = false)</span><br><span class="line">    @LastModifiedDate</span><br><span class="line">    @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;deleted&quot;, length = 1, columnDefinition=&quot;tinyint default 0&quot;, insertable = false)</span><br><span class="line">    private Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;question&quot;)</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line">public class Question implements Serializable &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy= GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;id&quot;, length = 11)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;question&quot;, length = 500, nullable = false)</span><br><span class="line">    private String question;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JoinColumn(name = &quot;intent_id&quot;, referencedColumnName = &quot;id&quot;)</span><br><span class="line">    private Intent intent;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;create_time&quot;, nullable = false)</span><br><span class="line">    @CreatedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;update_time&quot;, nullable = false)</span><br><span class="line">    @LastModifiedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;deleted&quot;, length = 1, columnDefinition=&quot;tinyint default 0&quot;, insertable = false)</span><br><span class="line">    private Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在编写完实体类后，并在数据库创建名为“chat”的数据库后，启动项目，数据库将会按照实体类映射关系自动创建数据库表。</p><h5 id="持久层-1"><a href="#持久层-1" class="headerlink" title="持久层"></a>持久层</h5><p>编写持久层接口，并继承 JpaRepository 和 JpaSpecificationExecutor。如果只需要基本的一些操作，也可以只继承 JpaRepository ，视使用场景而定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IntentDao extends JpaRepository&lt;Intent, Integer&gt;, JpaSpecificationExecutor &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h5><p>在service中，利用 Spring 的依赖注入获取 <code>IntentDao</code>后，对其进行增、删、改、查操作。</p><h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface IntentService &#123;</span><br><span class="line">    Page&lt;Intent&gt; list(Integer page, Integer size);</span><br><span class="line"></span><br><span class="line">    Intent insert(Intent intent);</span><br><span class="line"></span><br><span class="line">    Intent update(Intent intent);</span><br><span class="line"></span><br><span class="line">    Intent delete(Intent intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class IntentServiceImpl implements IntentService &#123;</span><br><span class="line">    private IntentDao intentDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public IntentServiceImpl(IntentDao intentDao) &#123;</span><br><span class="line">        this.intentDao = intentDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Page&lt;Intent&gt; list(Integer page, Integer size) &#123;</span><br><span class="line">        Specification specification = new Specification&lt;Intent&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Predicate toPredicate(Root root, CriteriaQuery query, CriteriaBuilder criteriaBuilder) &#123;</span><br><span class="line">                return criteriaBuilder.notEqual(root.get(&quot;deleted&quot;).as(Integer.class), &quot;1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        return  intentDao.findAll(specification, PageRequest.of(page, size));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Intent insert(Intent intent) &#123;</span><br><span class="line">        return intentDao.save(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Intent update(Intent intent) &#123;</span><br><span class="line">        return intentDao.save(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Intent delete(Intent intent) &#123; // 注意：这里删除使用的是逻辑删除，若为物理删除，则使用 intentDao.delete(intent);</span><br><span class="line">        intent.setDeleted(1);</span><br><span class="line">        return intentDao.save(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/intent&quot;)</span><br><span class="line">public class IntentController &#123;</span><br><span class="line">    private IntentService intentService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public IntentController(IntentService intentService) &#123;</span><br><span class="line">        this.intentService = intentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;list&quot;)</span><br><span class="line">    public Response list(@RequestParam(&quot;page&quot;) Integer page,</span><br><span class="line">                             @RequestParam(&quot;size&quot;) Integer size) &#123;</span><br><span class="line">        return Response.success(intentService.list(page, size));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;create&quot;)</span><br><span class="line">    public Response create(@RequestBody Intent intent) &#123;</span><br><span class="line">        return Response.success(intentService.insert(intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;update&quot;)</span><br><span class="line">    public Response update(@RequestBody Intent intent) &#123;</span><br><span class="line">        return Response.success(intentService.update(intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;delete&quot;)</span><br><span class="line">    public Response delete(@RequestBody Intent intent) &#123;</span><br><span class="line">        return Response.success(intentService.delete(intent));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableJpaAuditing // 此注解作用是开启自动数据字段填充功能，比如 create_time 等字段在创建时直接插入系统当前时间</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ChatApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ChatApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是关于Spring Data JPA的完成示例</p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h2><p>从时间线来看：</p><ol><li> Hibernate 的团队开发了 Hibernate</li><li>制订 J2EE 规范的团队邀请 Hibernate 的核心团队在 Hibernate 基础上制订了 JPA （Java Persistent API）标准。<strong>从功能上看，JPA 是 Hibernate 的子集。</strong></li><li>Spring 的团队使用 Spring 对 JPA 做了封装，就是 Spring Data JPA 了。</li></ol><p>​        总之，JPA 是一个 API 标准，除了 Hibernate 外，还有其它厂商的实现，例如 Eclipse 的 TopLink。<strong>Spring Data Jpa 是个对 JPA 的封装，帮助程序员以 Spring 的方式来使用 JPA。</strong></p><h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><blockquote><p>【1】 <a href="https://copyfuture.com/blogs-details/20211020223216210c">https://copyfuture.com/blogs-details/20211020223216210c</a></p><p>【2】<a href="http://blog.itpub.net/10752043/viewspace-990145/">http://blog.itpub.net/10752043/viewspace-990145/</a> ”谈谈ejb的效率问题“</p><p>【3】<a href="https://www.cnblogs.com/liqun-12345/p/5588309.html">https://www.cnblogs.com/liqun-12345/p/5588309.html</a> ”Hibernate和JDBC、EJB比较“</p><p>【4】<a href="https://baike.baidu.com/item/EJB/144195?fr=aladdin">https://baike.baidu.com/item/EJB/144195?fr=aladdin</a> ”EJB“</p><p>【5】<a href="http://www.blogjava.net/zhangxv/archive/2006/03/02/33167.html">http://www.blogjava.net/zhangxv/archive/2006/03/02/33167.html</a> “Hibernate发展之路”</p><p>【6】<a href="https://juejin.cn/post/6844904014757265416">https://juejin.cn/post/6844904014757265416</a> “Spring Data JPA”</p><p>【7】<a href="https://www.zhihu.com/question/335584253/answer/753316281">https://www.zhihu.com/question/335584253/answer/753316281</a> </p><p>【8】<a href="https://blog.csdn.net/weixin_42653522/article/details/119492142">https://blog.csdn.net/weixin_42653522/article/details/119492142</a> ”半自动ORM与全自动ORM框架有什么区别？“</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/SpringDataJPA/">SpringDataJPA</category>
      
      
      <category domain="http://hznu.asia/tags/%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF/">对象持久化技术</category>
      
      
      <comments>http://hznu.asia/2022/04/23/SpringDataJPA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入理解ORM思想</title>
      <link>http://hznu.asia/2022/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ORM%E6%80%9D%E6%83%B3/</link>
      <guid>http://hznu.asia/2022/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ORM%E6%80%9D%E6%83%B3/</guid>
      <pubDate>Sat, 26 Mar 2022 06:34:02 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;ORM简介&quot;&gt;&lt;a href=&quot;#ORM简介&quot; class=&quot;headerlink&quot; title=&quot;ORM简介&quot;&gt;&lt;/a&gt;ORM简介&lt;/h3&gt;&lt;p&gt;​        &lt;code&gt;ORM&lt;/code&gt;即对象-关系映射（Object Relational Mappin</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="ORM简介"><a href="#ORM简介" class="headerlink" title="ORM简介"></a>ORM简介</h3><p>​        <code>ORM</code>即对象-关系映射（Object Relational Mapping），指的是在单个组件中负责所有实体域对象的持久化，封装数据库访问细节。它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的<code>SQL</code>语句打交道，只要像平时操作对象一样操作它就可以了 。</p><p>​        <strong>在探究什么是<code>ORM</code>之前，首先需要搞清楚几个概念：持久化和持久层。</strong></p><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>​        即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、<code>XML</code>中等等。</p><p>​        <code>Hibernate ORM</code>关心的是帮助应用程序实现持久性。持久性仅仅意味着我们希望应用程序的数据比应用程序进程的寿命更长。用<code>Java</code>术语来说，我们希望(一些)对象的状态超出<code>JVM</code>所能管控的范围，以便稍后可以使用相同的状态。</p><h4 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h4><p>​        即专注于实现数据持久化应用领域的某个特定系统的一个<strong>逻辑层面</strong>，将数据使用者和数据实体相关联。</p><h3 id="ORM是一种思想"><a href="#ORM是一种思想" class="headerlink" title="ORM是一种思想"></a>ORM是一种思想</h3><p>​        在了解完以上几个概念后，我们有必要深入了解一下到底什么才是<code>ORM</code>。正如标题所说，<code>ORM</code>我认为其实是一种面向对象编程演变过程中，形成的一种编程思想。</p><h4 id="究竟什么是面向对象"><a href="#究竟什么是面向对象" class="headerlink" title="究竟什么是面向对象"></a>究竟什么是面向对象</h4><p>​        一个优秀的软件架构，是要基于面向对象设计的深入理解与运用的，那么，究竟什么才是面向对象呢？很多人碰到这个问题，通常会甩出三个词——继承、封装、多态，我碰到许多人都会这么回答，当然这没有错，但总让我感觉这个回答有点生疏。另一种常见的回答则是“面向对象是一种对真实世界进行建模的方式”，似乎好像比上一种更容易理解一点，但是也只能算是避重就轻，“对真实世界的建模”到底要如何进行？我们为什么要这么做？这么做有什么好处？许多人问到这便会陷入困境，不知如何回答。</p><p>​        那让我们先详细了解一下生疏而又神秘的三个特性——继承、封装、多态。这十分有利于我们去理解<code>ORM</code>思想。</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>​        所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​        所谓继承，是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>​        就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><p>​        面向对象的三大特性，其中一个非常重要的用处就是使得程序可复用性极高，它使得我们的软件体系架构得到解耦。其实这些思想和操作系统也有着很大的关联，比如在<code>UNIX</code>操作系统中，IO设备是被设计成插件形式的，简单说就是：程序和设备无关。而这又可以引申出另一种编程模式：依赖反转。</p><h4 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h4><p>​        设想一下，假如有一个main函数，控制着A、B、C三个函数，而A、B、C分别控制着A1、A2、A3，B1、B2、B3，C1、C2、C3函数。这样，main函数要调用其他模块，就必须看到其他模块所在的模块，每个函数的调用方就必须引用被调用方所在的模块，<strong>这样就导致系统行为决定控制流，而控制流决定着源代码的依赖关系。</strong></p><p>​        再设想一下，有一个main函数、一个A接口、一个A接口的实现类，函数的调用是通过源代码级别的接口来实现的，此时的依赖关系方向和控制流是相反的，我们在称之为<code>依赖反转</code> 。</p><p>​        通过这种方法，软件工程师可以完全控制采用了面向对象编程方式中的所有源代码依赖关系，而不再收到系统控制流的限制。不管哪个模块调用或者被调用，软件工程师都可以随意更改源代码依赖关系。</p><h4 id="回到问题"><a href="#回到问题" class="headerlink" title="回到问题"></a>回到问题</h4><p>​        <strong>那么我们回到最开始的问题，究竟什么才是面向对象编程呢？其实在笔者看过的许多经典作品中，很多人对此都有不同的说法和意见，但是对于软件工程师而言：面向对象编程就是以多态的手段对源代码中的依赖关系加以控制和约束，让高层代码对低层代码达到解耦的目的，实现相对独立的编程开发工作，这也是目前主流的软件体系架构思想。</strong></p><p>​        了解以上内容后，我们回到主题：什么是<code>ORM</code>思想？它和面向对象有什么关系？为什么需要<code>ORM</code>？</p><p>​        在目前的企业应用系统设计中，<code>MVC</code>，即 Model（模型）- View（视图）- Control（控制）为主要的系统架构模式。<code>MVC</code> 中的 Model 包含了复杂的业务逻辑和数据逻辑，以及数据存取机制（如<code> JDBC</code>的连接、<code>SQL</code>生成和<code>Statement</code>创建、还有<code>ResultSet</code>结果集的读取等）等。</p><p>​        将这些复杂的业务逻辑和数据逻辑分离，以将系统的紧耦 合关系转化为松耦合关系（即解耦合），是降低系统耦合度迫切要做的，也是持久化要做的工作。</p><p><code>MVC</code> 模式实现了架构上将表现层（即View）和数据处理层（即Model）分离的解耦合，而持久化的设计则实现了数据处理层内部的业务逻辑和数据逻辑分离的解耦合。 而 <code>ORM </code>作为持久化设计中的最重要也最复杂的技术，也是目前业界热点技术。</p><p>​        简单来说，按通常的系统设计，使用<code> JDBC</code> 操作数据库，业务处理逻辑和数据存取逻辑是混杂在一起的。<br>​        一般基本都是如下几个步骤：<br>​            1、建立数据库连接，获得<code>Connection</code>对象。<br>​            2、根据用户的输入组装查询<code> SQL</code> 语句。<br>​            3、根据<code> SQL</code> 语句建立<code> Statement</code> 对象 或者<code>PreparedStatement</code>对象。<br>​            4、用<code>Connection</code>对象执行<code> SQL</code>语句，获得结果集<code> ResultSet</code> 对象。<br>​            5、然后一条一条读取结果集 <code>ResultSet</code> 对象中的数据。<br>​            6、根据读取到的数据，按特定的业务逻辑进行计算。<br>​            7、根据计算得到的结果再组装更新<code> SQL</code> 语句。<br>​            8、再使用 <code>Connection</code> 对象执行更新 <code>SQL</code> 语句，以更新数据库中的数据。<br>​            9、最后依次关闭各个<code>Statement</code>对象和 <code>Connection</code> 对象。</p><p>​        由上可看出代码逻辑非常复杂，这还不包括某条语句执行失败的处理逻辑。其中的业务处理逻辑和数据存取逻辑完全混杂在一块。</p><p>而一个完整的系统要包含成 千上万个这样重复的而又混杂的处理过程，假如要对其中某些业务逻辑或者一些相关联的业务流程做修改，要改动的代码量将不可想象。</p><p>​        另一方面，假如要换数据库产品或者运行环境也可能是个不可能完成的任务。而用户的运行环境和要求却千差万别，我们不可能为每一个用户每一种运行环境设计一套一样的系统。</p><p>​        所以就要将一样的处理代码即业务逻辑和可能不一样的处理即数据存取逻辑分离开来，另一方面，关系型数据库中的数据基本都是以一行行的数据进行存取的，而程序 运行却是一个个对象进行处理，而目前大部分数据库驱动技术（如<code>ADO.NET</code>、<code>JDBC</code>、<code>ODBC</code>等等）均是以行集的结果集一条条进行处理的。</p><p>​        所以为解决这一困难，就出现<code> ORM</code> 这一个对象和数据之间映射技术。</p><p>​        举例来说，比如要完成一个购物打折促销的程序，用 <code>ORM</code> 思想将如下实现：</p><p>​        业务逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Double calcAmount(String customerid, double amount) &#123;</span><br><span class="line">  // 根据客户ID获得客户记录</span><br><span class="line">  Customer customer = CustomerManager.getCustomer(custmerid); </span><br><span class="line">  // 根据客户等级获得打折规则</span><br><span class="line">  Promotion promotion = PromotionManager.getPromotion(customer.getLevel()); </span><br><span class="line">  // 累积客户总消费额，并保存累计结果</span><br><span class="line">  customer.setSumAmount(customer.getSumAmount().add(amount); </span><br><span class="line">  CustomerManager.save(customer); </span><br><span class="line">  // 返回打折后的金额</span><br><span class="line">  return amount.multiply(protomtion.getRatio()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这样代码就非常清晰了，而且与数据存取逻辑完全分离。设计业务逻辑代码的时候完全不需要考虑数据库<code>JDBC</code>的那些千篇一律的操作，而将它交给 <code>CustomerManager</code> 和 <code>PromotionManager</code> 两个类去完成。这就是一个简单的 <code>ORM</code> 设计，实际的 <code>ORM</code> 实现框架比这个要复杂的多。</p><h3 id="常用的ORM中间件"><a href="#常用的ORM中间件" class="headerlink" title="常用的ORM中间件"></a>常用的ORM中间件</h3><p>​        开发<code>ORM</code>中间件需要十分专业的知识，因此一般在企业应用开发过程中都使用第三方提供的<code>ORM</code>中间件。下面列出了一些常用的<code>ORM</code>软件可供参考使用：</p><table><thead><tr><th align="center">ORM软件</th><th align="center">URL</th></tr></thead><tbody><tr><td align="center">Hibernate</td><td align="center"><a href="http://www.hibernate.org/">http://www.hibernate.org/</a></td></tr><tr><td align="center">Mybatis</td><td align="center"><a href="http://www.mybatis.org/">http://www.mybatis.org/</a></td></tr><tr><td align="center">Torque</td><td align="center"><a href="http://db.apache.org/torque/">http://db.apache.org/torque/</a></td></tr><tr><td align="center">JRelationalFramework</td><td align="center"><a href="http://jrf.sourceforge.net/">http://jrf.sourceforge.net</a></td></tr></tbody></table><p>​        不管是哪类<code>ORM</code>产品，首先需要保证的就是不能渗透到应用中，应用的上层组件应该和<code>ORM</code>中间件保持独立。有些<code>ORM</code>中间件要求在实体域对象中引入它们的类和接口，这会影响实体域对象的可移植性，如果日后想改用其他的<code>ORM</code>中间件，必须改写实体域对象的程序代码。</p><p>​        另外,即使<code>ORM</code>中间件没有渗透到实体域对象中,应用程序中负责处理业务逻辑的过程域对象必须通过ORM中间件的API去访问数据库。</p><p>​        每个<code>ORM</code>软件都有各自的<code>API</code>，如果一个应用程序起初使用了<code> Hibernate</code>,日后如果要改为使用<code>MyBatis</code>,就必须重新编写访问 <code>ORM</code> 中间件的代码。为了削弱应用程序对特定<code>ORM</code>中间件的依赖性,<code>Oracle</code> 公司制定了统一的Java对象持久化 <code>API</code>(<code>Java Persistence API</code>,<code>JPA</code>)。<code>JPA</code>成为了各种<code> ORM</code>架的标准<code>API</code>。</p><p>​        <code>JPA</code>充分吸收了现有的包括<code>Hibernate</code>在内的<code>ORM</code>软件的优点,具有易于使用和伸缩性强的优势。应用程序可通过<code>JPA</code>来对实体域对象进行持久化。</p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/SpringDataJPA/">SpringDataJPA</category>
      
      
      
      <comments>http://hznu.asia/2022/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ORM%E6%80%9D%E6%83%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL如何选择合适的数据类型和索引</title>
      <link>http://hznu.asia/2022/03/06/MySQL%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <guid>http://hznu.asia/2022/03/06/MySQL%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Sun, 06 Mar 2022 08:36:28 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;选择合适的数据类型&quot;&gt;&lt;a href=&quot;#选择合适的数据类型&quot; class=&quot;headerlink&quot; title=&quot;选择合适的数据类型&quot;&gt;&lt;/a&gt;选择合适的数据类型&lt;/h2&gt;&lt;h4 id=&quot;时间类型选择&quot;&gt;&lt;a href=&quot;#时间类型选择&quot; class=&quot;head</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h2><h4 id="时间类型选择"><a href="#时间类型选择" class="headerlink" title="时间类型选择"></a>时间类型选择</h4><table><thead><tr><th align="center">日期和时间类型</th><th align="center">字节</th><th align="center">最小值</th><th align="center">最大值</th></tr></thead><tbody><tr><td align="center">DATE</td><td align="center">4</td><td align="center">1000-01-01</td><td align="center">9999-12-31</td></tr><tr><td align="center">DATETIME</td><td align="center">8</td><td align="center">1000-01-01 00:00:00</td><td align="center">9999-12-31 23:59:59</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">4</td><td align="center">19700101080001</td><td align="center">2038年某个时刻</td></tr><tr><td align="center">TIME</td><td align="center">3</td><td align="center">-838：59：59</td><td align="center">838：59：59</td></tr><tr><td align="center">YEAR</td><td align="center">1</td><td align="center">1901</td><td align="center">2155</td></tr></tbody></table><p>其中，<code>TimeStamp</code>有一个重要的特点，就是和时区相关。当插入日期时，会先转换为本地时区后存储，后续需要取出时，也需要根据所在地时区进行转换显示。这样，不同时区的用户看到的同一个日期可能是不一样的。</p><h4 id="CHAR和VARCHAR"><a href="#CHAR和VARCHAR" class="headerlink" title="CHAR和VARCHAR"></a><code>CHAR</code>和<code>VARCHAR</code></h4><table><thead><tr><th align="center">值</th><th align="center">CHAR(4)</th><th align="center">存储需求</th><th align="center">VARCHAR(4)</th><th align="center">存储需求</th></tr></thead><tbody><tr><td align="center">“</td><td align="center">‘  ‘</td><td align="center">4个字节</td><td align="center">“</td><td align="center">1个字节</td></tr><tr><td align="center">‘ab’</td><td align="center">‘ab ‘</td><td align="center">4个字节</td><td align="center">‘ab ‘</td><td align="center">3个字节</td></tr><tr><td align="center">‘abcd’</td><td align="center">‘abcd’</td><td align="center">4个字节</td><td align="center">‘abcd’</td><td align="center">5个字节</td></tr><tr><td align="center">‘abcdefgh’</td><td align="center">‘abcd’</td><td align="center">4个字节</td><td align="center">‘abcd’</td><td align="center">5个字节</td></tr></tbody></table><blockquote><p>注：上图中最后一行只适用于<code>MySQL</code>的非严格模式，如果在严格模式，超过列长度的值将不会保存并出现错误提示。</p></blockquote><p><code>VARCHAR(4)</code>列显示的存储需求比实际字符长度多1，因为<code>VACHAR</code>要用1~2个字节要记录字节长度，低于255字节时使用一个，高于使用两个。（一个字节存储8位无符号数,储存的数值范围为0-255）</p><p>而不同的存储引擎对于两者的使用原则也有所不同：（个人认为造成使用原则不同的原因主要是两个存储方式不同，两种存储引擎都是基于<code>B+树</code>数据结构存储表数据的，但是区别在于<code>InnoDB</code>存储引擎中的<code>B+树</code>即存储了索引又存储了所有数据，而<code>MyISAM</code>中的<code>B+树</code>中只存储了数据的索引的Key值得地址，实际的数据存储在其他地方）</p><p><code>MyISAM</code>存储引擎：建议使用固定长度的数据列代替代替可变长度的数据列。</p><p><code>InnoDB</code>存储引擎：建议使用<code>VARCHAR</code>类型。对于<code>InnoDB</code>表，内部的行存储格式并没有区分固定长度和可变长度列（所有的数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的<code>CHAR</code>列不一定比使用可变长度的<code>VARCHAR</code>性能要好。因此，主要的性能因素都在行存储的数据量大小。由于<code>VARCHAR</code>的平均占用空间小于<code>CHAR</code>，因此使用<code>VARCHAR</code>来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。</p><h4 id="TEXT和BLOB"><a href="#TEXT和BLOB" class="headerlink" title="TEXT和BLOB"></a><code>TEXT</code>和<code>BLOB</code></h4><p><code>BLOB</code>主要用于保存一些二进制数据，比如照片；而<code>TEXT</code>只能保存字符数据。</p><p>但是这两种数据类型会引发一些性能问题，特别是执行过大量的删除操作后，会在数据表留下很大的数据“空洞”，以后填入这些空洞的记录在插入的性能上会有影响。可以通过执行<code>OPTIMIZE TABLE</code>对这类表进行碎片整理。</p><p>一般来说，不建议使用这两种数据类型，如果确实需要使用，建议将这两种数据类型分在不同的表中。这样会减少主表存储碎片，显著减少主表的数据量从而获得性能优势。</p><blockquote><p>优先使用<code>VARCHAR</code>类型，<code>VARCHAR</code>最长可以支持65533字节的长度，可以满足绝大多数需求。</p></blockquote><h4 id="浮点数和定点数"><a href="#浮点数和定点数" class="headerlink" title="浮点数和定点数"></a>浮点数和定点数</h4><p>当一个数据被定义为浮点数时，如果插入的数据精度超过该列定义的实际精度，则插入值会被四舍五入到实际精度。</p><p><strong>定点数实际上是以字符串形式存储的。</strong>所以定点数可以更精确地保存数据,因此在一些对数据精度要求比较高的场合（比如货币），一般使用定点数。</p><h2 id="索引设计和使用"><a href="#索引设计和使用" class="headerlink" title="索引设计和使用"></a>索引设计和使用</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>正确使用索引，是提高select操作性能的最佳途径。每种存储引擎对每个表至少支持16个索引，总索引的长度至少为256字节。</p><h3 id="索引在不同引擎中如何存储"><a href="#索引在不同引擎中如何存储" class="headerlink" title="索引在不同引擎中如何存储"></a>索引在不同引擎中如何存储</h3><p><code>InnoDB</code> 的表是根据主键进行展开的 B+tree 的聚集索引。<code>MyISAM </code>则为非聚集型索引，**<code>MyISAM</code> 存储会有两个文件，一个是索引文件，另外一个是数据文件，**其中索引文件中的索引指向数据文件中的表数据。</p><p>聚集型索引并不是一种单独的索引类型，而是一种存储方式，<code>InnoDB </code>聚集型索引实际上是在同一结构中保存了 B+tree 索引和数据行。当有聚簇索引时，<strong>它的索引实际放在叶子页中。</strong></p><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p>最适合索引的列是出现在<code>where</code>子句中的列，或连接子句中指定的列，而不是出现在select关键字后的选择列表中的列。</p><p>索引列的基数越大，索引的效果越好。比如出生日期具有不同值，很容易区分各行；而对于性别就两种值，不管搜索哪个值，都会得到一半的结果。</p><p>使用短索引。假如有一个CHAR(200)，如果前10或20个字符内，多数值都是唯一的，那么索引就只对前面具有唯一值的使用，能够节省大量索引空间。</p><p>利用最左前缀。见下一小节。</p><p>对于<code>InnoDB</code>的引擎，尽量手工指定主键。记录默认会按照一定的顺序保存，若有明确定义的主键，则按照主键顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个顺序去保存。按照主键或内部列进行访问是最快的，所以<code>InnoDB</code>表尽量指定主键。</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>在<code>MySQL</code>建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>要想理解联合索引的最左匹配原则，先来理解下索引的底层原理。索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p><p>举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子：</p><p><img src="https://img.hznu.asia/blog/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E7%B4%A2%E5%BC%95%E7%A4%BA%E4%BE%8B%E5%9B%BE.png"></p><p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为<code>MySQL</code>创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引。</p><h3 id="不可见索引"><a href="#不可见索引" class="headerlink" title="不可见索引"></a>不可见索引</h3><p><code>MySQL8.0</code>提供的不可见索引，是为了减小对于表上的索引进行调整时可能会带来的潜在风险。当删除一个你认为不再需要的索引时，一旦系统中还存在个别使用该索引的<code>SQL</code>，那么这些<code>SQL</code>的执行可能会转为全表扫描，严重的话可能直接击垮数据库。并且重建索引需要的时间和消耗的系统资源也会很大。</p><p>有了不可见索引，当需要删除一个表的冗余索引时，可能先将其设为不可见，一旦发现有负面影响，还可以快速恢复。</p><h2 id="参考引用："><a href="#参考引用：" class="headerlink" title="参考引用："></a>参考引用：</h2><blockquote><p>[1] 最左匹配原则：<a href="https://www.cnblogs.com/ljl150/p/12934071.html">https://www.cnblogs.com/ljl150/p/12934071.html</a></p><p>[2] 深入浅出MySQL：数据库开发、管理和维护（第三版）</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <category domain="http://hznu.asia/tags/MySQL/">MySQL</category>
      
      
      <comments>http://hznu.asia/2022/03/06/MySQL%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL存储引擎</title>
      <link>http://hznu.asia/2022/03/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <guid>http://hznu.asia/2022/03/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <pubDate>Thu, 03 Mar 2022 12:05:53 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;存储引擎概述&quot;&gt;&lt;a href=&quot;#存储引擎概述&quot; class=&quot;headerlink&quot; title=&quot;存储引擎概述&quot;&gt;&lt;/a&gt;存储引擎概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;MySQL5.7&lt;/code&gt;版本支持的存储引擎有&lt;code&gt;InnoDB&lt;/code&gt;、&lt;co</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="存储引擎概述"><a href="#存储引擎概述" class="headerlink" title="存储引擎概述"></a>存储引擎概述</h3><p><code>MySQL5.7</code>版本支持的存储引擎有<code>InnoDB</code>、<code>MyISAM</code>、<code>MEMORY</code>、<code>CSV</code>、<code>BLACKHOLE</code>、<code>ARCHIVE</code>、<code>MERGE</code>、<code>FEDERATED</code>、<code>EXAMPLE</code>、<code>NDB</code>等。其中<code>InnoDB</code>和<code>NBDB</code>提供事务安全表，其他都是非事务安全表。</p><p>由于常见的存储引擎为<code>InnoDB</code>和<code>MyISAM</code>，所以本篇博客只讨论这两种存储引擎。</p><p>其实在此之前，我一直认为存储引擎是基于整个数据库而言的，比如说一个数据库只能设定成一种存储引擎，其实不是的。<strong>存储引擎是基于表级别的。</strong></p><p>在创建新表的时候，可以使用关键字<code>ENGINE</code>来设置新建表的存储引擎，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table A(</span><br><span class="line">...</span><br><span class="line">)ENGINE=MyISAM</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table B(</span><br><span class="line">...</span><br><span class="line">)ENGINE=InnoDB</span><br></pre></td></tr></table></figure><blockquote><p><strong>修改表的存储引擎需要锁表并复制数据，对于线上环境的表进行这个操作非常危险，除非你非常了解可能造成的影响</strong>。</p></blockquote><h3 id="各类存储引擎的特性"><a href="#各类存储引擎的特性" class="headerlink" title="各类存储引擎的特性"></a>各类存储引擎的特性</h3><table><thead><tr><th align="center">特点</th><th align="center">MyISAM</th><th align="center">InnoDB</th></tr></thead><tbody><tr><td align="center">B树索引</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">备份/时间点恢复</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">支持集群</td><td align="center">——</td><td align="center">——</td></tr><tr><td align="center">聚簇索引</td><td align="center">——</td><td align="center">支持</td></tr><tr><td align="center">数据压缩</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">数据缓存</td><td align="center">——</td><td align="center">支持</td></tr><tr><td align="center">数据加密</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">支持外键</td><td align="center">——</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">地理坐标数据类型</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">地理坐标索引</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">哈希索引</td><td align="center">——</td><td align="center">——</td></tr><tr><td align="center">索引缓存</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">锁粒度</td><td align="center">表级</td><td align="center">行级</td></tr><tr><td align="center">MVCC多版本控制</td><td align="center">——</td><td align="center">支持</td></tr><tr><td align="center">支持复制</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">存储限制</td><td align="center">256TB</td><td align="center">64TB</td></tr><tr><td align="center">T树索引</td><td align="center">——</td><td align="center">——</td></tr><tr><td align="center">支持事务</td><td align="center">——</td><td align="center">支持</td></tr><tr><td align="center">统计信息</td><td align="center">支持</td><td align="center">支持</td></tr></tbody></table><blockquote><p>聚簇索引：<a href="https://juejin.cn/post/6844903972843552781">https://juejin.cn/post/6844903972843552781</a></p></blockquote><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p><code>MyISAM</code>在某些场景中相对<code>InnoDB</code>的访问速度有明显优势，对事务完整性没有要求或以<code>Select</code>、<code>Insert</code>为主的应用可以使用这个引擎来创建表。</p><p><code>MyISAM</code>的表支持三种不同的存储格式：静态表、动态表、压缩表。</p><h5 id="静态表："><a href="#静态表：" class="headerlink" title="静态表："></a>静态表：</h5><p>静态表是默认存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。</p><p>静态表的数据在存储时会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经丢掉。在保存数据的时候，如果某个要保存的内容前后后空格，那么在返回结果的时候会被去掉。</p><h5 id="动态表："><a href="#动态表：" class="headerlink" title="动态表："></a>动态表：</h5><p>动态表包含变长字段，记录不固定长度，这样存储的有点是占用空间相对较少，但是频繁地更新和删除记录会产生碎片，需要定期执行<code>OPTIMIZE TABLE</code>或<code>myisamchk-r</code>命令来改善性能，并且在出现故障时恢复相对比较困难。</p><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>该引擎具有提交、回滚和崩溃恢复能力地事务安全保障，同时提供了更小的锁粒度和更强地并发能力，拥有自己独立的缓存和日志，在<code>MySQL5.6</code>和<code>5.7</code>版本中性能有较大的提升。</p><p>相对<code>MyISAM</code>而言，<code>InnoDB</code>会占用更多的磁盘空间以保存数据和索引。但是在大多数情况下，<code>InnoDB</code>都是更好的选择。</p><h5 id="自动增长列"><a href="#自动增长列" class="headerlink" title="自动增长列"></a>自动增长列</h5><p><code>InnoDB</code>表的自动增长可以手工插入，但是如果插入的值为空，则实际插入的将是自动增长后的值。另外对于自动增长的值可以手动设置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter TABLE *** AUTO_INCREMENT=N</span><br></pre></td></tr></table></figure><p>在<code>MySQL8.0</code>之前，对于<code>InnoDB</code>引擎，这个值存在内存中，那么在数据库重启后，这个值便会丢失，数据库会自动将这个值重置为自增列当前存储最大值+1，可能会引起数据冲突。但是在<code>MySQL8.0</code>中这个Bug得到了修复，实现方式是将自增主键的计数器持久化到<code>REDO LOG</code>中，每次计数器发生改变，都会将其写入<code>REDO LOG</code>，重启后则会根据其中的信息来初始化其内存值。</p><p>对于<code>InnoDB</code>表，自动增长的列必须被索引。如果是组合索引，也必须是组合索引的第一列。但是对于<code>MyISAM</code>表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。</p><h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><p><code>MySQL</code>支持外键的只有<code>InnoDB</code>存储引擎，在创建外键时，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。</p><p>当某个表被其他表创建了外键参照，那么该表的对应索引或者主键禁止被删除。</p><blockquote><p>外键需要注意的细节较多，一旦使用不当，可能会带来性能下降或者数据不一致问题，需要慎用。</p></blockquote><h5 id="主键和索引"><a href="#主键和索引" class="headerlink" title="主键和索引"></a>主键和索引</h5><p>不同于其他存储引擎，<code>InnoDB</code>存储引擎的数据文件本身就是以聚簇索引的形式保存的，这个聚簇索引也被称为主索引，也是<code>InnoDB</code>的主键，<code>InnoDB</code>表的每行数据都保存在主索引的叶子节点上。因此，所有的<code>InnoDB</code>表都必须包含主键，若创建表的时候没有显示指定主键，那么<code>InnoDB</code>会自动创建一个长度为6个字节的<code>long</code>类型隐藏字段作为主键。</p><p>考虑到聚簇索引的特点和对于查询的优化效果，所有的<code>InnoDB</code>表都应该显示指定主键，一般来说，主键应该按照以下原则来选择：</p><ul><li>满足唯一和非空约束</li><li>优先考虑使用最经常被当作查询条件的字段或者自增字段</li><li>字段值基本不会被修改</li><li>使用尽可能短的字段</li></ul><p>在<code>InnoDB</code>表上，除了主键之外的其他索引都叫<code>二级索引</code>或<code>辅助索引</code>，二级索引会指向主索引，并通过主索引获取最终数据。因此，主键是否合理的创建，会对所有索引的效率产生影响。</p><h4 id="如何选择存储引擎"><a href="#如何选择存储引擎" class="headerlink" title="如何选择存储引擎"></a>如何选择存储引擎</h4><p><code>MyISAM</code>：如果应用是以读操作和插入操作为主，只有极少的更新和删除操作，并且对事务完整性没有要求、没有并发写操作，那么选择这个存储引擎是合适的。</p><p><code>InnoDB</code>: 对于大部分应用程序，都是更好的选择。它能有效地降低由于删除和更新导致的锁定，还可以保证事务完整提交和回滚。</p><h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><blockquote><p><code>MyISAM</code>读和插入更优的原因：</p><p><a href="https://blog.csdn.net/weixin_39631572/article/details/110861044">https://blog.csdn.net/weixin_39631572/article/details/110861044</a></p><p><a href="https://www.xttblog.com/?p=3859">https://www.xttblog.com/?p=3859</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <category domain="http://hznu.asia/tags/MySQL/">MySQL</category>
      
      
      <comments>http://hznu.asia/2022/03/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
