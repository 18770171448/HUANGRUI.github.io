<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>realhuang</title>
    <link>http://hznu.asia/</link>
    
    <atom:link href="http://hznu.asia/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>国家地板级演员 GitHub顶级粉丝</description>
    <pubDate>Tue, 19 Jul 2022 12:27:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>DDD初探--从DDD角度理解Spring Data JPA思想</title>
      <link>http://hznu.asia/2022/07/19/DDD%E5%88%9D%E6%8E%A2-%E4%BB%8EDDD%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Spring-Data-JPA%E6%80%9D%E6%83%B3/</link>
      <guid>http://hznu.asia/2022/07/19/DDD%E5%88%9D%E6%8E%A2-%E4%BB%8EDDD%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Spring-Data-JPA%E6%80%9D%E6%83%B3/</guid>
      <pubDate>Tue, 19 Jul 2022 07:46:30 GMT</pubDate>
      
        
        
      <description>&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</description>
        
      
      
      
      <content:encoded><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spring Data JPA 是一个非常常见的持久层框架，它和我们如今十分流程的DDD（Domain-Driven Design，即领域驱动设计）有着许多相同的思想。DDD是一种根据领域专家的输入对软件进行建模以匹配该领域的软件设计方法。</span><br><span class="line"></span><br><span class="line">它主要是为了构建复杂领域，将业务的复杂性和技术的架构的实现解耦开来。DDD并不是一种具体的架构，而是一种方法论，通过边界的划分方法构建出清晰的领域和应用边界，让架构更加容易的进行演进。</span><br><span class="line"></span><br><span class="line">DDD在软件工程领域并不是一个非常容易理解的名词，要理解DDD需要对软件设计和软件架构等领域有一定的理解，因此，我们需要先从软件设计谈起。</span><br></pre></td></tr></table></figure><h2 id="一-什么才是软件设计"><a href="#一-什么才是软件设计" class="headerlink" title="一 . 什么才是软件设计"></a>一 . 什么才是软件设计</h2><p>在我们开发软件的过程中，经常会碰到许多问题，团队的成员在开发的同时也需要保证其稳定运行，但是，久而久之我们慢慢会发现软件设计的缺陷而引发的种种问题：</p><ul><li>开发人员热衷于技术并通过技术手段解决问题,而不是深入思考和设计,这会导致他们孜孜不倦地追逐技术上的新潮流。</li><li>过于重视数据库,大多数解决方案的讨论都是围绕数据库和数据模型,而不是业务流程和运作方式。</li><li>对于根据业务目标命名的对象和操作,开发人员没有给予应有的重视,这导致他们交付的软件和业务所拥有的心智模型之间产生巨大的分歧。</li><li>开发人员在用户界面和持久层组件中构建业务逻辑。此外,开发人员也经常会在业务逻辑当中执行持久化操作。</li><li>数据库查询会时常出现中断、延迟、死锁等问题,阻碍用户执行时间敏感型的业务操作。</li></ul><p>这一切都似乎发生在“设计无法带来低成本的软件！”的观念下。</p><p>这种现象在如今的软件开发大环境中屡见不鲜，而大多数软件开发人员也并不知道除此之外能否有更好的选择。</p><p>但是，臆想出来的“不做设计能省钱”的观念是一个谬论，许多程序员因为千奇百怪的而忽略了设计的重要性。</p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/SpringDataJPA/">SpringDataJPA</category>
      
      
      
      <comments>http://hznu.asia/2022/07/19/DDD%E5%88%9D%E6%8E%A2-%E4%BB%8EDDD%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Spring-Data-JPA%E6%80%9D%E6%83%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring AOP的应用---系统操作日志的实现--基于AspectJ</title>
      <link>http://hznu.asia/2022/07/02/Spring-AOP%E7%9A%84%E5%BA%94%E7%94%A8-%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E7%9A%84%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8EAspectJ/</link>
      <guid>http://hznu.asia/2022/07/02/Spring-AOP%E7%9A%84%E5%BA%94%E7%94%A8-%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E7%9A%84%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8EAspectJ/</guid>
      <pubDate>Sat, 02 Jul 2022 13:02:13 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;一-AOP的种类和关系&quot;&gt;&lt;a href=&quot;#一-AOP的种类和关系&quot; class=&quot;headerlink&quot; title=&quot;一. AOP的种类和关系&quot;&gt;&lt;/a&gt;一. &lt;strong&gt;AOP&lt;/strong&gt;的种类和关系&lt;/h2&gt;&lt;p&gt;目前主流的AOP 框架有2个，</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="一-AOP的种类和关系"><a href="#一-AOP的种类和关系" class="headerlink" title="一. AOP的种类和关系"></a>一. <strong>AOP</strong>的种类和关系</h2><p>目前主流的AOP 框架有2个，分别是spring aop 和aspectJ，前者是纯Java 实现的，不需要专门的编译过程和类加载器，在运行期间可以通过代理的方式向目标内植入增强的代码。</p><p>而AspectJ是一个基于Java语言的AOP框架。在Spring 2.0 开始，引入了对AspectJ 的支持，并提供了一个专门的编译器在编译时提供横向代码的植入。</p><p><img src="https://img.hznu.asia/AOP%E6%A6%82%E5%BF%B5%E5%9B%BE%E8%A7%A3.jpg"></p><h2 id="二-AOP常见术语"><a href="#二-AOP常见术语" class="headerlink" title="二. AOP常见术语"></a>二. AOP常见术语</h2><p><strong>1. 通知（Advice）</strong></p><p>切面在某个具体的连接点采取的行为或行动，称为通知。切面的核心逻辑代码都写在通知中，有人也称之为增强或者横切关注点。通知是切面功能的具体实现，通常是业务代码以外的需求，如日志、验证等，这些被模块化的特殊对象。</p><p>简单来说，假如你有某个你想要的功能，比如上面说的安全，事物，日志等。你给先定义好把，然后在想用的地方在某个地方用注解或者在xml中配置好，你想在哪里用这个事先定义好的模块化的内容。</p><blockquote><p>前置通知：org.springframework.aop.MethodBeforeAdvice<br>后置通知：org.springframework.aop.AfterReturningAdvice<br>异常通知：org.springframework.aop.ThrowsAdvice<br>环绕通知：org.aopalliance.intercept.MethodInterceptor</p></blockquote><p><strong>2. 连接点（JoinPoint）</strong></p><p>连接点就是 Spring AOP允许你使用通知（使用事先定义好的模块化的功能）的地方，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，<strong>Spring AOP 只支持方法连接点</strong>。</p><p>其他如 aspectJ 还可以让你在构造器或属性注入时都行，只要记住，<strong>和方法有关的前前后后（抛出异常），都是连接点。</strong></p><p><strong>3. 切入点（Pointcut）</strong></p><p>切入点是一个连接点的过滤条件，AOP 通过切点定位到特定的连接点。每个类都拥有多个连接点：例如 UserService类中的所有方法实际上都是连接点，即连接点是程序类中客观存在的事物。</p><p>类比：<strong>连接点相当于数据库中的记录，切点相当于查询条件</strong>。切点和连接点不是一对一的关系，<strong>一个切点匹配多个连接点</strong>，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p><p>比如你的一个类里，有15个方法，那就有几十个连接点了，但是你并不想在所有方法附近都使用通知（使用叫织入，后文会讲），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。</p><p><strong>4. 切面（Aspect）</strong></p><p>切面其实是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切入点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等干什么事），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p><p><strong>5. 引入（introduction）</strong></p><p>允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗？</p><p><strong>6. 目标（target）</strong></p><p>引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。</p><p><strong>7. 织入(weaving)</strong></p><p>把切面应用到目标对象来创建新的代理对象的过程。</p><h2 id="三-基于XML方式的实现"><a href="#三-基于XML方式的实现" class="headerlink" title="三. 基于XML方式的实现"></a>三. 基于XML方式的实现</h2><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a><strong>切入点表达式</strong></h4><p>　　作用: 知道对哪个类里面的哪个方法进行增强</p><p>　　语法结构: execution([权限修饰符] [返回类型] [类全路径] <a href="%5B%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%5D">方法名称</a>)</p><p>　　举例说明:</p><p>　　<strong>1. 对com.hznu.class 类里面的 add 方法进行增强:</strong></p><p>　　　　execution(* com.hznu.class.add(..))</p><p>　　　　说明: *表示包括public, private等所有修饰符, (..)表示所有参数</p><p>　　<strong>2. 对com.hznu.class 类里面的所有方法进行增强:</strong></p><p>　　　　execution(* com.hznu.class.*(..))</p><p>　　<strong>3. 对com.hznu包里面的所有类中的所有方法进行增强:</strong></p><p>　　　　execution(* com.hznu.<em>.</em>(..))</p><h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><ol><li>创建xml文件: (创建context和aop的名称空间; 开启注解扫描; 开启生成Aspect代理对象)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--开启注解扫描--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.hznu.aspect1&quot;&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--开启Aspect生成代理对象, 即找到带@aspect注解的类, 生成其代理对象--&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建被增强类 User.java: </li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//被增强的类</span><br><span class="line">@Component</span><br><span class="line">public class User &#123;</span><br><span class="line">    public void basic()&#123;</span><br><span class="line">        System.out.println(&quot;Basic method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建增强类 UserPro.java: </li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//增强的类</span><br><span class="line">@Component</span><br><span class="line">//生成代理对象</span><br><span class="line">@Aspect</span><br><span class="line">public class UserPro &#123;</span><br><span class="line"></span><br><span class="line">    //前置通知 使用切入点表达式, value可省略</span><br><span class="line">    @Before(value = &quot;execution(* com.hznu.aspect1.User.basic(..))&quot;)</span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;Before.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //最终通知, 在方法调用之后执行, 不管有无异常都执行</span><br><span class="line">    @After(value = &quot;execution(* com.hznu.aspect1.User.basic(..))&quot;)</span><br><span class="line">    public void After()&#123;</span><br><span class="line">        System.out.println(&quot;After.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //后置通知/返回通知, 在方法return值后执行, 有异常则不执行</span><br><span class="line">    @AfterReturning(value = &quot;execution(* com.hznu.aspect1.User.basic(..))&quot;)</span><br><span class="line">    public void AfterReturning()&#123;</span><br><span class="line">        System.out.println(&quot;AfterReturning.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //异常通知, 在方法产生异常时执行(可在被增强方法中通过1/0手动触发异常来触发)</span><br><span class="line">    @AfterThrowing(value = &quot;execution(* com.hznu.aspect1.User.basic(..))&quot;)</span><br><span class="line">    public void AfterThrowing()&#123;</span><br><span class="line">        System.out.println(&quot;AfterThrowing.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //环绕通知</span><br><span class="line">    @Around(value = &quot;execution(* com.hznu.aspect1.User.basic(..))&quot;)</span><br><span class="line">    public void Around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable&#123;</span><br><span class="line">        //方法之前执行内容</span><br><span class="line">        System.out.println(&quot;Around-Before.&quot;);</span><br><span class="line">        //被增强的方法执行</span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        //方法之后执行内容</span><br><span class="line">        System.out.println(&quot;Around-After&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>测试</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;com/hznu/aspect1/bean.xml&quot;);</span><br><span class="line">        User user = context.getBean(&quot;user&quot;, User.class);</span><br><span class="line">        user.basic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行结果</li></ol><p><img src="https://img.hznu.asia/AOP%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h2 id="四-项目中利用AOP注解实现日志"><a href="#四-项目中利用AOP注解实现日志" class="headerlink" title="四. 项目中利用AOP注解实现日志"></a>四. 项目中利用AOP注解实现日志</h2><h4 id="Jar包一览"><a href="#Jar包一览" class="headerlink" title="Jar包一览"></a>Jar包一览</h4><p>下图为AspectJ的主要一些注解，平时项目开发我一般都使用Spring + AspectJ</p><p><img src="https://img.hznu.asia/AOP%E7%9A%84Jar%E5%8C%85.png"></p><ol start="2"><li>定义 SysOperLog 实体类</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class SysOperLog</span><br><span class="line">&#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    /** 日志主键 */</span><br><span class="line">    @TableId(value = &quot;id&quot;, type = IdType.AUTO)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    /** 操作模块 */</span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    /** 业务类型（0其它 1新增 2修改 3删除） */</span><br><span class="line">    // &quot;0=其它,1=新增,2=修改,3=删除,4=授权,5=导出,6=导入,7=强退,8=生成代码,9=清空数据&quot;</span><br><span class="line">    private Integer businessType;</span><br><span class="line"></span><br><span class="line">    /** 业务类型数组 */</span><br><span class="line">    private Integer[] businessTypes;</span><br><span class="line"></span><br><span class="line">    /** 请求方法 */</span><br><span class="line">    private String method;</span><br><span class="line"></span><br><span class="line">    /** 请求方式 */</span><br><span class="line">    private String requestMethod;</span><br><span class="line"></span><br><span class="line">    /** 操作类别（0其它 1后台用户 2手机端用户） */</span><br><span class="line">    private Integer operatorType;</span><br><span class="line"></span><br><span class="line">    /** 操作人员 */</span><br><span class="line">    private String operName;</span><br><span class="line"></span><br><span class="line">    /** 部门名称 */</span><br><span class="line">    private String deptName;</span><br><span class="line"></span><br><span class="line">    /** 请求url */</span><br><span class="line">    private String operUrl;</span><br><span class="line"></span><br><span class="line">    /** 操作地址 */</span><br><span class="line">    private String operIp;</span><br><span class="line"></span><br><span class="line">    /** 请求参数 */</span><br><span class="line">    private String operParam;</span><br><span class="line"></span><br><span class="line">    /** 返回参数 */</span><br><span class="line">    private String jsonResult;</span><br><span class="line"></span><br><span class="line">    /** 操作状态（0正常 1异常） */</span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line">    /** 错误消息 */</span><br><span class="line">    private String errorMsg;</span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义自定义注解Log</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123; ElementType.PARAMETER, ElementType.METHOD &#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Log</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 模块</span><br><span class="line">     */</span><br><span class="line">    public String title() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 功能</span><br><span class="line">     */</span><br><span class="line">    public BusinessType businessType() default BusinessType.OTHER;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作人类别</span><br><span class="line">     */</span><br><span class="line">    public OperatorType operatorType() default OperatorType.MANAGE;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否保存请求的参数</span><br><span class="line">     */</span><br><span class="line">    public boolean isSaveRequestData() default true;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否保存响应的参数</span><br><span class="line">     */</span><br><span class="line">    public boolean isSaveResponseData() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>项目中定义日志切面</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作日志记录处理</span><br><span class="line"> * </span><br><span class="line"> * @author huangrui</span><br><span class="line"> */</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAspect</span><br><span class="line">&#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AsyncLogService asyncLogService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理完请求后执行</span><br><span class="line">     *</span><br><span class="line">     * @param joinPoint 切点</span><br><span class="line">     */</span><br><span class="line">    @AfterReturning(pointcut = &quot;@annotation(controllerLog)&quot;, returning = &quot;jsonResult&quot;) </span><br><span class="line">    public void doAfterReturning(JoinPoint joinPoint, Log controllerLog, Object jsonResult)</span><br><span class="line">    &#123;</span><br><span class="line">        handleLog(joinPoint, controllerLog, null, jsonResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 拦截异常操作</span><br><span class="line">     * </span><br><span class="line">     * @param joinPoint 切点</span><br><span class="line">     * @param e 异常</span><br><span class="line">     */</span><br><span class="line">    @AfterThrowing(value = &quot;@annotation(controllerLog)&quot;, throwing = &quot;e&quot;)</span><br><span class="line">    public void doAfterThrowing(JoinPoint joinPoint, Log controllerLog, Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        handleLog(joinPoint, controllerLog, e, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void handleLog(final JoinPoint joinPoint, Log controllerLog, final Exception e, Object jsonResult)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            // *========数据库日志=========*//</span><br><span class="line">            SysOperLog operLog = new SysOperLog();</span><br><span class="line">            operLog.set...(...);  // 此处省略与本文无关代码   </span><br><span class="line">            // 保存数据库</span><br><span class="line">            asyncLogService.saveSysLog(operLog);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception exp)</span><br><span class="line">        &#123;</span><br><span class="line">            // 记录本地异常日志</span><br><span class="line">            log.error(&quot;==前置通知异常==&quot;);</span><br><span class="line">            log.error(&quot;异常信息:&#123;&#125;&quot;, exp.getMessage());</span><br><span class="line">            exp.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取注解中对方法的描述信息 用于Controller层注解</span><br><span class="line">     * </span><br><span class="line">     * @param log 日志</span><br><span class="line">     * @param operLog 操作日志</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public void getControllerMethodDescription(JoinPoint joinPoint, Log log, SysOperLog operLog, Object jsonResult) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置action动作</span><br><span class="line">        operLog.setBusinessType(log.businessType().ordinal());</span><br><span class="line">        // 设置标题</span><br><span class="line">        operLog.setTitle(log.title());</span><br><span class="line">        // 设置操作人类别</span><br><span class="line">        operLog.setOperatorType(log.operatorType().ordinal());</span><br><span class="line">        // 是否需要保存request，参数和值</span><br><span class="line">        if (log.isSaveRequestData())</span><br><span class="line">        &#123;</span><br><span class="line">            // 获取参数的信息，传入到数据库中。</span><br><span class="line">            setRequestValue(joinPoint, operLog);</span><br><span class="line">        &#125;</span><br><span class="line">        // 是否需要保存response，参数和值</span><br><span class="line">        if (log.isSaveResponseData() &amp;&amp; StringUtils.isNotNull(jsonResult))</span><br><span class="line">        &#123;</span><br><span class="line">            operLog.setJsonResult(StringUtils.substring(com.alibaba.fastjson.JSON.toJSONString(jsonResult), 0, 2000));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取请求的参数，放到log中</span><br><span class="line">     * </span><br><span class="line">     * @param operLog 操作日志</span><br><span class="line">     * @throws Exception 异常</span><br><span class="line">     */</span><br><span class="line">    private void setRequestValue(JoinPoint joinPoint, SysOperLog operLog) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        String requestMethod = operLog.getRequestMethod();</span><br><span class="line">        if (HttpMethod.PUT.name().equals(requestMethod) || HttpMethod.POST.name().equals(requestMethod))</span><br><span class="line">        &#123;</span><br><span class="line">            String params = argsArrayToString(joinPoint.getArgs());</span><br><span class="line">            operLog.setOperParam(StringUtils.substring(params, 0, 2000));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>controller中使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> @Log(title = &quot;查询信息&quot;, operatorType = OperatorType.MOBILE)</span><br><span class="line"> @GetMapping(&quot;list&quot;)</span><br><span class="line"> public Response list() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心大致流程其实就是这样：</strong></p><ol><li><p>定义好一个实体类，主要就是用于保存日志到数据库中。（比如我们上面第三步new SysOperLog()，并且set了一些参数）</p></li><li><p>定义自定义注解Log，包含的参数参考上述第二步。</p></li><li><p>定义一个切面类，用@Aspect标识。这里主要关注两个注解：@AfterReturning 和 @AfterThrowing。一个是在自定义注解@Log标识的方法结束返回后调用，一个是在异常抛出后调用。</p><p>也就是说，在所有使用@Log标识的方法执行完后，都会调用 LogAspect 这个切面类中 被 @AfterReturning 注解作用的代码。@AfterThrowing也是同样的道理。</p></li><li><p>在Controller中使用注解@Log，并且定义好其参数。</p></li></ol><h2 id="五-JointPoint到底是什么"><a href="#五-JointPoint到底是什么" class="headerlink" title="五. JointPoint到底是什么"></a>五. JointPoint到底是什么</h2><p>在上文中，我们会看的这样一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@AfterReturning(pointcut = &quot;@annotation(controllerLog)&quot;, returning = &quot;jsonResult&quot;) </span><br><span class="line">public void doAfterReturning(JoinPoint joinPoint, Log controllerLog, Object jsonResult)&#123;</span><br><span class="line">handleLog(joinPoint, controllerLog, null, jsonResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里有一个JoinPoint类，JoinPoint是AOP的术语，称为“连接点”，而连接点在执行的时候可以看成当前请求类。什么意思呢？我们用上面的示例代码解释下：</p><p>比如现在有一个controller，里面有一个如下方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Log(title = &quot;查询信息&quot;, operatorType = OperatorType.MOBILE)</span><br><span class="line">@GetMapping(&quot;list&quot;)</span><br><span class="line">public Response list(@RequestParam(value = &quot;phone&quot;, required = false) String phone,</span><br><span class="line">                     @RequestParam(value = &quot;nickName&quot;, required = false) String nickName,</span><br><span class="line">                     @RequestParam(value = &quot;schoolId&quot;, required = false) String schoolId,</span><br><span class="line">                     @RequestParam(value = &quot;gender&quot;, required = false) String gender,</span><br><span class="line">                     @RequestParam(value = &quot;stealth&quot;, required = false) String stealth) &#123;</span><br><span class="line">        List&lt;User&gt; users = personalInformationService.list(phone, nickName, schoolId, gender, stealth);</span><br><span class="line">        return Response.success(users);</span><br></pre></td></tr></table></figure><p>上面的方法被 <code>@Log</code> 注解标识了，那么他就会执行我们在上文第四部分代码中的 <code>LogAspect</code> 类，那么这个<code>controller</code> 方法在执行完成后，则会执行我们本部分开头的那段代码，然后我们就可以在这个切面中做我们想做的事情，正如第四部分一样，对日志信息进行了处理。</p><p>在执行本部分开头代码的时候，<code>doAfterReturning</code> 方法第一个参数是 <code>JoinPoint joinPoint</code>，而<code>jointPoint</code> 里面包含的，就是我们 <code>controller</code> 里的 <code>list</code> 方法。我们debug看下里面包含哪些内容：</p><p><img src="https://img.hznu.asia/SpringAOP%E4%B9%8BJointPoint%E7%9A%84Debug%E5%9B%BE.png"></p><p>我们一个个来看下：</p><ul><li>joinPoint.getArgs();</li></ul><p>此方法是获取 <code>controller</code> 里的 <code>list</code> 方法里的请求参数，比如我用 <code>PostMan</code> 发起一个请求，请求参数里面包含 <code>phone</code> 这个字段，如下：</p><p><img src="https://img.hznu.asia/SpringAOP%E4%B9%8BJointPoint%E7%9A%84Postman%E8%AF%B7%E6%B1%82Args%E5%9B%BE.png"></p><p>那么我们的debug界面的 <code>args</code> 里就能看到这个参数，这里的<code>args</code> 是一个数组的形式</p><p><img src="https://img.hznu.asia/SpringAOP%E4%B9%8BJointPoint%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AF%B7%E6%B1%82Args%E5%9B%BE.png"></p><p>所以我们可以得出， <code>joinPoint.getArgs()</code> 获取的就是连接点（指的就是被注解标识，被请求 <code>controller</code> 里的 <code>list</code> 方法，后文统一称为连接点）的参数。</p><ul><li>joinPoint.getSignature();</li></ul><p>返回正在请求的方法的描述，可参考本部分第一张图</p><ul><li>joinPoint.getTarget();</li></ul><p>返回目标 object，可参考本部分第一张图</p><ul><li>joinPoint.getThis();</li></ul><p>返回代理 object，可参考本部分第一张图</p><ul><li>joinPoint.toString();</li></ul><p>打印建议方法的有用描述，可参考本部分第一张图</p><p><strong>所以，经过debug分析来看，<code>JoinPoint</code> 类的主要作用就是可以让我们在Advice中获取被增强方法相关的所有信息。</strong></p><h2 id="六-可能存在的疑惑"><a href="#六-可能存在的疑惑" class="headerlink" title="六. 可能存在的疑惑"></a>六. 可能存在的疑惑</h2><ol><li>LogAspect 类如何知道自定义注解 @Log 作用了哪些方法，又是如和获取他们的？</li></ol><p>这里主要有两种方法，一种是通过反射，获取包含 @Log注解的类或方法。另一种就是通过 @annotation，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@AfterThrowing(value = &quot;@annotation(controllerLog)&quot;, throwing = &quot;e&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@annotation：就是用于匹配当前执行方法持有指定注解的方法</span><br></pre></td></tr></table></figure><p>参考引用：</p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/Spring/">Spring</category>
      
      
      <category domain="http://hznu.asia/tags/Spring-AOP/">Spring AOP</category>
      
      
      <comments>http://hznu.asia/2022/07/02/Spring-AOP%E7%9A%84%E5%BA%94%E7%94%A8-%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E7%9A%84%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8EAspectJ/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>程序中Error和Exception的区别和处理方式</title>
      <link>http://hznu.asia/2022/06/29/%E7%A8%8B%E5%BA%8F%E4%B8%ADError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</link>
      <guid>http://hznu.asia/2022/06/29/%E7%A8%8B%E5%BA%8F%E4%B8%ADError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</guid>
      <pubDate>Wed, 29 Jun 2022 03:23:50 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;一-异常的分类&quot;&gt;&lt;a href=&quot;#一-异常的分类&quot; class=&quot;headerlink&quot; title=&quot;一. 异常的分类&quot;&gt;&lt;/a&gt;一. 异常的分类&lt;/h2&gt;&lt;p&gt;在 Java 中所有异常类型都是内置类 java.lang.Throwable 类的子类，即 T</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="一-异常的分类"><a href="#一-异常的分类" class="headerlink" title="一. 异常的分类"></a>一. 异常的分类</h2><p>在 Java 中所有异常类型都是内置类 java.lang.Throwable 类的子类，即 Throwable 位于异常类层次结构的顶层。Throwable 类下有两个异常分支 Exception 和 Error，而Exception分为 ”检查异常（非运行时异常）“ 和 ”不检查异常（运行时异常，RuntimeException）“。如下图所示：</p><p><img src="https://img.hznu.asia/%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E5%88%86%E7%B1%BB.png"></p><h4 id="1-1-Error-和-Exception-的异同点"><a href="#1-1-Error-和-Exception-的异同点" class="headerlink" title="1.1 Error 和 Exception 的异同点"></a>1.1 Error 和 Exception 的异同点</h4><p><strong>相同点：</strong> </p><p>1、Exception 和 Error 都集成了同一个类 Throwable。因为在Java中只有继承了Throwable类的实例才可以被抛出或者捕获。 </p><p><strong>不同点：</strong> </p><p>1、Error 会导致程序处于非正常的，不可恢复的状态，比如JVM自身的问题，OutOfMemoyError 等。 </p><p>２、Exception分为两种：可检查异常和不可检查异常。 在编译阶段显示捕获的异常称为可检查异常，比如IO异常。 在运行时被捕获的异常称为不可检查异常，比如空指针、数组越界。</p><h4 id="1-2-检查异常和非检查异常"><a href="#1-2-检查异常和非检查异常" class="headerlink" title="1.2 检查异常和非检查异常"></a>1.2 检查异常和非检查异常</h4><p><strong>检查异常：</strong>没有继承RuntimeException的Exception属于检查异常，这类问题在编译期就可以确定的问题，如<strong>FileNotFoundException、IOException</strong>。编译器对检查异常的处理要求：</p><ul><li>try..catch捕获。</li><li>不断向上抛出，交由jvm来处理。 </li></ul><p><strong>非检查异常：</strong>继承了RuntimeException的Exception，非检查异常也叫<strong>运行时异常</strong>，这类问题大部分属于逻辑问题，如<strong>数组越界、空指针异常</strong>，只有运行时才能知道的问题，异常在编译时不会检查。通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p><h4 id="类比解释"><a href="#类比解释" class="headerlink" title="类比解释"></a>类比解释</h4><p>假如你开车上山，车坏了，你拿出工具箱修一修，修好继续上路（Exception被捕获，从异常中恢复，继续程序的运行），车坏了，你不知道怎么修，打电话告诉修车行，告诉你是什么问题，要车行过来修。（在当前的逻辑背景下，你不知道是怎么样的处理逻辑，把异常抛出去到更高的业务层来处理）。你打电话的时候，要尽量具体，不能只说我车动不了了。那修车行很难定位你的问题。（要补货特定的异常，不能捕获类似Exception的通用异常）。还有一种情况是，你开车上山，山塌了，这你还能修吗？（Error：导致你的运行环境进入不正常的状态，很难恢复）</p><h2 id="二-异常处理准则"><a href="#二-异常处理准则" class="headerlink" title="二. 异常处理准则"></a>二. 异常处理准则</h2><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  // 业务代码</span><br><span class="line">  // …</span><br><span class="line">  Thread.sleep(1000L);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">  // Ignore it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码尽管很短，但是已经<strong>违反了两个准则</strong>。</p><ol><li><strong>尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常，在这里是 Thread.sleep() 抛出的 InterruptedException。</strong></li></ol><blockquote><p>这是因为在日常的开发和合作中，我们读代码的机会往往超过写代码，软件工程是门协作的艺术，所以我们有义务让自己的代码能够直观地体现出尽量多的信息，而泛泛的 Exception 之类，恰恰隐藏了我们的目的。另外，我们也要保证程序不会捕获到我们不希望捕获的异常。比如，你可能更希望 RuntimeException 被扩散出来，而不是被捕获。</p><p>进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确程序处理 OutOfMemoryError。</p></blockquote><ol start="2"><li><strong>不要生吞（swallow）异常。这是异常处理中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况。</strong></li></ol><blockquote><p>生吞异常，往往是基于假设这段代码可能不会发生，或者感觉忽略异常是无所谓的，但是千万不要在产品代码做这种假设。<strong><em>如果我们不把异常抛出来，或者也没有输出到日志（Logger）之类，程序可能在后续代码以不可控的方式结束</em>。</strong>没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。</p></blockquote><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   // 业务代码</span><br><span class="line">   // …</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码作为一段实验代码，它是没有任何问题的，但是在产品代码中，通常都不允许这样处理。</p><blockquote><p>我们先来看看printStackTrace()的文档，开头就是“Prints this throwable and its backtrace to the standard error stream”。简单说，就是 在命令行打印异常信息在程序中出错的位置及原因。</p><p>问题就在这里，在稍微复杂一点的生产系统中，标准出错（STERR）不是个合适的输出选项，因为你很难判断出到底输出到哪里去了。</p><p>尤其是对于分布式系统，如果发生异常，无法找到堆栈轨迹（stacktrace），这纯属是为诊断设置障碍。所以，最好使用产品日志，详细地输出到日志系统里。</p></blockquote><h4 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void readPreferences(String fileName)&#123;</span><br><span class="line">  InputStream in = new FileInputStream(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 fileName 是 null，那么程序就会抛出 NullPointerException，但是由于没有第一时间暴露出问题，堆栈信息可能非常令人费解，往往需要相对复杂的定位。这个 NPE 只是作为例子，实际产品代码中，可能是各种情况，比如获取配置失败之类的。在发现问题的时候，第一时间抛出，能够更加清晰地反映问题。</p><p>我们可以修改一下，让问题“throw early”，对应的异常信息就非常直观了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void readPreferences(String filename) &#123;</span><br><span class="line">  Objects.requireNonNull(filename);</span><br><span class="line">  InputStream in = new FileInputStream(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于“catch late”，其实是我们经常苦恼的问题，捕获异常后，需要怎么处理呢？最差的处理方式，就是我前面提到的“生吞异常”，本质上其实是掩盖问题。如果实在不知道如何处理，可以选择保留原有异常的 cause 信息，直接再抛出或者构建新的异常抛出去。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。</p><p><strong>所以，catch late，就是尽量晚的处理异常，在越外层处理越好。</strong></p><h4 id="关于-Checked-Exception（非运行时异常）"><a href="#关于-Checked-Exception（非运行时异常）" class="headerlink" title="关于 Checked Exception（非运行时异常）"></a>关于 Checked Exception（非运行时异常）</h4><p>业界有一种争论（甚至可以算是某种程度的共识），Java 语言的 Checked Exception 也许是个设计错误，反对者列举了几点：</p><ul><li>Checked Exception 的假设是我们捕获了异常，然后恢复程序。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception 的使用，已经大大偏离了最初的设计目的。</li><li>Checked Exception 不兼容 functional 编程，如果你写过 Lambda/Stream 代码，相信深有体会。</li></ul><blockquote><p>比如对于运行时异常，可以使用 list1.stream().filter(Objects::nonNull).map(); 判断非空</p><p>而对于 FileNotFoundException、IOException 等非运行时异常，则无法使用Lambda 和 Stream</p></blockquote><p>但是，很多人也觉得没有必要矫枉过正，因为确实有一些异常，比如和环境相关的 IO、网络等，其实是存在可恢复性的，而且 Java 已经通过业界的海量实践，证明了其构建高质量软件的能力。</p><h2 id="三-性能分析"><a href="#三-性能分析" class="headerlink" title="三. 性能分析"></a>三. 性能分析</h2><ul><li>try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，<strong>尽量不要一个大的 try 包住整段的代码</strong>；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</li><li><strong>Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作</strong>。如果发生的非常频繁，这个开销可就不能被忽略了。</li></ul><blockquote><p><strong>异常实例的构造十分昂贵。这是由于在构造异常实例时，Java 虚拟机便需要生成该异常的栈轨迹（stack trace）。该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。</strong></p></blockquote><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><ol><li><strong>NoClassDefFoundError 和 ClassNotFoundException 有什么区别？</strong></li></ol><p>NoClassDefFoundError 是个Error，是指一个class在编译时存在，在运行时找不到了class文件了；ClassNotFoundException 是个Exception，是使用类似Class.foName()等方法时的checked exception。</p><p>类的加载分为显式加载(用字符串为类名加载类，抛出ClassNotFoundException)和隐式加载(不是通过显式方法调用，由引用、实例化或继承导致装入类。通常这种错误在编译阶段会发现，报错为找不到符号。如果编译时能找到这个类，但运行时找不到这个类，就抛出NoClassDefFoundError)</p><ol start="2"><li>throw 和 throws 的区别？</li></ol><p><strong>throw</strong></p><p> 1、throw是语句抛出一个异常，一般是在<strong>代码块的内部</strong>，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常 </p><p>2、定义在方法体内 </p><p>3、创建的是一个异常对象 </p><p>4、确定了发生哪种异常才可以使用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final String upload(String baseDir, MultipartFile file) throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            return upload(baseDir, file, MimeTypeUtils.DEFAULT_ALLOWED_EXTENSION);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new IOException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>throws</strong> </p><p>1、<strong>在方法参数列表后</strong>，throws后可以跟着多个异常名，表示抛出的异常用逗号隔开 </p><p>2、<strong>表示向调用该类的位置抛出异常，不在该类解决</strong> </p><p>3、可能发生哪种异常 throws用在方法声明后面，跟的是异常类名，throw用在方法体内，跟的是异常对象名。 throws可以跟多个异常类名，用逗号隔开，throw只能抛出一个异常对象名。 throws表示抛出异常，由该方法的调用者来处理，throw表示抛出异常，由方法体内的语句处理。 throws表示出现异常的一种可能性，并不一定会发生这些异常，throw则是抛出了异常，执行throw则一定抛出了某种异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void openFile() throws FileNotFoundException&#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考引用：</p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/Java/">Java</category>
      
      
      <category domain="http://hznu.asia/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</category>
      
      
      <comments>http://hznu.asia/2022/06/29/%E7%A8%8B%E5%BA%8F%E4%B8%ADError%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络--运输层那点事</title>
      <link>http://hznu.asia/2022/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E9%82%A3%E7%82%B9%E4%BA%8B/</link>
      <guid>http://hznu.asia/2022/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E9%82%A3%E7%82%B9%E4%BA%8B/</guid>
      <pubDate>Tue, 21 Jun 2022 01:52:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;写在前面：本篇博客是在看完《计算机网络：自顶向下方法》运输层一章写的，但是写着写着感觉东西实在太多，重要的点也很多。因此只挑选一些常见且相对重要的点记录下来。遇到问题，还是建议去翻一翻本章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概念</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>写在前面：本篇博客是在看完《计算机网络：自顶向下方法》运输层一章写的，但是写着写着感觉东西实在太多，重要的点也很多。因此只挑选一些常见且相对重要的点记录下来。遇到问题，还是建议去翻一翻本章。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="运输层协议"><a href="#运输层协议" class="headerlink" title="运输层协议"></a>运输层协议</h4><p>​        运输层协议是<strong>在端系统中而不是在路由器</strong>中实现的。</p><p>​        在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层报文段实现的方法（可能）是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。然后，在发送端系统中，运输层将这些报文段传递给网络层，网络层将其封装成网络层分组（即数据报）并向目的地发送。</p><p>​        注意到下列事实是重要的：网络路由器仅作用于该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。运输层则处理接收到的报文段，使该报文段中的数据为接收应用进程使用</p><h4 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h4><blockquote><p>​        考虑有两个家庭，一家位于美国东海岸，一家位于美国西海岸，每家有12个孩子。 东海岸家庭的孩子们是西海岸家庭孩子们的堂兄弟姐妹。这两个家庭的孩子们喜欢彼此通信，每个人每星期要互相写一封信，每封信都用单独的信封通过传统的邮政服务传送。</p><p>​         因此，每个家庭每星期向另一家发送144封信。（如果他们有电子邮件的话，这些孩子可以 省不少钱！）每一个家庭有个孩子负责收发邮件，西海岸家庭是Ann而东海岸家庭是Bill。 每星期Ann去她的所有兄弟姐妹那里收集信件，并将这些信件交到每天到家门口来的邮政 服务的邮车上。当信件到达西海岸家庭时，Ann也负责将信件分发到她的兄弟姐妹手上。 在东海岸家庭中的Bill也负责类似的工作。</p><p>​        在这个例子中，邮政服务为两个家庭间提供逻辑通信，邮政服务将信件从一家送往另 一家，而不是从一个人送往另一个人。在另一方面，Ann和Bill为堂兄弟姐妹之间提供了 逻辑通信，Arm和Bill从兄弟姐妹那里收取信件或到兄弟姐妹那里交付信件。注意到从堂 兄弟姐妹们的角度来看，Ann和Bill就是邮件服务，尽管他们只是端到端交付过程的一部 分（即端系统部分）。在解释运输层和网络层之间的关系时，这个家庭的例子是一个非常 好的类比。</p><p><strong>应用层报文 = 信封上的字符</strong> </p><p><strong>进程 = 堂兄弟姐妹</strong> </p><p><strong>主机（又称为端系统）= 家庭</strong> </p><p><strong>运输层协议 = Ann和Bill</strong> </p><p><strong>网络层协议 = 邮政服务（包括邮车）</strong></p></blockquote><h4 id="为什么需要TCP协议"><a href="#为什么需要TCP协议" class="headerlink" title="为什么需要TCP协议"></a>为什么需要TCP协议</h4><p>​        不少人应该听说过TCP/IP协议，并且对此有一定的了解。其中，TCP协议处于运输层，而IP协议处于网络层。</p><p>​        其中，IP的服务模型是尽力而为交付服务， 这意味着IP尽它“最大的努力”在通信的主机之间交付报文段，但它并不做任何确保。特别是，它不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性。由于这些原因，IP被称为不可靠服务。由此，就需要TCP来做可靠性传输保障了。</p><p>​        TCP协议是运输层中非常重要的一个协议，除了提供可靠性传输之外，TCP还提供拥塞控制等功能，后文会展开讲解。</p><h4 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h4><p>​        在接收端，运输层检查这些字段，标识出接收套 接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工 作称为多路分解。</p><p>​        在源主机从不同套接字中收集数据块，并为每个数据 块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将报文段传递到网络 层，所有这些工作称为多路复用。</p><h4 id="流行应用即下面的运输层协议"><a href="#流行应用即下面的运输层协议" class="headerlink" title="流行应用即下面的运输层协议"></a>流行应用即下面的运输层协议</h4><table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">下面的运输协议</th></tr></thead><tbody><tr><td align="center">电子邮件</td><td align="center">SMTP</td><td align="center">TCP</td></tr><tr><td align="center">远程终端访问</td><td align="center">Telnet</td><td align="center">TCP</td></tr><tr><td align="center">Web</td><td align="center">HTTP</td><td align="center">TCP</td></tr><tr><td align="center">文件传输</td><td align="center">FTP</td><td align="center">TCP</td></tr><tr><td align="center">远程文件服务器</td><td align="center">NFS</td><td align="center">通常UDP</td></tr><tr><td align="center">流式多媒体</td><td align="center">通常专用</td><td align="center">UDP或TCP</td></tr><tr><td align="center">因特网电话</td><td align="center">通常专用</td><td align="center">UDP或TCP</td></tr><tr><td align="center">网络管理</td><td align="center">SNMP</td><td align="center">通常UDP</td></tr><tr><td align="center">名字转换</td><td align="center">DNS</td><td align="center">通常UDP</td></tr></tbody></table><h4 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h4><table><thead><tr><th>对比点</th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多交互通信</td><td>一对一</td></tr><tr><td>首部开销</td><td>首部开销小，8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td>使用场景</td><td>实用应用（IP电话、视频会议等）</td><td>文件传输等</td></tr></tbody></table><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>TCP和UDP都是运输层常用的协议，两者之间各有优劣</p><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><ol><li>TCP为什么要三次握手？</li></ol><ol start="2"><li>套接字和报文的区别是什么？</li></ol><p>​        TCP的分组称为报文段</p><ol start="3"><li>拥塞控制和流量控制服务的区别</li></ol><h2 id="参考引用："><a href="#参考引用：" class="headerlink" title="参考引用："></a>参考引用：</h2>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</category>
      
      
      <category domain="http://hznu.asia/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</category>
      
      
      <comments>http://hznu.asia/2022/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E9%82%A3%E7%82%B9%E4%BA%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>吉他入门</title>
      <link>http://hznu.asia/2022/05/13/%E5%90%89%E4%BB%96%E5%85%A5%E9%97%A8/</link>
      <guid>http://hznu.asia/2022/05/13/%E5%90%89%E4%BB%96%E5%85%A5%E9%97%A8/</guid>
      <pubDate>Fri, 13 May 2022 10:57:01 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://img.hznu.asia/%E5%BC%A6%E5%92%8C%E6%89%8B.png&quot;&gt;&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://img.hznu.asia/%E5%BC%A6%E5%92%8C%E6%89%8B.png"></p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E5%90%89%E4%BB%96/">吉他</category>
      
      
      
      <comments>http://hznu.asia/2022/05/13/%E5%90%89%E4%BB%96%E5%85%A5%E9%97%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>理解进程与线程</title>
      <link>http://hznu.asia/2022/04/27/%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <guid>http://hznu.asia/2022/04/27/%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <pubDate>Wed, 27 Apr 2022 07:53:20 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;一-进程&quot;&gt;&lt;a href=&quot;#一-进程&quot; class=&quot;headerlink&quot; title=&quot;一. 进程&quot;&gt;&lt;/a&gt;一. 进程&lt;/h2&gt;&lt;p&gt;进程（Process）是系统进行资源分配和调度的基本单位，是操作系统结构的基础。大白话讲，进程本质上是正在执行的一个程序</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="一-进程"><a href="#一-进程" class="headerlink" title="一. 进程"></a>一. 进程</h2><p>进程（Process）是系统进行资源分配和调度的基本单位，是操作系统结构的基础。大白话讲，进程本质上是正在执行的一个程序，并且，<strong>如果一个程序如果运行了两遍，则算作两个进程</strong>。</p><p>与每个进程相关的是地址空间，这是从某个最小值的存储位置（通常是0）到某个最大值的存储位置的列表。在这个地址空间中，进程可以读写。该地址空间存放有可执行程序、程序的数据以及程序的堆栈。</p><h5 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h5><p>在许多操作系统中，与一个进程有关的所有信息，除了该进程自身的地址空间的内容外，均存放在操作系统的一张表中，称为<strong>进程表</strong>，进程表是数组（或链表）结构，当前存在的进程都要占有其中一项。</p><p>所以，一个（挂起的）进程包括：进程的地址空间以及对应的进程表项（其中包括寄存器以及稍后重启该进程所需要的许多其他信息）。</p><h4 id="进程的组成："><a href="#进程的组成：" class="headerlink" title="进程的组成："></a>进程的组成：</h4><p><strong>进程是由程序控制块（PCB）、程序段、数据段组成。</strong></p><p>操作系统是通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需的各种信息，如进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息。</p><p>程序段：程序代码存放的位置。</p><p>数据段：程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量就存放在数据段内。</p><p><img src="http://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84" alt="http://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84"></p><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>在非常简单的系统中，比如微波炉中的控制器以及类似的系统，因为只为一个应用程序而设计，所以在启动时，所有在之后运行过程中需要的程序便已经存在。但是在更为复杂的操作系统中，需要有一种方式来创建或消耗进程。</p><p>主要有四种主要事件会创建进程：</p><p>​    1）系统初始化</p><p>​    2）正在运行的程序执行了创建进程的系统调用</p><p>​    3）用户请求创建一个新进程</p><p>​    4）一个批处理作业的初始化</p><p>启动操作系统时，通常会创建若干进程，其中有些是前台进程，也就是同用户交互并完成其相关指令的进程。还有些则是后台进程，这些与用户没有关系，比如一个接受电子邮件的进程，其大部分时间处于睡眠状态，但是当电子邮件到达时便被唤醒。这些停留在后台处理的进程称为<strong>守护进程</strong>。在大型系统中有很多守护进程，比如在Unix中，可以用<code>ps</code>指令列出正在运行的进程；在<code>Windows</code>中，则可以使用任务管理器。</p><p>在多处理机中，让每个进程在不同的CPU上运行会使整个作业运行得更快。进程创建的方式有许多种，在所有的情形中，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程做的工作是：执行一个用来创建新进程的系统调用，这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定在该进程中运行地程序。</p><p>此外，不同的操作系统也有不同的进程创建方式。</p><h5 id="Unix操作系统创建进程"><a href="#Unix操作系统创建进程" class="headerlink" title="Unix操作系统创建进程"></a>Unix操作系统创建进程</h5><p>在Unix操作系统中，只有一个系统调用可以创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用fork后，这两个进程（父进程和子进程）拥有相同的内存映像和相同的打开文件。通常，子进程接着执行<code>execve</code>或一个类似的系统调用，用于修改其内存映像并运行一个新的程序。之所以安排两步，是为了在fork后但在<code>execve</code>之前允许该子进程处理其文件描述符，这样可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。</p><h5 id="Windows操作系统创建进程"><a href="#Windows操作系统创建进程" class="headerlink" title="Windows操作系统创建进程"></a>Windows操作系统创建进程</h5><p>在，Windows中，情形正好相反，一个<code>Win32</code>函数调用<code>CreateProcess</code>既处理进程的创建，也负责把正确的程序装入新的进程。除了<code>CreateProcess</code>，Win32中大约有100个其他的函数用于处理进程的管理、同步以及相关的事物。</p><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><p>进程在创建之后，以下行为将引起终止：</p><p>​    1）正常退出（自愿的）</p><p>​    2）出错退出（自愿的）</p><p>​    3）严重错误（非自愿）</p><p>​    4）被其他进程杀死（非自愿）</p><p>其中第二个原因时<strong>进程发现了错误</strong>，比如用户输入 cc <code>foo.c</code> 编译程序 <code>foo.c</code>，但是该文件不存在，于是编译器退出。</p><p>第三个原因时<strong>由进程引起的错误</strong>，比如执行了一条非法指令，或者引用了一段不存在的内存或除数为0等等。</p><h4 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h4><h5 id="Unix中的结构"><a href="#Unix中的结构" class="headerlink" title="Unix中的结构"></a>Unix中的结构</h5><p>在Unix中，进程和它的所有子进程以及后裔共同组成了一个进程组。</p><p>Unix在初始化自己时，一个称为<code>init</code>的特殊进程出现在启动镜像中，当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录，如果有一个用户登录成功，该登录进程就执行一个<code>shell</code>准备接收命令。所接收的这些命令会启动更多的进程，以此类推。这样，在整个系统中，所有的进程都属于以<code>init</code>为根的一棵树。</p><h5 id="Windows中的结构"><a href="#Windows中的结构" class="headerlink" title="Windows中的结构"></a>Windows中的结构</h5><p>相反, Windows中没有进程层次的概念,所有的进程都是地位相同的。唯一类似于进程层次的暗示是在创建进程的时候,父进程得到一个特别的令牌(称为句柄),该句柄可以用来控制子进程。但是,它有权把这个令牌传送给某个其他进程,这样就不存在进程层次了。在UNIX中,进程就不能剥夺其子继承的“继承权”。 </p><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p>进程分三种状态：</p><p>​    1）就绪态（该时刻进程实际占用CPU）</p><p>​    2）就绪态（可运行，但因为其他进程正在运行而暂时停止）</p><p>​    3）阻塞态（除非某种外部事件发生，否则进程不能运行）</p><p><img src="https://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p><p>前两种状态在逻辑上是类似的。处于这两种状态的进程都可以运行,只是对于第二种状态暂时没有CPU分配给它。第三种状态与前两种状态不同,处于该状态的进程不能运行,即使CPU空闲也不行。</p><h4 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h4><p>为了实现进程模型,操作系统维护着一张表格(一个结构数组),即进程表(process table)。每个进程占用一个进程表项 (有些作者称这些表项为进程控制块) 该表项包含了进程状态的重要信息,包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息,以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息,从而保证该进程随后能再次启动,就像从未被中断过一样。 </p><p><img src="https://img.hznu.asia/%E8%BF%9B%E7%A8%8B%E8%A1%A8%E5%AD%97%E6%AE%B5.png"></p><p>在了解进程表后,就可以对在单个(或每一个) CPU上如何维持多个顺序进程的错觉做更多的阐述。<strong>与每一I/O类关联的是一个称作中断向量(interrupt vector)的位置(靠近内存底部的固定区域)。它包含中断服务程序的人口地址。假设当一个磁盘中断发生时,用户进程3正在运行,则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈,计算机随即跳转到中断向量所指示的地址。这些是硬件完成的所有操作,然后软件,特别是中断服务例程就接管一切剩余的工作。</strong> </p><p>其实这个操作，说白了，就是先保存到寄存器，再将一个或多个寄存器压入进程堆栈，再把进程存到进程表中。</p><p>所有的中断都从保存寄存器开始,对于当前进程而言,通常是保存在进程表项中。随后,会从堆栈中删除由中断硬件机制存人堆栈的那部分信息,并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。</p><h2 id="二-线程"><a href="#二-线程" class="headerlink" title="二. 线程"></a>二. 线程</h2><h4 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h4><p>需要线程的几个理由：</p><p>​    1）人们需要多线程的主要原因是,在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程,程序设计模型会变得更简单。</p><p>​    2）第二个关于需要多线程的理由是,由于线程比进程更轻量级,所以它们比进程更容易(即更快)创建,也更容易撤销。在许多系统中,创建一个线程较创建一个进程要快10~100倍。在有大量线程需要动态和快速修改时,具有这一特性是很有用的。</p><p>​    3）需要多线程的第三个原因涉及性能方面的讨论。若多个线程都是CPU密集型的,那么并不能获得性能上的增强,但是如果存在着大量的计算和大量的I/0处理,拥有多个线程允许这些活动彼此重叠进行,从而会加快应用程序执行的速度。最后,在多CPU系统中,多线程是有益的,在这样的系统中,真正的并行有了实现的可能。</p><ul><li><p>​    <strong>CPU密集型程序：</strong>程序中进行大量的数据运算处理，花费了绝大部分时间在计算上。最佳线程数 = CPU核心数 + 1，+1 是为防止有线程被阻塞，CPU可以调    用其他线程。</p></li><li><p>​    <strong>IO密集型程序：</strong>多任务并行处理，程序中大量进行IO操作，对CPU要求并不高，因此执行流个数没有太大要求。</p><p>​    最佳线程数  = 1/CPU利用率 = 1 + (I/O耗时) / (CPU耗时)；一般为CPU核心数的两倍。</p></li></ul><h4 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h4><p>在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。 </p><p><strong>进程中的不同线程</strong>不像不同进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写或甚至清除另一个线程的堆栈。线程之间是没有保护的，原因是: </p><p>1)不可能</p><p>2)也没有必要。</p><p>这与不同进程是有差别的。不同的进程会来自不同的用户，它们彼此之间可能有敌意，一个进程总是由某个用户所拥有，该用户创建多个线程应该是为了它们之间的合作而不是彼此间争斗。除了共享地址空间之外，所有线程还共享同一个打开文件集、子进程、定时器以及相关信号等，如图212所示。这样,对于三个没有关系的线程而言，应该使用下图第一列的结构，而在三个线程实际完成同一个作业，并彼此积极密切合作的情形中，下图第二列则比较合适。 </p><table><thead><tr><th align="center">每个进程中的内容</th><th align="center">每个线程中的内容</th></tr></thead><tbody><tr><td align="center">地址空间<br>全局变量<br>打开文件<br>子进程<br>即将发生的定时器<br>信号与信号处理程序<br>账户信息</td><td align="center">程序计数器<br>寄存器<br>堆栈<br>状态</td></tr></tbody></table><p><strong>线程概念试图实现的是：共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。</strong></p><h4 id="在用户空间实现线程"><a href="#在用户空间实现线程" class="headerlink" title="在用户空间实现线程"></a>在用户空间实现线程</h4><p><strong>有两种主要的方法实现线程包：在用户空间中和内核中。</strong>这两种方法各有利弊，不过也有混合实现的方式。</p><p>在用户空间管理线程时，每个进程需要有其专用的线程表(thread table)，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈、指针、寄存器和状态等。该线程表由运行时系统管理，当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。</p><p>当某个线程做了一些会引起在本地阻塞的事情之后,例如,等待进程中另一个线程完成某项工作,它调用一个运行时系统的过程,这个过程检查该线程是否必须进人阻塞状态。如果是,它在线程表中保存该线程的寄存器(即它本身的),查看表中可运行的就绪线程,并把新线程的保存值重新装入机器的寄存器中。</p><p>只要堆栈指针和程序计数器一被切换，新的线程就又自动投入运行。如果机器有一条保存所有寄存器的指令和另一条装入全部寄存器的指令，那么整个线程的切换可以在几条指令内完成。进行类似,于这样的线程切换至少比陷入内核要快一个数量级(或许更多)，这是使用用户级线程包的极大的优点。</p><h4 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h4><p>内核的线程表保存了每个线程的寄存器、状态和其他信息。这些信息和在用户空间中(在运行时系·统中)的线程是一样的,但是现在保存在内核中。这些信息是传统内核所维护的每个单线程进程信息(即进程状态)的子集。另外,内核还维护了传统的进程表,以便跟踪进程的状态。</p><p>由于在内核中创建或撤销线程的代价比较大,某些系统采取“环保”的处理方式,回收其线程。当某个线程被撤销时,就把它标志为不可运行的,但是其内核数据结构没有受到影响。稍后,在必须创建一个新线程时,就重新启动某个旧线程,从而节省了一些开销。在用户级线程中线程回收也是可能的,但是由于其线程管理的代价很小,所以没有必要进行这项工作。 </p><p><strong>存在的问题：</strong></p><ol><li>为什么在内核中创建或撤销线程的代价比较大</li></ol><p><strong>参考引用：</strong></p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</category>
      
      
      <category domain="http://hznu.asia/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</category>
      
      
      <comments>http://hznu.asia/2022/04/27/%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringDataJPA的前世今生</title>
      <link>http://hznu.asia/2022/04/23/SpringDataJPA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</link>
      <guid>http://hznu.asia/2022/04/23/SpringDataJPA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</guid>
      <pubDate>Sat, 23 Apr 2022 05:47:11 GMT</pubDate>
      
        
        
      <description>&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</description>
        
      
      
      
      <content:encoded><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前言：</span><br><span class="line">Java 持久层框架访问数据库的方式大致分为两种：一种以 SQL 核心，封装一定程度的 JDBC 操作，比如： MyBatis。</span><br><span class="line">另一种是以 Java 实体类为核心，将实体类的和数据库表之间建立映射关系，也就是我们说的 ORM 框架，如：Hibernate、Spring Data JPA。</span><br></pre></td></tr></table></figure><p><strong>在了解<code>Spring Data JPA</code>前，有必要先了解几个概念——<code>JPA</code>、<code>Hibernate</code>和<code>Spring Data JPA</code>。</strong></p><h2 id="一-JPA-、Hibernate-和-Spring-Data"><a href="#一-JPA-、Hibernate-和-Spring-Data" class="headerlink" title="一. JPA 、Hibernate 和 Spring Data"></a>一. JPA 、Hibernate 和 Spring Data</h2><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p>​        <code>Spring Data JPA</code>是建立的JPA的基础之上， 那么什么是JPA？</p><p>​        我们都知道不同的数据库厂商都有自己的实现类，后来统一规范也就有了数据库驱动，Java在操作数据库的时候，底层使用的其实是<code>JDBC</code>，而<code>JDBC</code>是一组操作不同数据库的规范。我们的Java应用程序，只需要调用<code>JDBC</code>提供的<code>API</code>就可以访问数据库了，而JPA也是类似的道理。</p><pre><code>     JPA全称是`Java Persistence API`（Java持久层API），它是Sun公司在JavaEE 5中提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：`Hibernate`。</code></pre><p>​        需要注意的是JPA统一了Java应用程序访问ORM框架的规范。</p><p>​        JPA为我们提供了以下规范：</p><p>​            1. ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。</p><p>​            2. JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发人员不用再写SQL了。</p><p>​            3. JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密藕合。</p><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><p>​        Hibernate是Java中的对象关系映射解决方案。对象关系映射或ORM框架是将应用程序数据模型对象映射到关系数据库表的技术。Hibernate 不仅关注于从 Java 类到数据库表的映射，也有 Java 数据类型到 SQL 数据类型的映射。</p><h4 id="Hibernate-和-JPA是什么关系呢？"><a href="#Hibernate-和-JPA是什么关系呢？" class="headerlink" title="Hibernate 和 JPA是什么关系呢？"></a><strong>Hibernate 和 JPA是什么关系呢？</strong></h4><p>​        上面我们介绍到JPA是Java EE 5规范中提出的Java持久化接口，而Hibernate是一个ORM框架。</p><h4 id="JPA和Hibernate的关系："><a href="#JPA和Hibernate的关系：" class="headerlink" title="JPA和Hibernate的关系："></a><strong>JPA和Hibernate的关系：</strong></h4><p>​        • JPA是一个规范，<strong>而不是框架</strong></p><p>​        • Hibernate是JPA的一种实现，<strong>是一个框架</strong></p><h3 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h3><h4 id="Spring-Data是什么？"><a href="#Spring-Data是什么？" class="headerlink" title="Spring Data是什么？"></a><strong>Spring Data是什么？</strong></h4><p>​        Spring Data是Spring 社区的一个子项目，主要用于简化数据（关系型&amp;非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。</p><p>​        • 它提供很多模板操作</p><p>​                – Spring Data Elasticsearch</p><p>​                – Spring Data MongoDB</p><p>​                – Spring Data Redis</p><p>​                – Spring Data Solr</p><p>​        • 强大的 Repository 和定制的数据储存对象的抽象映射</p><p>​        • 对数据访问对象的支持</p><p>​        <code>Spring Data JPA</code>是在实现了JPA规范的基础上封装的一套 JPA 应用框架，虽然ORM框架都实现了JPA规范，但是在不同的ORM框架之间切换仍然需要编写不同的代码，而使用<code>Spring Data JPA</code>能够方便大家在不同的ORM框架之间进行切换而不需要更改代码。<code>Spring Data JPA</code>旨在通过将统一ORM框架的访问持久层的操作，来提高开发的效率。</p><h4 id="Spring-Data-JPA和Hibernate的关系"><a href="#Spring-Data-JPA和Hibernate的关系" class="headerlink" title="Spring Data JPA和Hibernate的关系"></a>Spring Data JPA和Hibernate的关系</h4><p>​        <code>Hibernate</code>其实是JPA的一种实现，而<code>Spring Data JPA</code>是一个JPA数据访问抽象。<strong>也就是说Spring Data JPA不是一个实现或JPA提供的程序，它只是一个抽象层，主要用于减少为各种持久层存储实现数据访问层所需的样板代码量。但是它还是需要JPA提供实现程序，其实Spring Data JPA底层就是使用的 Hibernate实现。</strong></p><p><em><strong>总结就是：</strong></em></p><p><em><strong>• Hibernate是 JPA的一种实现，是一个框架</strong></em></p><p><em><strong>• Spring Data JPA是一种 JPA的抽象层，底层依赖 Hibernate</strong></em></p><p><img src="http://img.hznu.asia/202008270940571879.png" alt="http://img.hznu.asia/202008270940571879.png"></p><h2 id="二-ORM思想简介"><a href="#二-ORM思想简介" class="headerlink" title="二. ORM思想简介"></a>二. ORM思想简介</h2><p>​        前文提到， Spring Data JPA 底层是Hibernate ，而Hibernate 又是基于ORM思想的框架，因此，这里有必要对ORM做一个简单的介绍，以便理解后文。</p><p><strong>在探究什么是<code>ORM</code>之前，首先需要搞清楚几个概念：持久化和持久层。</strong></p><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>​        即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、<code>XML</code>中等等。</p><p>​        <code>Hibernate ORM</code>关心的是帮助应用程序实现持久性。持久性仅仅意味着我们希望应用程序的数据比应用程序进程的寿命更长。用<code>Java</code>术语来说，我们希望一些对象的状态超出<code>JVM</code>所能管控的范围，以便稍后可以使用相同的状态。</p><h4 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h4><p>​        即专注于实现数据持久化应用领域的某个特定系统的一个<strong>逻辑层面</strong>，将数据使用者和数据实体相关联。</p><h4 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h4><p>​        <code>ORM</code>即对象-关系映射（Object Relational Mapping），指的是在单个组件中负责所有实体域对象的持久化，封装数据库访问细节。它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的<code>SQL</code>语句打交道，只要像平时操作对象一样操作它就可以了 。</p><p>​        它是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。</p><p>​        <strong>采用 <code>ORM</code>框架后，应用程序不再直接访问底层数据库，而是以面向对象的方式来操作持久化对象，而<code>ORM</code>则将这些面向对象的操作转换成底层的 SQL 操作。</strong></p><p><img src="http://img.hznu.asia/A6970EEE-7490-4300-B50C-D3E368AFFAD5.png"></p><h4 id="常用的ORM中间件"><a href="#常用的ORM中间件" class="headerlink" title="常用的ORM中间件"></a>常用的ORM中间件</h4><p>​        开发<code>ORM</code>中间件需要十分专业的知识，因此一般在企业应用开发过程中都使用第三方提供的<code>ORM</code>中间件。下面列出了一些常用的<code>ORM</code>软件可供参考使用：</p><table><thead><tr><th align="center">ORM软件</th><th align="center">URL</th></tr></thead><tbody><tr><td align="center">Hibernate</td><td align="center"><a href="http://www.hibernate.org/">http://www.hibernate.org/</a></td></tr><tr><td align="center">Mybatis</td><td align="center"><a href="http://www.mybatis.org/">http://www.mybatis.org/</a></td></tr><tr><td align="center">Torque</td><td align="center"><a href="http://db.apache.org/torque/">http://db.apache.org/torque/</a></td></tr><tr><td align="center">JRelationalFramework</td><td align="center"><a href="http://jrf.sourceforge.net/">http://jrf.sourceforge.net</a></td></tr></tbody></table><p>​        <strong>不管是哪类<code>ORM</code>产品，首先需要保证的就是不能渗透到应用中，应用的上层组件应该和<code>ORM</code>中间件保持独立。</strong></p><p>​        有些<code>ORM</code>中间件要求在实体域对象中引入它们的类和接口，这会影响实体域对象的可移植性，如果日后想改用其他的<code>ORM</code>中间件，必须改写实体域对象的程序代码。另外,即使<code>ORM</code>中间件没有渗透到实体域对象中,应用程序中负责处理业务逻辑的过程域对象必须通过ORM中间件的API去访问数据库。每个<code>ORM</code>软件都有各自的<code>API</code>，如果一个应用程序起初使用了<code> Hibernate</code>,日后如果要改为使用<code>MyBatis</code>,就必须重新编写访问 <code>ORM</code> 中间件的代码。</p><p>​        为了削弱应用程序对特定<code>ORM</code>中间件的依赖性,<code>Oracle</code> 公司制定了统一的Java对象持久化 <code>API</code>(<code>Java Persistence API</code>,<code>JPA</code>)。<code>JPA</code>成为了各种<code> ORM</code>框架的标准<code>API</code>。<code>JPA</code>充分吸收了现有的包括<code>Hibernate</code>在内的<code>ORM</code>软件的优点,具有易于使用和伸缩性强的优势。应用程序可通过<code>JPA</code>来对实体域对象进行持久化。</p><h2 id="三-半自动ORM与全自动ORM框架"><a href="#三-半自动ORM与全自动ORM框架" class="headerlink" title="三. 半自动ORM与全自动ORM框架"></a>三. 半自动ORM与全自动ORM框架</h2><p>​        目前主流的持久层开发框架都是基于ORM思想的，但是ORM框架也有全自动化和半自动化之分。笔者认为，两者没有优劣之分，两者都有其适用的使用场景，对这两者都有一个较为深刻的理解也是很有必要的。</p><p>​        目前，主流的全自动ORM框架为Hibernate ，半自动ORM框架为Mybatis，那么，全自动和半自动的区别是什么呢？</p><h4 id="为什么说-Mybatis是半自动-ORM框架，而-Hibenate是全自动-ORM框架？"><a href="#为什么说-Mybatis是半自动-ORM框架，而-Hibenate是全自动-ORM框架？" class="headerlink" title="为什么说 Mybatis是半自动 ORM框架，而 Hibenate是全自动 ORM框架？"></a>为什么说 <code>Mybatis</code>是半自动 ORM框架，而 <code>Hibenate</code>是全自动 ORM框架？</h4><p>​        我们先来看看在持久层框架出现以前我们是如何对数据库进行操作的？</p><p>​        毋庸置疑，我们都使用 JDBC(Java Database Connectivity) 对数据库进行操作。操作步骤如下：</p><p>​        1. 加载驱动程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(driverClass)</span><br><span class="line">//加载MySql驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</span><br></pre></td></tr></table></figure><p>​        2. 获取数据库连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/imooc&quot;, &quot;root&quot;, &quot;root&quot;);</span><br></pre></td></tr></table></figure><pre><code>      3.  创建 `Statement` / `PerparedStatement` 对象</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn.createStatement();</span><br><span class="line">conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure><p>​    4. 操作数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.executeQuery(&quot;...&quot;);</span><br></pre></td></tr></table></figure><ol start="5"><li>关闭连接</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h5 id="Mybatis的实现机制"><a href="#Mybatis的实现机制" class="headerlink" title="Mybatis的实现机制"></a>Mybatis的实现机制</h5><p>1、读取 Mybatis的全局配置文件 mybatis-config.xml</p><p>2、创建 SqlSessionFactory会话工厂</p><p>3、创建 SqlSession会话</p><p>4、执行查询操作</p><p>mybatis-config.xml文件中包括一系列配置信息，其中包括标签 <mapper>，此标签配置了映射节点，映射节点内部定义了SQL语句。</mapper></p><p><strong>Mybatis将 SQL的定义工作独立出来，让用户自定义，而 SQL的解析，执行等工作交由 Mybatis处理执行。</strong></p><h5 id="Hibenate-的实现机制"><a href="#Hibenate-的实现机制" class="headerlink" title="Hibenate 的实现机制"></a>Hibenate 的实现机制</h5><p>1、构建 Configuration实例，初始化该实例中的变量</p><p>2、加载 hibenate.cfg.xml 文件到内存</p><p>3、通过 hibenate.cfg.xml 文件中的 mapping 节点配置并加载 xxx.hbm.xml 文件至内存</p><p>4、利用 Configuration实例构建 SessionFactory 实例</p><p>5、由SessionFactory 实例构建 session实例</p><p>6、由 session实例创建事务操作接口 Transaction 实例</p><p>7、执行查询操作</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><strong>传统的 JDBC是手工的，需要程序员加载驱动、建立连接、创建 Statement 对象、定义SQL语句、处理返回结果、关闭连接等操作。</strong></p><p><strong>Hibernate 是自动化的，内部封装了JDBC，并且还将 SQL 语句封装了，理念是即使开发人员不懂SQL语言也可以进行开发工作，向应用程序提供调用接口，直接调用即可。</strong></p><p><strong>Mybatis 是半自动化的，是介于 JDBC和 Hibernate之间的持久层框架，也是对 JDBC 进行了封装，不过将SQL的定义工作独立了出来交给用户实现，负责完成剩下的SQL解析，处理等工作。</strong></p><h2 id="四-Spring-Data-JPA-的前世今生"><a href="#四-Spring-Data-JPA-的前世今生" class="headerlink" title="四. Spring Data JPA 的前世今生"></a>四. Spring Data JPA 的前世今生</h2><p>由于如今EJB很少使用，许多人对此完全没有概念，因此在了解Spring Data JPA发展史之前，有必要对EJB做一个稍微详细一点的介绍，从而能对为什么如今更流行Hibernate和Spring Data JPA有一个更为清晰的认识。</p><h4 id="EJB-的演变史"><a href="#EJB-的演变史" class="headerlink" title="EJB 的演变史"></a>EJB 的演变史</h4><p>​        EJB (Enterprise Java Beans) 是基于分布式事务处理的企业级应用程序的组件。Sun公司发布的文档中对EJB的定义是：<strong>EJB是用于开发和部署多层结构的、分布式的、面向对象的Java应用系统的跨平台的构件体系结构</strong>。</p><p>​        由于 IBM 和 Sun Microsystems 等EJB提倡者力推其前景，起初一些大公司纷纷采用EJB部署他们的系统。然而随后各种问题便接踵而至，对 EJB 的恶评短时间内激增。</p><p>​        在实际运用中被发现，如果使用EJB来封装业务逻辑会带来性能上的下降。这是因为，<strong>最早的EJB规范只允许客户端通过特定协议</strong>（如<code>CORBA</code>进行远程方法调用）<strong>来调用</strong>，即使大部分实际应用根本就不需要分布式计算。直到EJB 2.0才引入了本地接口，以支持可以开发不通过网络就能直接本地调用的EJB系统。</p><p>​        尽管如此，EJB的广泛普及仍然为其复杂度所制约。尽管已经有一些高质量的集成开发工具可以协助开发人员通过自动编码解决一部分重复作业，但这并不能降低学习此项技术的难度。另一方面，“草根阶层”的编程爱好者们发起了一场旨在使用 “轻量级”技术以代替复杂的EJB的运动。这些技术包括<code>Hibernate</code>（用于提供数据持久化和对象-关系映射）及<code>Spring</code>框架（用于封装业务逻辑）。</p><p>​        EJB规范起初的一个主要价值—对分布式应用进行事务管理—在随后的实践中被一致认为几乎没能派上用场。对于企业级应用来说，Spring和Hibernate等简化框架更加实用。因此，EJB 3.0规范（JSR 220）为了迎合这个趋势相比于其之前的版本进行了一次激进的大跳跃。</p><p>​        <strong>受到Spring 影响，EJB 3.0也使用所谓的“传统简单Java对象POJO”；同时，支持依赖注入来简化全异系统的集成与配置。</strong></p><p>​        <strong>Hibernate的创始人Gavin King参与了这一新版规范的制订，并对EJB大加提倡。Hibernate的许多特性也被引入到Java持久化API当中，从而取代原来的实体bean。EJB 3.0规范大幅采用Java注解（annotation）来对代码进行元数据修饰，从而消减了此前EJB编程的冗杂性。</strong></p><p>​        <strong>相应地，EJB 3.0几乎成为了一个全新的API，与此前的数版可谓毫无相似度可言</strong>。    </p><p>​        在技术不断演变过程中，出现过众多璀璨的“新星”，而每一个产品的诞生也都和时代的需要有关。其实，在Hibernate和EJB演变的过程中，两者之间也有众多联系。</p><h4 id="EJB-和-Hibernate-的爱恨情仇"><a href="#EJB-和-Hibernate-的爱恨情仇" class="headerlink" title="EJB 和 Hibernate 的爱恨情仇"></a>EJB 和 Hibernate 的爱恨情仇</h4><p>​        在Java世界，Hibernate是最引人关注的一个话题。从Gavin King加入EJB3.0，负责制订EJB3.0的持久层规范；到Gavin King非正式退出JDO，并且充满个人情绪的攻击JDO2.0规范；到《Hibernate in Action》的发行；再到Hibernate3 Alpha的发布；最后再到最近JBoss 3.0 PR的发布(使用Hibernate3实现Entity Bean)。可以说这其中的每一步都引起业界的关注。</p><p>​        自从Gavin King加入JBoss之后，Hibernate已经由一个民间的开源软件走上了兼容EJB EntityBean的道路。Gavin King在EJB3.0 EG中充当了一个非常重要的角色，只要对比一下EJB3.0的EntityBean和Hibernate3，真相就会大白，<strong>虽然API接口不同，但是 EntityBean的设计理念完全来自于Hibernate。</strong></p><p>​        虽然EJB3.0的EntityBean在相当程度上来源于Hibernate，但是毕竟是不同的API接口，因此Hibernate和EJB3.0 EntityBean究竟是怎样的一种关系，是很多人心中的疑问。</p><p>​        2004年10月8日JBoss发布的EJB3.0 PR揭开了答案。Gavin King对Hibernate3进行了简单的封装，将EJB 3.0 EntityBean API调用转换为内部Hibernate3自己的API，从而实现EJB3.0 EntityBean的兼容。</p><p>​        EJB3.0不承诺脱离容器调用，如果你想使用EJB3.0，则必须运行在某个EJB Vendor提供的容器内，例如你使用JBoss提供的容器，那么你调用的是EntityBean API，这些调用请求会被转换为Hibernate API的调用请求。<strong>这意味着Hibernate实际上提供了两套API：一套是Hibernate原生API；另一套是兼容EJB3.0 EntityBean API。</strong></p><p>​        对于那些需要分布式调用支持，需要EJB容器的开发人员来说，他们选择后一套API；对于不需要EJB容器的开发人员来说，他们选择前一套 API。这就是Hibernate既定的发展策略，也是奠定其如今地位地关键。</p><p>​        Spring Data JPA演变成如今的样子是一个漫长的过程。在了解完什么是EJB以及其与Hibernate的关联后，要完全了解Spring Data JPA的形成过程，还得从技术架构的演变谈起。</p><h4 id="技术架构的演变"><a href="#技术架构的演变" class="headerlink" title="技术架构的演变"></a>技术架构的演变</h4><p>第一种：Session Bean ⇿ Entity Bean ⇿ DB        (EJB架构)<br>                                         ↓</p><p>第二种：Session Bean ⇿ DAO ⇿  JDBC ⇿ DB   （JDBC架构）<br>                                         ↓</p><p>第三种：Session Bean ⇿ DAO ⇿ Hibernate ⇿ DB   （Hibernate 架构）</p><p>首先我们对上面3个架构来简单分析下：<br><strong>1、内存消耗：</strong></p><p>​        采用JDBC的第二种架构是最省内存的，Hibernate的第三种架构次之，EJB的第一种架构最差。 </p><p><strong>2、运行效率：</strong></p><p>​        如果JDBC的代码写的非常优化，那么JDBC架构运行效率最高，但是实际项目中，这一点几乎做不到，这需要程序员非常精通JDBC，运用Batch语句批量处理，调整PreapredStatement的Batch Size和Fetch Size等参数，以及在必要的情况下采用结果集cache等等，<strong>而一般情况下程序员是做不到这一点的。</strong></p><p>​        因此Hibernate架构表现出最快的运行效率。</p><p>​        EJB的架构效率会差的很远，EJB效率低的一大原因就是通过RMI调用，RMI是一种Java的远程调用方法调用技术，要通过TCP/IP，比本地函数调用的开销要慢很多，此外entity bean效率低的还有更主要的原因，就是由于entity bean的结构造成的。由于使用entity bean每查找一行数据要进行两次数据库操作（一次是找出主键，另一次是通过主键找出数据），因此使数据库访问的效率大打折扣。 </p><p><strong>3、开发效率：</strong></p><p>​        在有JBuilder（一款Java可视化开发工具）支持下以及简单的项目，EJB架构开发效率最高，JDBC次之，Hibernate最差。但是在大的项目，特别是持久层关系映射很复杂的情况下，Hibernate效率很高，JDBC次之，而EJB架构由于其使用复杂性等原因很可能会失败。</p><p>​        从上面的结构演变来看，变化都是集中在Session Bean至DB之间的，而中间无非是从 Entity Bean 到 JDBC 再到 Hibernate ，这几种都是集中在对数据库的操作上，当然EJB不仅仅只是数据库操作，但是EJB 在各个方面都不占优势。因此，我们再来<strong>对这三种涉及的数据库相关操作展开分析</strong>，来对技术为什么会演变成如今的样子一探究竟。</p><p>​        (1) JDBC：多数Java开发人员是用JDBC来和数据库进行通信，它可以通过DAO模式进行改善和提高。但这种方式在大型应用程序中不容易操作使用，且维护起来相当困难。 </p><p>​        (2) EJB： EJB通常是在数据持久技术上的第二个选择，它是通过Entity Beans来对数据进行持久化。首先就需要购买一个价位合理的EJB容器一J2EE应用服务器，也可以采用开源项目的免费EJB容器，比如JBOSS。但是很多商业EJB容器的性能和技术支持不太好，在EJB中实现JDBC也比较复杂。 </p><p>​        (3)  Hibernate： Hibernate这种持久框架在某些方面有很大的不同，它不需要任何容器，提供简单易用的API。作为一个良好的ORM ，它有如下特点： </p><p>​                1. 透明地提供对象与关系数据库的映射，以统一的接口方式支持多种数据源，可以方便地进行切换。 </p><p>​                2. 缓存机制，缓存机制和锁定策略使针对数据库操作大大减少，提高系统运行效率地同时降低了对数据库的直接冲击。 </p><p>​                3. 开源免费的License，开源免费的特性使得使用人员可以自主研究源代码，并能够对系统提出建议或直接对源代码加以改进。 </p><p>​                4. 轻量级封装，避免引入过多复杂的问题，方便调试，减轻程序员的负担。 </p><p>​                5. 具有可移植性，基于JPA规范开发，使其无需手写SQL便可实现众多数据库相关操作并具有可移植性。 </p><p>​                ……</p><p>​        从上面可以看出，Hibernate相较于EJB和JDBC的结构来说，拥有众多优势，这也是如今Hibernate相较于其他两种架构更流行的原因。</p><h4 id="Hibernate-兼容-JPA"><a href="#Hibernate-兼容-JPA" class="headerlink" title="Hibernate 兼容 JPA"></a>Hibernate 兼容 JPA</h4><p>​        JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。</p><p>​        前面提到，JPA是Java EE 5规范中提出的Java持久化接口，而Hibernate是一个ORM框架，Hibernate是 JPA的一种实现。JPA是需要框架来实现其功能的，Hibernate就是JPA实现框架中很强的一个，应该说是目前最主流的一个框架。从功能上来说，JPA就是Hibernate功能的一个子集。</p><p>​        Hibernate 从3.2开始，就开始兼容JPA。Hibernate3.2获得了Sun TCK的JPA(Java Persistence API) 兼容认证。只要熟悉Hibernate或者其他ORM框架，在使用JPA时会发现其实非常容易上手。</p><h4 id="Spring-Data-JPA问世"><a href="#Spring-Data-JPA问世" class="headerlink" title="Spring Data JPA问世"></a>Spring Data JPA问世</h4><p>​        Hibernate 在 3.2 的时候提供了 JPA 的实现，其余的 JPA 的供应商还有诸如 OpenJPA、 Toplink等；Spring 在做持久化这一块的工作，开发了 Spring-data-xxx 这一系列包，如： Spring-data-jpa， Spring-data-redis， Spring-data-mongodb 等等，这些都是 Spring 提供的基于 JPA 和其他一些 NOSQL 的 Repository。</p><p>​        <strong>Spring Data JPA 是在 JPA 规范的基础下提供了 Repository 层的实现，但是使用哪一款 ORM 需要你自己去决定；相比我们更为熟悉的 Hibernate 和 MyBatis， Spring Data JPA 可以看做更高层次的抽象。</strong></p><h4 id="再看什么是Spring-Data-JPA"><a href="#再看什么是Spring-Data-JPA" class="headerlink" title="再看什么是Spring Data JPA"></a>再看什么是Spring Data JPA</h4><p><strong>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展。Spring Data JPA让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现。</strong></p><h2 id="五-Spring-Data-JPA的简单使用"><a href="#五-Spring-Data-JPA的简单使用" class="headerlink" title="五. Spring Data JPA的简单使用"></a>五. Spring Data JPA的简单使用</h2><h3 id="Spring-Data-JPA基本概念介绍"><a href="#Spring-Data-JPA基本概念介绍" class="headerlink" title="Spring Data JPA基本概念介绍"></a>Spring Data JPA基本概念介绍</h3><h4 id="实体类和数据库表的映射配置"><a href="#实体类和数据库表的映射配置" class="headerlink" title="实体类和数据库表的映射配置"></a>实体类和数据库表的映射配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">** 所有的注解都是使用JPA的规范提供的注解，</span><br><span class="line"> ** 所以在导入注解包的时候，一定要导入javax.persistence下的</span><br><span class="line"> */</span><br><span class="line">@Entity //声明实体类</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@Table(name=&quot;cst_customer&quot;) //建立实体类和表的映射关系</span><br><span class="line">public class Customer &#123;</span><br><span class="line"></span><br><span class="line">@Id//声明当前私有属性为主键</span><br><span class="line">@GeneratedValue(strategy=GenerationType.IDENTITY) //配置主键的生成策略</span><br><span class="line">@Column(name=&quot;cust_id&quot;) //指定和表中cust_id字段的映射关系</span><br><span class="line">private Long custId;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_name&quot;) //指定和表中cust_name字段的映射关系</span><br><span class="line">private String custName;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_source&quot;)//指定和表中cust_source字段的映射关系</span><br><span class="line">private String custSource;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_industry&quot;)//指定和表中cust_industry字段的映射关系</span><br><span class="line">private String custIndustry;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_level&quot;)//指定和表中cust_level字段的映射关系</span><br><span class="line">private String custLevel;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_address&quot;)//指定和表中cust_address字段的映射关系</span><br><span class="line">private String custAddress;</span><br><span class="line"></span><br><span class="line">@Column(name=&quot;cust_phone&quot;)//指定和表中cust_phone字段的映射关系</span><br><span class="line">private String custPhone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用注解说明"><a href="#常用注解说明" class="headerlink" title="常用注解说明"></a>常用注解说明</h4><blockquote><p>@Entity</p><p>​      作用：指定当前类是实体类。</p><p>@Table</p><p>​    作用：指定实体类和表之间的对应关系。</p><p>​    属性：name：指定数据库表的名称</p><p>@Id</p><p>​    作用：指定当前字段是主键。</p><p>@GeneratedValue</p><p>​    作用：指定主键的生成方式。。</p><p>​    属性：strategy ：指定主键生成策略。</p><p>@Column</p><p>​     作用：指定实体类属性和数据库表之间的对应关系</p><p>​     属性：</p><p>​        name：指定数据库表的列名称。</p><p>​        unique：是否唯一 </p><p>​        nullable：是否可以为空 </p><p>​        inserttable：是否可以插入 </p><p>​        updateable：是否可以更新 </p><p>​        columnDefinition: 定义建表时创建此列的DDL </p><p>​        secondaryTable: 从表名。如果此列不建在主表上（默认建在主表），该属性定义该列所在从表的名字搭建开发环境（主键所在的表是主表。 外键所在的表是从表）</p></blockquote><h5 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h5><p>通过annotation（注解）来映射hibernate实体的,基于annotation的hibernate主键标识为@Id, 其生成规则由@GeneratedValue设定的.这里的@id和@GeneratedValue都是JPA的标准用法。</p><p>JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO。</p><p>具体说明如下：</p><p>**IDENTITY: **主键由数据库自动生成（主要是自动增长型）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Id  </span><br><span class="line">@GeneratedValue(strategy = GenerationType.IDENTITY) </span><br><span class="line">private Long custId;</span><br></pre></td></tr></table></figure><p>​    </p><p><strong>SEQUENCE</strong>：根据底层数据库的序列来生成主键，条件是数据库支持序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Id  </span><br><span class="line">@GeneratedValue(strategy = GenerationType.SEQUENCE,generator=&quot;payablemoney_seq&quot;)  </span><br><span class="line">@SequenceGenerator(name=&quot;payablemoney_seq&quot;, sequenceName=&quot;seq_payment&quot;)  </span><br><span class="line">private Long custId;</span><br><span class="line"></span><br><span class="line">//@SequenceGenerator源码中的定义</span><br><span class="line">@Target(&#123;TYPE, METHOD, FIELD&#125;)   </span><br><span class="line">@Retention(RUNTIME)  </span><br><span class="line">public @interface SequenceGenerator &#123;  </span><br><span class="line">    //表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中</span><br><span class="line">    String name();  </span><br><span class="line">    //属性表示生成策略用到的数据库序列名称。</span><br><span class="line">    String sequenceName() default &quot;&quot;;  </span><br><span class="line">    //表示主键初识值，默认为0</span><br><span class="line">    int initialValue() default 0;  </span><br><span class="line">    //表示每次主键值增加的大小，例如设置1，则表示每次插入新记录后自动加1，默认为50</span><br><span class="line">    int allocationSize() default 50;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AUTO</strong>：主键由程序控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Id  </span><br><span class="line">@GeneratedValue(strategy = GenerationType.AUTO)  </span><br><span class="line">private Long custId;</span><br></pre></td></tr></table></figure><p><strong>TABLE</strong>：使用一个特定的数据库表格来保存主键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Id  </span><br><span class="line">@GeneratedValue(strategy = GenerationType.TABLE, generator=&quot;payablemoney_gen&quot;)  </span><br><span class="line">@TableGenerator(name = &quot;pk_gen&quot;,  table=&quot;tb_generator&quot;,  pkColumnName=&quot;gen_name&quot;,  </span><br><span class="line">valueColumnName=&quot;gen_value&quot;,  pkColumnValue=&quot;PAYABLEMOENY_PK&quot;,  allocationSize=1  ) </span><br><span class="line">private Long custId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//@TableGenerator的定义：</span><br><span class="line">@Target(&#123;TYPE, METHOD, FIELD&#125;)    </span><br><span class="line">@Retention(RUNTIME)  </span><br><span class="line">public @interface TableGenerator &#123;  </span><br><span class="line">    //表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的“generator”值中</span><br><span class="line">    String name();  </span><br><span class="line">    //表示表生成策略所持久化的表名，例如，这里表使用的是数据库中的“tb_generator”。</span><br><span class="line">    String table() default &quot;&quot;;  </span><br><span class="line">    //catalog和schema具体指定表所在的目录名或是数据库名</span><br><span class="line">    String catalog() default &quot;&quot;;  </span><br><span class="line">    String schema() default &quot;&quot;;  </span><br><span class="line">    //属性的值表示在持久化表中，该主键生成策略所对应键值的名称。例如在“tb_generator”中将“gen_name”作为主键的键值</span><br><span class="line">    String pkColumnName() default &quot;&quot;;  </span><br><span class="line">    //属性的值表示在持久化表中，该主键当前所生成的值，它的值将会随着每次创建累加。例如，在“tb_generator”中将“gen_value”作为主键的值 </span><br><span class="line">    String valueColumnName() default &quot;&quot;;  </span><br><span class="line">    //属性的值表示在持久化表中，该生成策略所对应的主键。例如在“tb_generator”表中，将“gen_name”的值为“CUSTOMER_PK”。 </span><br><span class="line">    String pkColumnValue() default &quot;&quot;;  </span><br><span class="line">    //表示主键初识值，默认为0。 </span><br><span class="line">    int initialValue() default 0;  </span><br><span class="line">    //表示每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50。</span><br><span class="line">    int allocationSize() default 50;  </span><br><span class="line">    UniqueConstraint[] uniqueConstraints() default &#123;&#125;;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//这里应用表tb_generator，定义为 ：</span><br><span class="line">CREATE TABLE  tb_generator (  </span><br><span class="line">id NUMBER NOT NULL,  </span><br><span class="line">gen_name VARCHAR2(255) NOT NULL,  </span><br><span class="line">gen_value NUMBER NOT NULL,  </span><br><span class="line">PRIMARY KEY(id)  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="Spring-Data-JPA完整体验"><a href="#Spring-Data-JPA完整体验" class="headerlink" title="Spring Data JPA完整体验"></a>Spring Data JPA完整体验</h4><p>由于现在大多数时候，都会结合SpringBoot等框架来进行开发，因此本例采用和SpringBoot结合使用的场景来讲解。</p><p>首先在maven中引入依赖包（若使用gradle可自行在官网查询）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>​        先看一个简单的例子，实现增删查改的功能；从例子中我们可以发现，可以通过方法名称的定义，就可以达到 SQL 的效果:</p><p>比如 findByName(String name) 就相当于 select * from user where name = ?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface UserCrudRepository extends CrudRepository&lt;User, String&gt;&#123;    </span><br><span class="line">User findOne(String userid);    </span><br><span class="line">List&lt;User&gt; findByName(String name);    </span><br><span class="line">List&lt;User&gt; findByNameAndAgeLessThan(String name, int age);    </span><br><span class="line">void deleteByNameAndAgeLessThan(String name, int age);    </span><br><span class="line">List&lt;User&gt; findDistinctByName(String name);    </span><br><span class="line">List&lt;User&gt; findByNameIgnoreCase(String name);    </span><br><span class="line">User findFirstByOrderByUseridDesc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h4><p>Spring Date JPA提供了几个接口：</p><ul><li>Repository：最顶层的接口，是一个空的接口，目的是为了统一所有Repository的类型，且能让组件扫描的时候自动识别。</li><li>CrudRepository：是Repository的子接口，提供CRUD的功能。</li><li>PagingAndSortingRepository ：是CrudRepository的子接口，添加分页和排序的功能。</li><li>JpaRepository ：是PagingAndSortingRepository的子接口，增加了批量操作等功能。</li></ul><h4 id="完整体验"><a href="#完整体验" class="headerlink" title="完整体验"></a>完整体验</h4><h5 id="yml配置项"><a href="#yml配置项" class="headerlink" title="yml配置项"></a>yml配置项</h5><p>首先如本节开头所述，在maven中引入依赖，然后在application.yml中编写如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring：</span><br><span class="line">jpa:</span><br><span class="line">    show-sql: true </span><br><span class="line">    database: mysql</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update // 每次运行程序，没有表格会新建表格，表内有数据 不会清空，只会更新</span><br><span class="line">    open-in-view: false</span><br></pre></td></tr></table></figure><p>创建三个实体类：Intent（意图）、Question（问题）、Answer（答案），其中 Intent 和 Question 为一对多关系， Intent 和 Answer 也为一对多关系。</p><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;intent&quot;)</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line">public class Intent &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy= GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;id&quot;, length = 11)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;intentName&quot;, length = 500, nullable = false)</span><br><span class="line">    private String intentName;</span><br><span class="line"></span><br><span class="line">    @OneToMany(targetEntity = Question.class,fetch=FetchType.EAGER,cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JsonIgnoreProperties(value = &#123;&quot;intent&quot;&#125;)</span><br><span class="line">    private Set&lt;Question&gt; questionList = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @OneToMany(targetEntity = Answer.class,fetch=FetchType.EAGER,cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JsonIgnoreProperties(value = &#123;&quot;intent&quot;&#125;)</span><br><span class="line">    private Set&lt;Answer&gt; answerList = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;create_time&quot;, nullable = false)</span><br><span class="line">    @CreatedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;update_time&quot;, nullable = false)</span><br><span class="line">    @LastModifiedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;deleted&quot;, insertable = false, columnDefinition=&quot;int default 0&quot;)</span><br><span class="line">    private Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;answer&quot;)</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line">public class Answer implements Serializable &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy= GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;id&quot;, length = 11)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;answer&quot;, length = 1000, nullable = false)</span><br><span class="line">    private String answer;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JoinColumn(name = &quot;intent_id&quot;, referencedColumnName = &quot;id&quot;)</span><br><span class="line">    private Intent intent;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;create_time&quot;, nullable = false)</span><br><span class="line">    @CreatedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;update_time&quot;, nullable = false)</span><br><span class="line">    @LastModifiedDate</span><br><span class="line">    @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;deleted&quot;, length = 1, columnDefinition=&quot;tinyint default 0&quot;, insertable = false)</span><br><span class="line">    private Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;question&quot;)</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line">public class Question implements Serializable &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy= GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;id&quot;, length = 11)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;question&quot;, length = 500, nullable = false)</span><br><span class="line">    private String question;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(cascade = &#123;CascadeType.ALL&#125;)</span><br><span class="line">    @JoinColumn(name = &quot;intent_id&quot;, referencedColumnName = &quot;id&quot;)</span><br><span class="line">    private Intent intent;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;create_time&quot;, nullable = false)</span><br><span class="line">    @CreatedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;update_time&quot;, nullable = false)</span><br><span class="line">    @LastModifiedDate</span><br><span class="line">    @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;deleted&quot;, length = 1, columnDefinition=&quot;tinyint default 0&quot;, insertable = false)</span><br><span class="line">    private Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在编写完实体类后，并在数据库创建名为“chat”的数据库后，启动项目，数据库将会按照实体类映射关系自动创建数据库表。</p><h5 id="持久层-1"><a href="#持久层-1" class="headerlink" title="持久层"></a>持久层</h5><p>编写持久层接口，并继承 JpaRepository 和 JpaSpecificationExecutor。如果只需要基本的一些操作，也可以只继承 JpaRepository ，视使用场景而定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IntentDao extends JpaRepository&lt;Intent, Integer&gt;, JpaSpecificationExecutor &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h5><p>在service中，利用 Spring 的依赖注入获取 <code>IntentDao</code>后，对其进行增、删、改、查操作。</p><h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface IntentService &#123;</span><br><span class="line">    Page&lt;Intent&gt; list(Integer page, Integer size);</span><br><span class="line"></span><br><span class="line">    Intent insert(Intent intent);</span><br><span class="line"></span><br><span class="line">    Intent update(Intent intent);</span><br><span class="line"></span><br><span class="line">    Intent delete(Intent intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class IntentServiceImpl implements IntentService &#123;</span><br><span class="line">    private IntentDao intentDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public IntentServiceImpl(IntentDao intentDao) &#123;</span><br><span class="line">        this.intentDao = intentDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Page&lt;Intent&gt; list(Integer page, Integer size) &#123;</span><br><span class="line">        Specification specification = new Specification&lt;Intent&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Predicate toPredicate(Root root, CriteriaQuery query, CriteriaBuilder criteriaBuilder) &#123;</span><br><span class="line">                return criteriaBuilder.notEqual(root.get(&quot;deleted&quot;).as(Integer.class), &quot;1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        return  intentDao.findAll(specification, PageRequest.of(page, size));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Intent insert(Intent intent) &#123;</span><br><span class="line">        return intentDao.save(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Intent update(Intent intent) &#123;</span><br><span class="line">        return intentDao.save(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Intent delete(Intent intent) &#123; // 注意：这里删除使用的是逻辑删除，若为物理删除，则使用 intentDao.delete(intent);</span><br><span class="line">        intent.setDeleted(1);</span><br><span class="line">        return intentDao.save(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/intent&quot;)</span><br><span class="line">public class IntentController &#123;</span><br><span class="line">    private IntentService intentService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public IntentController(IntentService intentService) &#123;</span><br><span class="line">        this.intentService = intentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;list&quot;)</span><br><span class="line">    public Response list(@RequestParam(&quot;page&quot;) Integer page,</span><br><span class="line">                             @RequestParam(&quot;size&quot;) Integer size) &#123;</span><br><span class="line">        return Response.success(intentService.list(page, size));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;create&quot;)</span><br><span class="line">    public Response create(@RequestBody Intent intent) &#123;</span><br><span class="line">        return Response.success(intentService.insert(intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;update&quot;)</span><br><span class="line">    public Response update(@RequestBody Intent intent) &#123;</span><br><span class="line">        return Response.success(intentService.update(intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;delete&quot;)</span><br><span class="line">    public Response delete(@RequestBody Intent intent) &#123;</span><br><span class="line">        return Response.success(intentService.delete(intent));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableJpaAuditing // 此注解作用是开启自动数据字段填充功能，比如 create_time 等字段在创建时直接插入系统当前时间</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ChatApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ChatApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是关于Spring Data JPA的完成示例</p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h2><p>从时间线来看：</p><ol><li> Hibernate 的团队开发了 Hibernate</li><li>制订 J2EE 规范的团队邀请 Hibernate 的核心团队在 Hibernate 基础上制订了 JPA （Java Persistent API）标准。<strong>从功能上看，JPA 是 Hibernate 的子集。</strong></li><li>Spring 的团队使用 Spring 对 JPA 做了封装，就是 Spring Data JPA 了。</li></ol><p>​        总之，JPA 是一个 API 标准，除了 Hibernate 外，还有其它厂商的实现，例如 Eclipse 的 TopLink。<strong>Spring Data Jpa 是个对 JPA 的封装，帮助程序员以 Spring 的方式来使用 JPA。</strong></p><blockquote><p>参考文献：</p><p>【1】 <a href="https://copyfuture.com/blogs-details/20211020223216210c">https://copyfuture.com/blogs-details/20211020223216210c</a></p><p>【2】<a href="http://blog.itpub.net/10752043/viewspace-990145/">http://blog.itpub.net/10752043/viewspace-990145/</a> ”谈谈ejb的效率问题“</p><p>【3】<a href="https://www.cnblogs.com/liqun-12345/p/5588309.html">https://www.cnblogs.com/liqun-12345/p/5588309.html</a> ”Hibernate和JDBC、EJB比较“</p><p>【4】<a href="https://baike.baidu.com/item/EJB/144195?fr=aladdin">https://baike.baidu.com/item/EJB/144195?fr=aladdin</a> ”EJB“</p><p>【5】<a href="http://www.blogjava.net/zhangxv/archive/2006/03/02/33167.html">http://www.blogjava.net/zhangxv/archive/2006/03/02/33167.html</a> “Hibernate发展之路”</p><p>【6】<a href="https://juejin.cn/post/6844904014757265416">https://juejin.cn/post/6844904014757265416</a> “Spring Data JPA”</p><p>【7】<a href="https://www.zhihu.com/question/335584253/answer/753316281">https://www.zhihu.com/question/335584253/answer/753316281</a> </p><p>【8】<a href="https://blog.csdn.net/weixin_42653522/article/details/119492142">https://blog.csdn.net/weixin_42653522/article/details/119492142</a> ”半自动ORM与全自动ORM框架有什么区别？“</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/SpringDataJPA/">SpringDataJPA</category>
      
      
      <category domain="http://hznu.asia/tags/%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF/">对象持久化技术</category>
      
      
      <comments>http://hznu.asia/2022/04/23/SpringDataJPA%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深入理解ORM思想</title>
      <link>http://hznu.asia/2022/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ORM%E6%80%9D%E6%83%B3/</link>
      <guid>http://hznu.asia/2022/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ORM%E6%80%9D%E6%83%B3/</guid>
      <pubDate>Sat, 26 Mar 2022 06:34:02 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;ORM简介&quot;&gt;&lt;a href=&quot;#ORM简介&quot; class=&quot;headerlink&quot; title=&quot;ORM简介&quot;&gt;&lt;/a&gt;ORM简介&lt;/h3&gt;&lt;p&gt;​        &lt;code&gt;ORM&lt;/code&gt;即对象-关系映射（Object Relational Mappin</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="ORM简介"><a href="#ORM简介" class="headerlink" title="ORM简介"></a>ORM简介</h3><p>​        <code>ORM</code>即对象-关系映射（Object Relational Mapping），指的是在单个组件中负责所有实体域对象的持久化，封装数据库访问细节。它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的<code>SQL</code>语句打交道，只要像平时操作对象一样操作它就可以了 。</p><p>​        <strong>在探究什么是<code>ORM</code>之前，首先需要搞清楚几个概念：持久化和持久层。</strong></p><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>​        即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、<code>XML</code>中等等。</p><p>​        <code>Hibernate ORM</code>关心的是帮助应用程序实现持久性。持久性仅仅意味着我们希望应用程序的数据比应用程序进程的寿命更长。用<code>Java</code>术语来说，我们希望(一些)对象的状态超出<code>JVM</code>所能管控的范围，以便稍后可以使用相同的状态。</p><h4 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h4><p>​        即专注于实现数据持久化应用领域的某个特定系统的一个<strong>逻辑层面</strong>，将数据使用者和数据实体相关联。</p><h3 id="ORM是一种思想"><a href="#ORM是一种思想" class="headerlink" title="ORM是一种思想"></a>ORM是一种思想</h3><p>​        在了解完以上几个概念后，我们有必要深入了解一下到底什么才是<code>ORM</code>。正如标题所说，<code>ORM</code>我认为其实是一种面向对象编程演变过程中，形成的一种编程思想。</p><h4 id="究竟什么是面向对象"><a href="#究竟什么是面向对象" class="headerlink" title="究竟什么是面向对象"></a>究竟什么是面向对象</h4><p>​        一个优秀的软件架构，是要基于面向对象设计的深入理解与运用的，那么，究竟什么才是面向对象呢？很多人碰到这个问题，通常会甩出三个词——继承、封装、多态，我碰到许多人都会这么回答，当然这没有错，但总让我感觉这个回答有点生疏。另一种常见的回答则是“面向对象是一种对真实世界进行建模的方式”，似乎好像比上一种更容易理解一点，但是也只能算是避重就轻，“对真实世界的建模”到底要如何进行？我们为什么要这么做？这么做有什么好处？许多人问到这便会陷入困境，不知如何回答。</p><p>​        那让我们先详细了解一下生疏而又神秘的三个特性——继承、封装、多态。这十分有利于我们去理解<code>ORM</code>思想。</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>​        所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​        所谓继承，是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>​        就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><p>​        面向对象的三大特性，其中一个非常重要的用处就是使得程序可复用性极高，它使得我们的软件体系架构得到解耦。其实这些思想和操作系统也有着很大的关联，比如在<code>UNIX</code>操作系统中，IO设备是被设计成插件形式的，简单说就是：程序和设备无关。而这又可以引申出另一种编程模式：依赖反转。</p><h4 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h4><p>​        设想一下，假如有一个main函数，控制着A、B、C三个函数，而A、B、C分别控制着A1、A2、A3，B1、B2、B3，C1、C2、C3函数。这样，main函数要调用其他模块，就必须看到其他模块所在的模块，每个函数的调用方就必须引用被调用方所在的模块，<strong>这样就导致系统行为决定控制流，而控制流决定着源代码的依赖关系。</strong></p><p>​        再设想一下，有一个main函数、一个A接口、一个A接口的实现类，函数的调用是通过源代码级别的接口来实现的，此时的依赖关系方向和控制流是相反的，我们在称之为<code>依赖反转</code> 。</p><p>​        通过这种方法，软件工程师可以完全控制采用了面向对象编程方式中的所有源代码依赖关系，而不再收到系统控制流的限制。不管哪个模块调用或者被调用，软件工程师都可以随意更改源代码依赖关系。</p><h4 id="回到问题"><a href="#回到问题" class="headerlink" title="回到问题"></a>回到问题</h4><p>​        <strong>那么我们回到最开始的问题，究竟什么才是面向对象编程呢？其实在笔者看过的许多经典作品中，很多人对此都有不同的说法和意见，但是对于软件工程师而言：面向对象编程就是以多态的手段对源代码中的依赖关系加以控制和约束，让高层代码对低层代码达到解耦的目的，实现相对独立的编程开发工作，这也是目前主流的软件体系架构思想。</strong></p><p>​        了解以上内容后，我们回到主题：什么是<code>ORM</code>思想？它和面向对象有什么关系？为什么需要<code>ORM</code>？</p><p>​        在目前的企业应用系统设计中，<code>MVC</code>，即 Model（模型）- View（视图）- Control（控制）为主要的系统架构模式。<code>MVC</code> 中的 Model 包含了复杂的业务逻辑和数据逻辑，以及数据存取机制（如<code> JDBC</code>的连接、<code>SQL</code>生成和<code>Statement</code>创建、还有<code>ResultSet</code>结果集的读取等）等。</p><p>​        将这些复杂的业务逻辑和数据逻辑分离，以将系统的紧耦 合关系转化为松耦合关系（即解耦合），是降低系统耦合度迫切要做的，也是持久化要做的工作。</p><p><code>MVC</code> 模式实现了架构上将表现层（即View）和数据处理层（即Model）分离的解耦合，而持久化的设计则实现了数据处理层内部的业务逻辑和数据逻辑分离的解耦合。 而 <code>ORM </code>作为持久化设计中的最重要也最复杂的技术，也是目前业界热点技术。</p><p>​        简单来说，按通常的系统设计，使用<code> JDBC</code> 操作数据库，业务处理逻辑和数据存取逻辑是混杂在一起的。<br>​        一般基本都是如下几个步骤：<br>​            1、建立数据库连接，获得<code>Connection</code>对象。<br>​            2、根据用户的输入组装查询<code> SQL</code> 语句。<br>​            3、根据<code> SQL</code> 语句建立<code> Statement</code> 对象 或者<code>PreparedStatement</code>对象。<br>​            4、用<code>Connection</code>对象执行<code> SQL</code>语句，获得结果集<code> ResultSet</code> 对象。<br>​            5、然后一条一条读取结果集 <code>ResultSet</code> 对象中的数据。<br>​            6、根据读取到的数据，按特定的业务逻辑进行计算。<br>​            7、根据计算得到的结果再组装更新<code> SQL</code> 语句。<br>​            8、再使用 <code>Connection</code> 对象执行更新 <code>SQL</code> 语句，以更新数据库中的数据。<br>​            9、最后依次关闭各个<code>Statement</code>对象和 <code>Connection</code> 对象。</p><p>​        由上可看出代码逻辑非常复杂，这还不包括某条语句执行失败的处理逻辑。其中的业务处理逻辑和数据存取逻辑完全混杂在一块。</p><p>而一个完整的系统要包含成 千上万个这样重复的而又混杂的处理过程，假如要对其中某些业务逻辑或者一些相关联的业务流程做修改，要改动的代码量将不可想象。</p><p>​        另一方面，假如要换数据库产品或者运行环境也可能是个不可能完成的任务。而用户的运行环境和要求却千差万别，我们不可能为每一个用户每一种运行环境设计一套一样的系统。</p><p>​        所以就要将一样的处理代码即业务逻辑和可能不一样的处理即数据存取逻辑分离开来，另一方面，关系型数据库中的数据基本都是以一行行的数据进行存取的，而程序 运行却是一个个对象进行处理，而目前大部分数据库驱动技术（如<code>ADO.NET</code>、<code>JDBC</code>、<code>ODBC</code>等等）均是以行集的结果集一条条进行处理的。</p><p>​        所以为解决这一困难，就出现<code> ORM</code> 这一个对象和数据之间映射技术。</p><p>​        举例来说，比如要完成一个购物打折促销的程序，用 <code>ORM</code> 思想将如下实现：</p><p>​        业务逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Double calcAmount(String customerid, double amount) &#123;</span><br><span class="line">  // 根据客户ID获得客户记录</span><br><span class="line">  Customer customer = CustomerManager.getCustomer(custmerid); </span><br><span class="line">  // 根据客户等级获得打折规则</span><br><span class="line">  Promotion promotion = PromotionManager.getPromotion(customer.getLevel()); </span><br><span class="line">  // 累积客户总消费额，并保存累计结果</span><br><span class="line">  customer.setSumAmount(customer.getSumAmount().add(amount); </span><br><span class="line">  CustomerManager.save(customer); </span><br><span class="line">  // 返回打折后的金额</span><br><span class="line">  return amount.multiply(protomtion.getRatio()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这样代码就非常清晰了，而且与数据存取逻辑完全分离。设计业务逻辑代码的时候完全不需要考虑数据库<code>JDBC</code>的那些千篇一律的操作，而将它交给 <code>CustomerManager</code> 和 <code>PromotionManager</code> 两个类去完成。这就是一个简单的 <code>ORM</code> 设计，实际的 <code>ORM</code> 实现框架比这个要复杂的多。</p><h3 id="常用的ORM中间件"><a href="#常用的ORM中间件" class="headerlink" title="常用的ORM中间件"></a>常用的ORM中间件</h3><p>​        开发<code>ORM</code>中间件需要十分专业的知识，因此一般在企业应用开发过程中都使用第三方提供的<code>ORM</code>中间件。下面列出了一些常用的<code>ORM</code>软件可供参考使用：</p><table><thead><tr><th align="center">ORM软件</th><th align="center">URL</th></tr></thead><tbody><tr><td align="center">Hibernate</td><td align="center"><a href="http://www.hibernate.org/">http://www.hibernate.org/</a></td></tr><tr><td align="center">Mybatis</td><td align="center"><a href="http://www.mybatis.org/">http://www.mybatis.org/</a></td></tr><tr><td align="center">Torque</td><td align="center"><a href="http://db.apache.org/torque/">http://db.apache.org/torque/</a></td></tr><tr><td align="center">JRelationalFramework</td><td align="center"><a href="http://jrf.sourceforge.net/">http://jrf.sourceforge.net</a></td></tr></tbody></table><p>​        不管是哪类<code>ORM</code>产品，首先需要保证的就是不能渗透到应用中，应用的上层组件应该和<code>ORM</code>中间件保持独立。有些<code>ORM</code>中间件要求在实体域对象中引入它们的类和接口，这会影响实体域对象的可移植性，如果日后想改用其他的<code>ORM</code>中间件，必须改写实体域对象的程序代码。</p><p>​        另外,即使<code>ORM</code>中间件没有渗透到实体域对象中,应用程序中负责处理业务逻辑的过程域对象必须通过ORM中间件的API去访问数据库。</p><p>​        每个<code>ORM</code>软件都有各自的<code>API</code>，如果一个应用程序起初使用了<code> Hibernate</code>,日后如果要改为使用<code>MyBatis</code>,就必须重新编写访问 <code>ORM</code> 中间件的代码。为了削弱应用程序对特定<code>ORM</code>中间件的依赖性,<code>Oracle</code> 公司制定了统一的Java对象持久化 <code>API</code>(<code>Java Persistence API</code>,<code>JPA</code>)。<code>JPA</code>成为了各种<code> ORM</code>架的标准<code>API</code>。</p><p>​        <code>JPA</code>充分吸收了现有的包括<code>Hibernate</code>在内的<code>ORM</code>软件的优点,具有易于使用和伸缩性强的优势。应用程序可通过<code>JPA</code>来对实体域对象进行持久化。</p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/SpringDataJPA/">SpringDataJPA</category>
      
      
      
      <comments>http://hznu.asia/2022/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ORM%E6%80%9D%E6%83%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL如何选择合适的数据类型和索引</title>
      <link>http://hznu.asia/2022/03/06/MySQL%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <guid>http://hznu.asia/2022/03/06/MySQL%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Sun, 06 Mar 2022 08:36:28 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;选择合适的数据类型&quot;&gt;&lt;a href=&quot;#选择合适的数据类型&quot; class=&quot;headerlink&quot; title=&quot;选择合适的数据类型&quot;&gt;&lt;/a&gt;选择合适的数据类型&lt;/h2&gt;&lt;h4 id=&quot;时间类型选择&quot;&gt;&lt;a href=&quot;#时间类型选择&quot; class=&quot;head</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h2><h4 id="时间类型选择"><a href="#时间类型选择" class="headerlink" title="时间类型选择"></a>时间类型选择</h4><table><thead><tr><th align="center">日期和时间类型</th><th align="center">字节</th><th align="center">最小值</th><th align="center">最大值</th></tr></thead><tbody><tr><td align="center">DATE</td><td align="center">4</td><td align="center">1000-01-01</td><td align="center">9999-12-31</td></tr><tr><td align="center">DATETIME</td><td align="center">8</td><td align="center">1000-01-01 00:00:00</td><td align="center">9999-12-31 23:59:59</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">4</td><td align="center">19700101080001</td><td align="center">2038年某个时刻</td></tr><tr><td align="center">TIME</td><td align="center">3</td><td align="center">-838：59：59</td><td align="center">838：59：59</td></tr><tr><td align="center">YEAR</td><td align="center">1</td><td align="center">1901</td><td align="center">2155</td></tr></tbody></table><p>其中，<code>TimeStamp</code>有一个重要的特点，就是和时区相关。当插入日期时，会先转换为本地时区后存储，后续需要取出时，也需要根据所在地时区进行转换显示。这样，不同时区的用户看到的同一个日期可能是不一样的。</p><h4 id="CHAR和VARCHAR"><a href="#CHAR和VARCHAR" class="headerlink" title="CHAR和VARCHAR"></a><code>CHAR</code>和<code>VARCHAR</code></h4><table><thead><tr><th align="center">值</th><th align="center">CHAR(4)</th><th align="center">存储需求</th><th align="center">VARCHAR(4)</th><th align="center">存储需求</th></tr></thead><tbody><tr><td align="center">“</td><td align="center">‘  ‘</td><td align="center">4个字节</td><td align="center">“</td><td align="center">1个字节</td></tr><tr><td align="center">‘ab’</td><td align="center">‘ab ‘</td><td align="center">4个字节</td><td align="center">‘ab ‘</td><td align="center">3个字节</td></tr><tr><td align="center">‘abcd’</td><td align="center">‘abcd’</td><td align="center">4个字节</td><td align="center">‘abcd’</td><td align="center">5个字节</td></tr><tr><td align="center">‘abcdefgh’</td><td align="center">‘abcd’</td><td align="center">4个字节</td><td align="center">‘abcd’</td><td align="center">5个字节</td></tr></tbody></table><blockquote><p>注：上图中最后一行只适用于<code>MySQL</code>的非严格模式，如果在严格模式，超过列长度的值将不会保存并出现错误提示。</p></blockquote><p><code>VARCHAR(4)</code>列显示的存储需求比实际字符长度多1，因为<code>VACHAR</code>要用1~2个字节要记录字节长度，低于255字节时使用一个，高于使用两个。（一个字节存储8位无符号数,储存的数值范围为0-255）</p><p>而不同的存储引擎对于两者的使用原则也有所不同：（个人认为造成使用原则不同的原因主要是两个存储方式不同，两种存储引擎都是基于<code>B+树</code>数据结构存储表数据的，但是区别在于<code>InnoDB</code>存储引擎中的<code>B+树</code>即存储了索引又存储了所有数据，而<code>MyISAM</code>中的<code>B+树</code>中只存储了数据的索引的Key值得地址，实际的数据存储在其他地方）</p><p><code>MyISAM</code>存储引擎：建议使用固定长度的数据列代替代替可变长度的数据列。</p><p><code>InnoDB</code>存储引擎：建议使用<code>VARCHAR</code>类型。对于<code>InnoDB</code>表，内部的行存储格式并没有区分固定长度和可变长度列（所有的数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的<code>CHAR</code>列不一定比使用可变长度的<code>VARCHAR</code>性能要好。因此，主要的性能因素都在行存储的数据量大小。由于<code>VARCHAR</code>的平均占用空间小于<code>CHAR</code>，因此使用<code>VARCHAR</code>来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。</p><h4 id="TEXT和BLOB"><a href="#TEXT和BLOB" class="headerlink" title="TEXT和BLOB"></a><code>TEXT</code>和<code>BLOB</code></h4><p><code>BLOB</code>主要用于保存一些二进制数据，比如照片；而<code>TEXT</code>只能保存字符数据。</p><p>但是这两种数据类型会引发一些性能问题，特别是执行过大量的删除操作后，会在数据表留下很大的数据“空洞”，以后填入这些空洞的记录在插入的性能上会有影响。可以通过执行<code>OPTIMIZE TABLE</code>对这类表进行碎片整理。</p><p>一般来说，不建议使用这两种数据类型，如果确实需要使用，建议将这两种数据类型分在不同的表中。这样会减少主表存储碎片，显著减少主表的数据量从而获得性能优势。</p><blockquote><p>优先使用<code>VARCHAR</code>类型，<code>VARCHAR</code>最长可以支持65533字节的长度，可以满足绝大多数需求。</p></blockquote><h4 id="浮点数和定点数"><a href="#浮点数和定点数" class="headerlink" title="浮点数和定点数"></a>浮点数和定点数</h4><p>当一个数据被定义为浮点数时，如果插入的数据精度超过该列定义的实际精度，则插入值会被四舍五入到实际精度。</p><p><strong>定点数实际上是以字符串形式存储的。</strong>所以定点数可以更精确地保存数据,因此在一些对数据精度要求比较高的场合（比如货币），一般使用定点数。</p><h2 id="索引设计和使用"><a href="#索引设计和使用" class="headerlink" title="索引设计和使用"></a>索引设计和使用</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>正确使用索引，是提高select操作性能的最佳途径。每种存储引擎对每个表至少支持16个索引，总索引的长度至少为256字节。</p><h3 id="索引在不同引擎中如何存储"><a href="#索引在不同引擎中如何存储" class="headerlink" title="索引在不同引擎中如何存储"></a>索引在不同引擎中如何存储</h3><p><code>InnoDB</code> 的表是根据主键进行展开的 B+tree 的聚集索引。<code>MyISAM </code>则为非聚集型索引，**<code>MyISAM</code> 存储会有两个文件，一个是索引文件，另外一个是数据文件，**其中索引文件中的索引指向数据文件中的表数据。</p><p>聚集型索引并不是一种单独的索引类型，而是一种存储方式，<code>InnoDB </code>聚集型索引实际上是在同一结构中保存了 B+tree 索引和数据行。当有聚簇索引时，<strong>它的索引实际放在叶子页中。</strong></p><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p>最适合索引的列是出现在<code>where</code>子句中的列，或连接子句中指定的列，而不是出现在select关键字后的选择列表中的列。</p><p>索引列的基数越大，索引的效果越好。比如出生日期具有不同值，很容易区分各行；而对于性别就两种值，不管搜索哪个值，都会得到一半的结果。</p><p>使用短索引。假如有一个CHAR(200)，如果前10或20个字符内，多数值都是唯一的，那么索引就只对前面具有唯一值的使用，能够节省大量索引空间。</p><p>利用最左前缀。见下一小节。</p><p>对于<code>InnoDB</code>的引擎，尽量手工指定主键。记录默认会按照一定的顺序保存，若有明确定义的主键，则按照主键顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个顺序去保存。按照主键或内部列进行访问是最快的，所以<code>InnoDB</code>表尽量指定主键。</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>在<code>MySQL</code>建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>要想理解联合索引的最左匹配原则，先来理解下索引的底层原理。索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p><p>举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子：</p><p><img src="https://img2020.cnblogs.com/blog/1804577/202005/1804577-20200521182659976-48843100.png" alt="https://img2020.cnblogs.com/blog/1804577/202005/1804577-20200521182659976-48843100.png"></p><p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为<code>MySQL</code>创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引。</p><h3 id="不可见索引"><a href="#不可见索引" class="headerlink" title="不可见索引"></a>不可见索引</h3><p><code>MySQL8.0</code>提供的不可见索引，是为了减小对于表上的索引进行调整时可能会带来的潜在风险。当删除一个你认为不再需要的索引时，一旦系统中还存在个别使用该索引的<code>SQL</code>，那么这些<code>SQL</code>的执行可能会转为全表扫描，严重的话可能直接击垮数据库。并且重建索引需要的时间和消耗的系统资源也会很大。</p><p>有了不可见索引，当需要删除一个表的冗余索引时，可能先将其设为不可见，一旦发现有负面影响，还可以快速恢复。</p><blockquote><p>参考引用：</p><p>[1] 最左匹配原则：<a href="https://www.cnblogs.com/ljl150/p/12934071.html">https://www.cnblogs.com/ljl150/p/12934071.html</a></p><p>[2] 深入浅出MySQL：数据库开发、管理和维护（第三版）</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <category domain="http://hznu.asia/tags/MySQL/">MySQL</category>
      
      
      <comments>http://hznu.asia/2022/03/06/MySQL%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL存储引擎</title>
      <link>http://hznu.asia/2022/03/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <guid>http://hznu.asia/2022/03/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <pubDate>Thu, 03 Mar 2022 12:05:53 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;存储引擎概述&quot;&gt;&lt;a href=&quot;#存储引擎概述&quot; class=&quot;headerlink&quot; title=&quot;存储引擎概述&quot;&gt;&lt;/a&gt;存储引擎概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;MySQL5.7&lt;/code&gt;版本支持的存储引擎有&lt;code&gt;InnoDB&lt;/code&gt;、&lt;co</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="存储引擎概述"><a href="#存储引擎概述" class="headerlink" title="存储引擎概述"></a>存储引擎概述</h3><p><code>MySQL5.7</code>版本支持的存储引擎有<code>InnoDB</code>、<code>MyISAM</code>、<code>MEMORY</code>、<code>CSV</code>、<code>BLACKHOLE</code>、<code>ARCHIVE</code>、<code>MERGE</code>、<code>FEDERATED</code>、<code>EXAMPLE</code>、<code>NDB</code>等。其中<code>InnoDB</code>和<code>NBDB</code>提供事务安全表，其他都是非事务安全表。</p><p>由于常见的存储引擎为<code>InnoDB</code>和<code>MyISAM</code>，所以本篇博客只讨论这两种存储引擎。</p><p>其实在此之前，我一直认为存储引擎是基于整个数据库而言的，比如说一个数据库只能设定成一种存储引擎，其实不是的。<strong>存储引擎是基于表级别的。</strong></p><p>在创建新表的时候，可以使用关键字<code>ENGINE</code>来设置新建表的存储引擎，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table A(</span><br><span class="line">...</span><br><span class="line">)ENGINE=MyISAM</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table B(</span><br><span class="line">...</span><br><span class="line">)ENGINE=InnoDB</span><br></pre></td></tr></table></figure><blockquote><p><strong>修改表的存储引擎需要锁表并复制数据，对于线上环境的表进行这个操作非常危险，除非你非常了解可能造成的影响</strong>。</p></blockquote><h3 id="各类存储引擎的特性"><a href="#各类存储引擎的特性" class="headerlink" title="各类存储引擎的特性"></a>各类存储引擎的特性</h3><table><thead><tr><th align="center">特点</th><th align="center">MyISAM</th><th align="center">InnoDB</th></tr></thead><tbody><tr><td align="center">B树索引</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">备份/时间点恢复</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">支持集群</td><td align="center">——</td><td align="center">——</td></tr><tr><td align="center">聚簇索引</td><td align="center">——</td><td align="center">支持</td></tr><tr><td align="center">数据压缩</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">数据缓存</td><td align="center">——</td><td align="center">支持</td></tr><tr><td align="center">数据加密</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">支持外键</td><td align="center">——</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">地理坐标数据类型</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">地理坐标索引</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">哈希索引</td><td align="center">——</td><td align="center">——</td></tr><tr><td align="center">索引缓存</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">锁粒度</td><td align="center">表级</td><td align="center">行级</td></tr><tr><td align="center">MVCC多版本控制</td><td align="center">——</td><td align="center">支持</td></tr><tr><td align="center">支持复制</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">存储限制</td><td align="center">256TB</td><td align="center">64TB</td></tr><tr><td align="center">T树索引</td><td align="center">——</td><td align="center">——</td></tr><tr><td align="center">支持事务</td><td align="center">——</td><td align="center">支持</td></tr><tr><td align="center">统计信息</td><td align="center">支持</td><td align="center">支持</td></tr></tbody></table><blockquote><p>聚簇索引：<a href="https://juejin.cn/post/6844903972843552781">https://juejin.cn/post/6844903972843552781</a></p></blockquote><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p><code>MyISAM</code>在某些场景中相对<code>InnoDB</code>的访问速度有明显优势，对事务完整性没有要求或以<code>Select</code>、<code>Insert</code>为主的应用可以使用这个引擎来创建表。</p><p><code>MyISAM</code>的表支持三种不同的存储格式：静态表、动态表、压缩表。</p><h5 id="静态表："><a href="#静态表：" class="headerlink" title="静态表："></a>静态表：</h5><p>静态表是默认存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多。</p><p>静态表的数据在存储时会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经丢掉。在保存数据的时候，如果某个要保存的内容前后后空格，那么在返回结果的时候会被去掉。</p><h5 id="动态表："><a href="#动态表：" class="headerlink" title="动态表："></a>动态表：</h5><p>动态表包含变长字段，记录不固定长度，这样存储的有点是占用空间相对较少，但是频繁地更新和删除记录会产生碎片，需要定期执行<code>OPTIMIZE TABLE</code>或<code>myisamchk-r</code>命令来改善性能，并且在出现故障时恢复相对比较困难。</p><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>该引擎具有提交、回滚和崩溃恢复能力地事务安全保障，同时提供了更小的锁粒度和更强地并发能力，拥有自己独立的缓存和日志，在<code>MySQL5.6</code>和<code>5.7</code>版本中性能有较大的提升。</p><p>相对<code>MyISAM</code>而言，<code>InnoDB</code>会占用更多的磁盘空间以保存数据和索引。但是在大多数情况下，<code>InnoDB</code>都是更好的选择。</p><h5 id="自动增长列"><a href="#自动增长列" class="headerlink" title="自动增长列"></a>自动增长列</h5><p><code>InnoDB</code>表的自动增长可以手工插入，但是如果插入的值为空，则实际插入的将是自动增长后的值。另外对于自动增长的值可以手动设置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter TABLE *** AUTO_INCREMENT=N</span><br></pre></td></tr></table></figure><p>在<code>MySQL8.0</code>之前，对于<code>InnoDB</code>引擎，这个值存在内存中，那么在数据库重启后，这个值便会丢失，数据库会自动将这个值重置为自增列当前存储最大值+1，可能会引起数据冲突。但是在<code>MySQL8.0</code>中这个Bug得到了修复，实现方式是将自增主键的计数器持久化到<code>REDO LOG</code>中，每次计数器发生改变，都会将其写入<code>REDO LOG</code>，重启后则会根据其中的信息来初始化其内存值。</p><p>对于<code>InnoDB</code>表，自动增长的列必须被索引。如果是组合索引，也必须是组合索引的第一列。但是对于<code>MyISAM</code>表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。</p><h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><p><code>MySQL</code>支持外键的只有<code>InnoDB</code>存储引擎，在创建外键时，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。</p><p>当某个表被其他表创建了外键参照，那么该表的对应索引或者主键禁止被删除。</p><blockquote><p>外键需要注意的细节较多，一旦使用不当，可能会带来性能下降或者数据不一致问题，需要慎用。</p></blockquote><h5 id="主键和索引"><a href="#主键和索引" class="headerlink" title="主键和索引"></a>主键和索引</h5><p>不同于其他存储引擎，<code>InnoDB</code>存储引擎的数据文件本身就是以聚簇索引的形式保存的，这个聚簇索引也被称为主索引，也是<code>InnoDB</code>的主键，<code>InnoDB</code>表的每行数据都保存在主索引的叶子节点上。因此，所有的<code>InnoDB</code>表都必须包含主键，若创建表的时候没有显示指定主键，那么<code>InnoDB</code>会自动创建一个长度为6个字节的<code>long</code>类型隐藏字段作为主键。</p><p>考虑到聚簇索引的特点和对于查询的优化效果，所有的<code>InnoDB</code>表都应该显示指定主键，一般来说，主键应该按照以下原则来选择：</p><ul><li>满足唯一和非空约束</li><li>优先考虑使用最经常被当作查询条件的字段或者自增字段</li><li>字段值基本不会被修改</li><li>使用尽可能短的字段</li></ul><p>在<code>InnoDB</code>表上，除了主键之外的其他索引都叫<code>二级索引</code>或<code>辅助索引</code>，二级索引会指向主索引，并通过主索引获取最终数据。因此，主键是否合理的创建，会对所有索引的效率产生影响。</p><h4 id="如何选择存储引擎"><a href="#如何选择存储引擎" class="headerlink" title="如何选择存储引擎"></a>如何选择存储引擎</h4><p><code>MyISAM</code>：如果应用是以读操作和插入操作为主，只有极少的更新和删除操作，并且对事务完整性没有要求、没有并发写操作，那么选择这个存储引擎是合适的。</p><p><code>InnoDB</code>: 对于大部分应用程序，都是更好的选择。它能有效地降低由于删除和更新导致的锁定，还可以保证事务完整提交和回滚。</p><blockquote><p><code>MyISAM</code>读和插入更优的原因：</p><p><a href="https://blog.csdn.net/weixin_39631572/article/details/110861044">https://blog.csdn.net/weixin_39631572/article/details/110861044</a></p><p><a href="https://www.xttblog.com/?p=3859">https://www.xttblog.com/?p=3859</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <category domain="http://hznu.asia/tags/MySQL/">MySQL</category>
      
      
      <comments>http://hznu.asia/2022/03/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java设计模式--单例模式</title>
      <link>http://hznu.asia/2022/02/23/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <guid>http://hznu.asia/2022/02/23/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <pubDate>Wed, 23 Feb 2022 13:20:23 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;写在前面：&lt;strong&gt;线程安全&lt;/strong&gt;就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。      &lt;/p&gt;
&lt;p&gt;&lt;s</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>写在前面：<strong>线程安全</strong>就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。      </p><p><strong>线程不安全</strong>就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p></blockquote><p>单例模式有八种方式，其中完美无缺的有两种。</p><p>但是实际工作中不一定用的是完美无缺的。</p><h4 id="第一种：饿汉式"><a href="#第一种：饿汉式" class="headerlink" title="第一种：饿汉式"></a>第一种：饿汉式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Mg01 &#123;</span><br><span class="line">    public static final Mg01 INSTANCE = new Mg01();</span><br><span class="line"></span><br><span class="line">    private Mg01() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    public Mg01 getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类加载到内存后,就实例化一个单例,JVM保证线程安全简单实用,推荐实用!</p><p>唯一缺点:不管用到与否,类装载时就完成实例化(话说你不用的,你装载它干啥)</p><blockquote><p>这样写，由于Mgr01被private修饰，故不能够再new一个新的Mgr01，如果要一个新的，只能够调用getInstance方法，注意看getInstance，return的是一个INSTANCE，就是上面被final修饰的实例化的对象名，意思就是无论你调用多少次，返回的都是被final修饰的那个对象</p></blockquote><h4 id="第二种：懒汉式"><a href="#第二种：懒汉式" class="headerlink" title="第二种：懒汉式"></a>第二种：懒汉式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Mg02 &#123;</span><br><span class="line">    public static Mg02 INSTANCE = new Mg02();</span><br><span class="line"></span><br><span class="line">    private Mg02() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public Mg02 getInstance()&#123;</span><br><span class="line">        if (INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new  Mg02();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先声明但是没有初始化，在getInstance方法里面，先判断是否存在该实例对象，如果不存在，则创建，存在则返回该实例，从而保证单例。</p><p>这里定义时不能加final，因为用final修饰就必须初始化</p><p>但是会有线程不安全的问题，可能两个线程在没到return前创建了两个实例，此时两个是不同的实例，那么就无法保证是单例的了。</p><h4 id="第四种：用锁（效率下降）"><a href="#第四种：用锁（效率下降）" class="headerlink" title="第四种：用锁（效率下降）"></a>第四种：用锁（效率下降）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Mg03 &#123;</span><br><span class="line">    public static Mg03 INSTANCE = new Mg03();</span><br><span class="line"></span><br><span class="line">    private Mg03() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized Mg03 getInstance()&#123;</span><br><span class="line">        if (INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new  Mg02();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第五种：静态内部类"><a href="#第五种：静态内部类" class="headerlink" title="第五种：静态内部类"></a>第五种：静态内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Mg03 &#123;</span><br><span class="line">    private static class Mg03Holder &#123;</span><br><span class="line">        public static final Mg03 INSTANCE = new Mg03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Mg03() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    public Mg03 getInstance()&#123;</span><br><span class="line">        return Mg03Holder.INSTANCE;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个线程安全是由<code>jvm</code>保证的，<code>jvm</code>加载类的时候只加载一次，所以<code>Mg03Holder</code>和<code>getInstance</code>也只加载一次，从而保证线程安全。</p><h4 id="第六种：枚举（完美写法）"><a href="#第六种：枚举（完美写法）" class="headerlink" title="第六种：枚举（完美写法）"></a>第六种：枚举（完美写法）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Mg04 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法无法被反序列化的原因：java的反射可以通过一个class文件把整个class加载到内存，再通过反序列化new一个新的类。实际中想阻挡这种写法需要设置内部变量，很复杂。</p><p>而枚举单例无法被反序列化，因为枚举类没有构造方法，所以拿到class文件也无法构造对象。如上图中反序列化之后返回的值是INSTANCE,如果根据这个值创建对象的话，那么这个对象和我们单例里创建的是同一个对象，所以严格讲这个是最完美的方法。</p><p><strong>综合来看，一般都用第一种就行</strong></p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/Java/">Java</category>
      
      
      <category domain="http://hznu.asia/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <comments>http://hznu.asia/2022/02/23/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库锁的基本原理</title>
      <link>http://hznu.asia/2022/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</link>
      <guid>http://hznu.asia/2022/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</guid>
      <pubDate>Tue, 22 Feb 2022 12:45:02 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;数据库系统的锁的基本原理&quot;&gt;&lt;a href=&quot;#数据库系统的锁的基本原理&quot; class=&quot;headerlink&quot; title=&quot;数据库系统的锁的基本原理&quot;&gt;&lt;/a&gt;数据库系统的锁的基本原理&lt;/h3&gt;&lt;p&gt;锁的基本原理如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当一个事务访问</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="数据库系统的锁的基本原理"><a href="#数据库系统的锁的基本原理" class="headerlink" title="数据库系统的锁的基本原理"></a>数据库系统的锁的基本原理</h3><p>锁的基本原理如下：</p><ol><li>当一个事务访问某种数据库资源时，如果执行select语句，必须先获得的共享锁；如果执行insert，update或delete语句，必须获得独占锁。这些锁用于锁定被操纵的资源。</li><li>当第二个事务也要访问某种相同资源时，如果执行select语句，也必须获得的共享锁；如果执行insert，update或delete语句，必须获得独占锁。此时根据已经放置在资源上的锁的类型，来决定第二个事务到底是应该等待第一个事务解除对资源的锁定，还是可以立刻获得锁。</li></ol><table><thead><tr><th align="center">资源上已经放置的锁</th><th align="center">第二个事务进行读操作</th><th align="center">第二个事务进行更新操作</th></tr></thead><tbody><tr><td align="center">无</td><td align="center">立即获得共享锁</td><td align="center">立即获得独占锁</td></tr><tr><td align="center">共享锁</td><td align="center">立即获得共享锁</td><td align="center">等待第一个事务解除共享锁</td></tr><tr><td align="center">独占锁</td><td align="center">等待第一个事务接触独占锁</td><td align="center">等待第一个事务解除独占锁</td></tr></tbody></table><p>许多数据库系统都有自动管理锁的功能，它们能根据事务执行的SQL语句,自动在保证事务间的隔离性与保证事务间的并发性能之间做出权衡，然后自动为数据库资源加上当的锁在运行期间还会自动升级锁的类型,以优化系统的性能。多个事务的并发性能是指数据库系统能够同时执行多个事务的能力，很少出现因为一个事务占用了特定资源，而导到其他事务必须暂停下来长时间等待资源的情况。</p><p>对于普通的并发性事务,通过数据库系统的自动锁定管理机制基本可以保证事务之间</p><h4 id="锁的多粒度性及自动锁升级"><a href="#锁的多粒度性及自动锁升级" class="headerlink" title="锁的多粒度性及自动锁升级"></a>锁的多粒度性及自动锁升级</h4><p>数据库系统能够锁定的资源包括数据库、表、区域、页面、键值(指带有索引的行数据)和行(即表中的单行数据)。按照锁定资源的粒度,锁可以分为以下类型。</p><ol><li>数据库级锁:锁定整个数据库。</li><li>表级锁:锁定一张数据库表。</li><li>区域级锁:锁定数据库的特定区域。</li><li>页面级锁:锁定数据库的特定页面。</li><li>键值级锁:锁定数据库表中带有索引的一行数据。</li><li>行级锁:锁定数据库表中的单行数据(即一条记录)。</li></ol><p>锁的封锁粒度越大,事务间的隔离性就越高，但是事务间的并发性能就越低。数据库系统根据事务执行的SQL语句，自动对访问的数据资源加上合适的锁。假设某事务只操纵一个表中的部分行数据,系统可能只会添加几个行锁或页面锁，这样可以尽可能多地支持多个事务的并发操作。</p><p>但是,如果某个事务频繁地对某个表中的多条记录进行操作，将对该表的许多记录行都加上行级锁,数据库系统中锁的数目会急剧增加，这就加重了系统负荷，影响系统性能。因此,在数据库系统中,一般都支持锁升级。锁升级是指调整锁的粒度，将多个低粒度的锁替换成少数更高粒度的锁,以此来降低系统负荷。例如,当一个事务中的锁较多,达到锁升级门限时,系统自动将行级锁和页面级锁升级为表级锁。</p><h4 id="锁的类型和兼容性"><a href="#锁的类型和兼容性" class="headerlink" title="锁的类型和兼容性"></a>锁的类型和兼容性</h4><h5 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a><strong>共享锁</strong></h5><p>共享锁用于读数据操作，它是非独占的，允许其他事务同时读取其锁定的资源，但不允许其他事务更新它。共享锁具有以下特征：</p><ul><li>加锁的条件：当一个事务执行select语句时，数据库系统会为这个事务分配一把共享锁，来锁定被查询的数据。</li><li>解锁的条件：在默认情况下，数据被读取后，数据库系统会立即接触共享锁。例如，当一个事务执行查询语句（select * from account）时，数据库系统会先锁定第一行，读取之后，解除对第一行的锁定，然后锁定第二行。这样，在一个事务读操作过程中，允许其他食物同时更新account表中未被锁定的行。</li><li>与其他锁的兼容性：如果数据资源上放置了共享锁，还能再放置共享锁和更新锁。</li><li>并发性能：共享锁具有良好的并发性能。当多个事务读相同的数据时，每个事务都会获得一把共享锁，因此可以同时读锁定的数据。</li></ul><h5 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a><strong>独占锁</strong></h5><p>也称为排他锁，适用于修改数据的场合。它锁定的资源，其他事务不能读取和修改。独占锁具有以下特征：</p><ul><li>加锁的条件：当一个事务执行insert，update或delete语句时，数据库系统会自动对SQL语句操纵的数据资源使用独占锁。如果该数据资源已经有其他锁存在时，无法对其再放置独占锁。</li><li>解锁的条件：独占锁一直到事务结束才能被解除。</li><li>兼容性：独占锁不能和其他锁兼容，如果数据资源上已经加了独占锁，就不能再放置其他锁。同样，如果数据资源上已经有了其他锁，也不能再放置独占锁。</li><li>并发性能：独占锁的并发性能比较差，只允许有一个事务访问锁定的数据，如果有其他事物也需要访问该数据，就必须等待，直到前一个事务结束，解除了独占锁，其他事务才有机会访问该数据。</li></ul><h5 id="更新锁"><a href="#更新锁" class="headerlink" title="更新锁"></a><strong>更新锁</strong></h5><p>在更新操作的初始化阶段用来锁定可能要被修改的资源，这可以避免使用共享锁造成的死锁现象。例如对于以下的语句：</p><p>update account set balance = 90 where id = 1;</p><p>如果使用共享锁，更新操作分为两步：</p><ol><li>获得一个共享锁，读取 <code>account</code> 表中id为1的记录；</li><li>将共享锁升级为独占锁，再执行更新操作。</li></ol><p><strong>如果同时有两个或多个事务同时更新数据，每个事务都先获得一把共享锁,在更新数据的时候，这些事务都要先将共享锁升级为独占锁。由于独占锁不能与其他锁兼容,因此每事务都进入等待状态,等待其他事务释放共享锁,这就造成了死锁。</strong></p><p>如果使用更新锁,更新数据的操作分为以下两步：</p><ol><li>获得一个更新锁,读取 ACCOUNTS表中ID为1的记录。</li><li>将更新锁升级为独占锁,再执行更新操作。</li></ol><p>更新锁具有以下特征：</p><ul><li>加锁的条件：当一个事务执行update语句时，数据库系统会先为事务分配一把新锁。</li><li>解锁的条件：当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁，</li><li><strong>与其他锁的兼容性：更新锁与共享锁是兼容的，也就是说，一个资源可以同时放更新锁和共享锁，但是最多只能放置一把更新锁。这样，当多个事务更新相同的数据时有一个事务能获得更新锁，然后再把更新锁升级为独占锁,其他事务必须等到前一个事务结束后,才能获得更新锁,这就避免了死锁。</strong></li><li>并发性能：允许多个事务同时读锁定的资源,但不允许其他事务修改它。</li></ul><h4 id="死锁及其防治办法"><a href="#死锁及其防治办法" class="headerlink" title="死锁及其防治办法"></a>死锁及其防治办法</h4><p>多数据库系统能够自动定期搜索和处理死锁问题。当检测到锁定请求环时,系统将结束死锁优先级最低的事务,并且撤销该事务。</p><p>理解了死锁的概念,在应用程序中可以采用下面的一些方法来尽量避免死锁。</p><ol><li>合理安排对数据库表的访问顺序。</li><li>使用短事务。</li><li>如果对数据的一致性要求不是很高，可以允许脏读。脏读不需要对数据资源加锁，可以避免锁冲突。</li><li>如果可能的话,错开多个事务访问相同数据资源的时间,以防止锁冲突。</li><li>使用尽可能低的事务隔离级别。隔离级别过高，虽然系统可以因此提供更好的隔离性而更大程度上保证数据的完整性和一致性，但各事务间死锁的机会大大增加,反而影响了系统性能。</li></ol><p>短事务是指在一个数据库事务中包含尽可能少的操作，并且在尽可能短的时间内完成事务不仅能避免死锁，而且能提高事务间的并发性能。因为如果一个事务锁定了某种资源,由于这个事务很快就结束,因此不会长时间锁定资源,其他事务也就不需要长时间等待前一个事务解除对资源的锁定。</p><p>为了实现短事务,在应用程序中可以考虑使用以下策略。</p><ol><li>如果可能的话,尝试把大的事务分解为多个小的事务,然后分别执行。这可以保证每个小事务都很快完成,不会对数据资源锁定很长时间。</li><li>应该在处理事务前就准备好用户必须提供的数据,不应该在执行事务过程中,停下来长时间等待用户输入。以取款事务为例,应该在开始取款事务之前,就明确客户的取款数额,这使得取款事务不用中途停下来等待用户输入。</li></ol>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      
      <comments>http://hznu.asia/2022/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>精通JPA与Hibernate:对象持久化技术详解--摘录与理解</title>
      <link>http://hznu.asia/2022/02/22/%E7%B2%BE%E9%80%9AJPA%E4%B8%8EHibernate-%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3-%E6%91%98%E5%BD%95%E4%B8%8E%E7%90%86%E8%A7%A3/</link>
      <guid>http://hznu.asia/2022/02/22/%E7%B2%BE%E9%80%9AJPA%E4%B8%8EHibernate-%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3-%E6%91%98%E5%BD%95%E4%B8%8E%E7%90%86%E8%A7%A3/</guid>
      <pubDate>Tue, 22 Feb 2022 03:28:01 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-包装类与基本类型的区别&quot;&gt;&lt;a href=&quot;#1-包装类与基本类型的区别&quot; class=&quot;headerlink&quot; title=&quot;1. 包装类与基本类型的区别&quot;&gt;&lt;/a&gt;1. 包装类与基本类型的区别&lt;/h3&gt;&lt;p&gt;一直以来对于这两者没有很清晰的认识，但是在本书中</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-包装类与基本类型的区别"><a href="#1-包装类与基本类型的区别" class="headerlink" title="1. 包装类与基本类型的区别"></a>1. 包装类与基本类型的区别</h3><p>一直以来对于这两者没有很清晰的认识，但是在本书中某一段给了我启示。</p><p>Java有8种基本类型，分别是byte, short, char, int, long, float, double 和 boolean。与此对应，Java提供了8种包装类型Byte, Short, Character, Integer, Long, Float, Double 和 Boolean。</p><p>基本类型的缺点在于无法表达null值。所有基本类型的默认值都不是null，如数字类型默认值是0。在一些场合是可以用基本类型的默认值来表示属性值是未知的。比如对于年龄，如果属性为0，可以表示是未知的，但是有些场合则不行。</p><p>比如对于成绩属性，有些成绩可能是未知的，这时候不能用0表示，因为0也是一个具有实际意义的分数，此时就需要用到包装类。</p><h3 id="2-数据库事务"><a href="#2-数据库事务" class="headerlink" title="2. 数据库事务"></a>2. 数据库事务</h3><p>之前一直对ACID特性有了解，可是看过之后总是容易忘，可能是没有真正理解。本书中我感觉解释的不错：</p><h5 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h5><p>指整个数据库事务是不可分割的工作单元。只有事务中所有的操作执行成功，才能算整个事务成功；事务中任何一个sql语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该回到执行事务前的状态。</p><h5 id="一致性："><a href="#一致性：" class="headerlink" title="一致性："></a>一致性：</h5><p>指数据库事务不能破坏关系数据的完整性以及业务逻辑的一致性。例如银行转账事务，不管事务成功还是失败，应该保证事务结束后表中数据一致。例如A和B在数据库种存款总额为2000，那么执行完成后，总额依然为2000.</p><h5 id="隔离性："><a href="#隔离性：" class="headerlink" title="隔离性："></a>隔离性：</h5><p>在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。</p><h5 id="持久性："><a href="#持久性：" class="headerlink" title="持久性："></a>持久性：</h5><p>指的是只要事务成功结束，它对数据库所做的更改必须永久保存下来，即使发生系统崩溃，重新启动数据库系统后，数据库仍能恢复到事务成功结束时的状态。</p><p>事务的ACID特性是由数据库系统来实现的。数据库系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新操作，如果某个事物在执行过程中发生错误，就可以根据日志撤销事务对数据库已做的更改操作。</p><p>数据库系统采用锁机制来实现事物的隔离性，当多个事务同时更新数据库中相同数据时，只允许持有锁的事务能够更新数据，其他事务必须等待，直到其释放锁。</p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E9%9A%8F%E7%AC%94/">随笔</category>
      
      
      <category domain="http://hznu.asia/tags/%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF/">对象持久化技术</category>
      
      
      <comments>http://hznu.asia/2022/02/22/%E7%B2%BE%E9%80%9AJPA%E4%B8%8EHibernate-%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3-%E6%91%98%E5%BD%95%E4%B8%8E%E7%90%86%E8%A7%A3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>阅读Spring文档摘录</title>
      <link>http://hznu.asia/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/</link>
      <guid>http://hznu.asia/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/</guid>
      <pubDate>Wed, 26 Jan 2022 03:33:32 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;这篇博客是我在阅读 Spring 英文文档过程中记录的对 Spring 的新认知，或者说是之前比较模糊的概念。总而言之，算是我个人的随笔记录，方便以后查看，如果感觉对你帮助不大，可以跳过不看本篇博客。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 i</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>这篇博客是我在阅读 Spring 英文文档过程中记录的对 Spring 的新认知，或者说是之前比较模糊的概念。总而言之，算是我个人的随笔记录，方便以后查看，如果感觉对你帮助不大，可以跳过不看本篇博客。</p></blockquote><h3 id="1-Container-Overview"><a href="#1-Container-Overview" class="headerlink" title="1. Container Overview"></a>1. Container Overview</h3><p>The <code>org.springframework.context.ApplicationContext</code> interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects.</p><p>applicationcontext接口表示Spring IoC容器，并负责实例化、配置和组装bean。容器通过读取配置元数据来获取关于实例化、配置和组装哪些对象的指令。配置元数据以XML、Java注释或Java代码表示。它允许您表达组成应用程序的对象以及这些对象之间的丰富的相互依赖关系。</p><h3 id="2-Configuration-Metadata"><a href="#2-Configuration-Metadata" class="headerlink" title="2. Configuration Metadata"></a>2. Configuration Metadata</h3><p>For information about using other forms of metadata with the Spring container, see:</p><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config">Annotation-based configuration</a>: Spring 2.5 introduced support for annotation-based configuration metadata.</li><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java">Java-based configuration</a>: Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus, you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html"><code>@Import</code></a>, and <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html"><code>@DependsOn</code></a> annotations.</li></ul><p>Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata configures these beans as <code>&lt;bean/&gt;</code> elements inside a top-level <code>&lt;beans/&gt;</code> element. Java configuration typically uses <code>@Bean</code>-annotated methods within a <code>@Configuration</code> class.</p><p>这段我认为需要理解好最后一句话：Java 配置通常在@Configuration 类中使用@Bean 注释的方法。</p><blockquote><p> Spring3.0开始，@Configuration用于定义配置类，定义的配置类可以替换xml文件，一般和@Bean注解联合使用。@Configuration注解主要标注在某个类上，相当于xml配置文件中的<beans>@Bean注解主要标注在某个方法上，相当于xml配置文件中的<bean></bean></beans></p></blockquote><p><img src="/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/development\myblog\source_posts\阅读Spring文档摘录\202004161021529.png" alt="D:\development\myblog\source\_posts\阅读Spring文档摘录\202004161021529.png"></p><h4 id="2-1-the-basic-structure-of-XML-based-configuration-metadata"><a href="#2-1-the-basic-structure-of-XML-based-configuration-metadata" class="headerlink" title="2.1 the basic structure of XML-based configuration metadata"></a>2.1 the basic structure of XML-based configuration metadata</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;  </span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ul><li>The <code>id</code> attribute is a string that identifies the individual bean definition.</li><li>The <code>class</code> attribute defines the type of the bean and uses the fully qualified classname.</li></ul><h3 id="3-Composing-XML-based-Configuration-Metadata"><a href="#3-Composing-XML-based-Configuration-Metadata" class="headerlink" title="3. Composing XML-based Configuration Metadata"></a>3. Composing XML-based Configuration Metadata</h3><p>It can be useful to have bean definitions span multiple XML files. Often, each individual XML configuration file represents a logical layer or module in your architecture.</p><p>You can use the application context constructor to load bean definitions from all these XML fragments. This constructor takes multiple <code>Resource</code> locations, as was shown in the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-instantiation">previous section</a>. Alternatively, use one or more occurrences of the <code>&lt;import/&gt;</code> element to load bean definitions from another file or files. The following example shows how to do so:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;import resource=&quot;services.xml&quot;/&gt;</span><br><span class="line">    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;</span><br><span class="line">    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>In the preceding example, external bean definitions are loaded from three files: <code>services.xml</code>, <code>messageSource.xml</code>, and <code>themeSource.xml</code>. <strong>All location paths are relative to the definition file doing the importing, so <code>services.xml</code> must be in the same directory or classpath location as the file doing the importing, while <code>messageSource.xml</code> and <code>themeSource.xml</code> must be in a <code>resources</code> location below the location of the importing file.</strong> As you can see, a leading slash is ignored. However, given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level <code>&lt;beans/&gt;</code> element, must be valid XML bean definitions, according to the Spring Schema.</p><p>上述内容主要就是描述了XML如何定义，其中黑体字标出的相对重要些：<strong>所有的位置路径都是相对于执行导入的定义文件的，因此services.xml必须与执行导入的文件位于相同的目录或类路径位置，而messageSource.xml和themeSource.xml必须位于导入文件位置下方的资源位置。</strong></p><blockquote><p>It is possible, but not recommended, to reference files in parent directories using a relative “../“ path. Doing so creates a dependency on a file that is outside the current application. In particular, this reference is not recommended for <code>classpath:</code> URLs (for example, <code>classpath:../services.xml</code>), where the runtime resolution process chooses the “nearest” classpath root and then looks into its parent directory. Classpath configuration changes may lead to the choice of a different, incorrect directory.</p><p>You can always use fully qualified resource locations instead of relative paths: for example, <code>file:C:/config/services.xml</code> or <code>classpath:/config/services.xml</code>. However, be aware that you are coupling your application’s configuration to specific absolute locations. It is generally preferable to keep an indirection for such absolute locations — for example, through “${…}” placeholders that are resolved against JVM system properties at runtime.</p></blockquote><blockquote><p>上述大概意思就是不推荐使用 “../” 这种形式的路径配置，这样做会在当前应用程序之外的文件上创建一个依赖项。特别是不建议<code>classpath:</code> URLs (比如 <code>classpath:../services.xml</code>) 这种形式的引用，运行时解析进程选择“最近的”类路径根，然后查看其父目录。</p><p>可以使用完全限定的资源位置而不是绝对位置: 比如  <code>file:C:/config/services.xml</code> 或者<code>classpath:/config/services.xml</code>。但是，请注意，您正在将应用程序的配置耦合到特定的绝对位置。对于这种绝对位置，通常更可取的做法是保持间接性ーー例如，通过在运行时根据 JVM 系统属性解析的“ ${ … }”占位符。</p></blockquote><h3 id="4-Naming-Beans"><a href="#4-Naming-Beans" class="headerlink" title="4. Naming Beans"></a>4. Naming Beans</h3><p>Every bean has one or more identifiers. These identifiers must be unique within the container that hosts the bean. A bean usually has only one identifier. However, if it requires more than one, the extra ones can be considered aliases.</p><p>In XML-based configuration metadata, you use the <code>id</code> attribute, the <code>name</code> attribute, or both to specify the bean identifiers. The <code>id</code> attribute lets you specify exactly one id. </p><p>The convention is to use the standard Java convention for instance field names when naming beans. That is, bean names start with a lowercase letter and are camel-cased from there. Examples of such names include <code>accountManager</code>, <code>accountService</code>, <code>userDao</code>, <code>loginController</code>, and so forth.</p><p>Naming beans consistently makes your configuration easier to read and understand. <strong>Also, if you use Spring AOP, it helps a lot when applying advice to a set of beans related by name.</strong></p><p>With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules described earlier: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved. These are the same rules as defined by <code>java.beans.Introspector.decapitalize</code> (which Spring uses here).</p><p>上述前两段主要就是描述每个 bean 都有一个或多个标识符。这些标识符在承载 bean 的容器中必须是唯一的。一个 bean 通常只有一个标识符。但是，如果它需要多于一个，那么额外的那些可以被认为是别名。Bean的命名方式通常有 <code>id</code> 和 <code>name</code> 命名，</p><p>中间两段主要介绍了并推荐使用驼峰命名。<strong>但是这部分最后一句加粗的文字目前我并不理解，暂且搁置。</strong></p><p>最后一段描述通过在类路径中进行组件扫描，Spring 为未命名的组件生成 bean 名称，遵循前面描述的规则: 本质上，使用简单的类名并将其初始字符转换为小写。<strong>但是，在(不寻常的)特殊情况下，当有多个字符且第一个和第二个字符都是大写字母时，原始大小写将得到保留。这些规则与 java.beans 定义的规则相同。</strong>这部分加粗文字和Java内省机制相关类 <code>Introspector</code> 有关，其中该类相关源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static String decapitalize(String name) &#123;</span><br><span class="line">        if (name == null || name.length() == 0) &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        if (name.length() &gt; 1 &amp;&amp; Character.isUpperCase(name.charAt(1)) &amp;&amp;</span><br><span class="line">                        Character.isUpperCase(name.charAt(0)))&#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        char chars[] = name.toCharArray();</span><br><span class="line">        chars[0] = Character.toLowerCase(chars[0]);</span><br><span class="line">        return new String(chars);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般情况下，把字符串第一个字母变为小写，如把“FooBah”变为“fooBah”。但在特殊情况下，即字符串前两个字母都是大写的时候，什么也不做，如，遇到“URL”，原样返回。</p><p>decapitalize()的bug是：如果一个字符串，前两个字母大写，但后面还有小写字母，它仍然返回原字符串！</p><p>Hibernate的开发者注意到decapitalize()的特点，所以才在判断语句中使用一个或运算(不然只需要判断方法名截掉“get”，再改第一个字母为小写后的字符串与属性名是否相等即可，这也是按照JavaBean Specification定义的标准做法)。但是，Hibernate没有解决这个bug，可能是他们没有碰到我遇到的情况。</p><p>类似sAddress(一般性地说，第一个字母小写，第二个字母大写)属性命名就是bug的诱因。</p><p>那么，解决方法有三种：</p><p>把属性名改成SAddress，这样就满足上面匹配判断的第二个条件(方法名截掉“get”后，与属性名匹配)。但是，这样做不符合Java命名规范；</p><p>把getSAddress()改成getsAddress()，这样也满足上面匹配判断的第二个条件(方法名截掉“get”后，与属性名匹配)。但是，这样做不符合JavaBean命名规范；</p><p>把属性名改成strAddress，并形成一种约定：命名属性时，第二个字符只能是小写字母。这个方法不需要做更多地修改，符合所有规范，最为稳妥。</p></blockquote><h4 id="4-1-Aliasing-a-Bean-outside-the-Bean-Definition"><a href="#4-1-Aliasing-a-Bean-outside-the-Bean-Definition" class="headerlink" title="4.1 Aliasing a Bean outside the Bean Definition"></a>4.1 Aliasing a Bean outside the Bean Definition</h4><p>子系统 a 的配置元数据可以通过 subsystemA-DataSource 的名称引用 DataSource。子系统 b 的配置元数据可以通过 subsystemB-DataSource 的名称来引用 DataSource。当组合使用这两个子系统的主应用程序时，主应用程序通过 myapp-DataSource 的名称引用 DataSource。要让所有三个名称都指向同一个对象，可以向配置元数据添加以下别名定义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt;</span><br><span class="line">&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;</span><br></pre></td></tr></table></figure><p>现在，每个组件和主应用程序都可以通过一个惟一的名称引用 dataSource，并保证不会与任何其他定义发生冲突(有效地创建名称空间) ，但它们引用的是同一个 bean。</p><blockquote><p>If you use Javaconfiguration, the <code>@Bean</code> annotation can be used to provide aliases. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-bean-annotation">Using the <code>@Bean</code> Annotation</a> for details.</p></blockquote><h4 id="4-2-Instantiation-with-a-Static-Factory-Method（用静态工厂方法实例化）"><a href="#4-2-Instantiation-with-a-Static-Factory-Method（用静态工厂方法实例化）" class="headerlink" title="4.2 Instantiation with a Static Factory Method（用静态工厂方法实例化）"></a>4.2 Instantiation with a Static Factory Method（用静态工厂方法实例化）</h4><p>调用这个方法(带有可选参数，如后面所述)并返回一个活动对象，随后该对象将被视为通过构造函数创建的。这种 bean 定义的一个用途是在遗留代码中调用静态工厂。</p><p>下面的 bean 定义指定通过调用 factory 方法创建 bean。该定义不指定返回对象的类型(类) ，只指定包含工厂方法的类。在本例中，createInstance ()方法必须是静态方法。下面的示例演示如何指定工厂方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    class=&quot;examples.ClientService&quot;</span><br><span class="line">    factory-method=&quot;createInstance&quot;/&gt;</span><br></pre></td></tr></table></figure><p>下面的示例展示了一个与前面的 bean 定义一起工作的类:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ClientService &#123;</span><br><span class="line">    private static ClientService clientService = new ClientService();</span><br><span class="line">    private ClientService() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static ClientService createInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>遗留代码: Legacy Code</p><p>遗留代码是指不再受支持的应用程序系统源代码类型。遗留代码也可以指不支持的操作系统、硬件和格式。在大多数情况下，遗留代码被转换为现代软件语言和平台。然而，为了保留熟悉的用户功能，遗留代码有时会被带入新的环境中。</p></blockquote><blockquote><p>这里可以参考我的另一篇博客来理解静态工厂方法创建对象：<a href="https://hznu.asia/2022/01/13/Effective-Java-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/">Effective Java–创建和销毁对象</a></p></blockquote><h4 id="4-3-Instantiation-by-Using-an-Instance-Factory-Method-（使用实例工厂方法实例化）"><a href="#4-3-Instantiation-by-Using-an-Instance-Factory-Method-（使用实例工厂方法实例化）" class="headerlink" title="4.3 Instantiation by Using an Instance Factory Method （使用实例工厂方法实例化）"></a>4.3 Instantiation by Using an Instance Factory Method （使用实例工厂方法实例化）</h4><p>与通过静态工厂方法进行的实例化类似，使用实例工厂方法进行的实例化，从容器中调用现有 bean 的非静态方法来创建新 bean。要使用这种机制，保留 class 属性为空，并在 factory-bean 属性中，在当前(或父或祖先)容器中指定 bean 的名称，该容器包含要调用来创建对象的实例方法。使用 factory-method 属性设置 factory 方法本身的名称。下面的例子展示了如何配置这样一个 bean:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span><br><span class="line">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;</span><br><span class="line">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- the bean to be created via the factory bean --&gt;</span><br><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createClientServiceInstance&quot;/&gt;</span><br></pre></td></tr></table></figure><p>下面的示例展示了相应的类:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultServiceLocator &#123;</span><br><span class="line"></span><br><span class="line">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    public ClientService createClientServiceInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个工厂类也可以容纳多个工厂方法，如下面的示例所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;</span><br><span class="line">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createClientServiceInstance&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;accountService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createAccountServiceInstance&quot;/&gt;</span><br></pre></td></tr></table></figure><p>下面的示例展示了相应的类:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultServiceLocator &#123;</span><br><span class="line"></span><br><span class="line">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    private static AccountService accountService = new AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    public ClientService createClientServiceInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AccountService createAccountServiceInstance() &#123;</span><br><span class="line">        return accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法表明，工厂 bean 本身可以通过依赖注入管理器(DI)来管理和配置。详见<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-properties-detailed">依赖关系和配置</a>。</p><blockquote><p>在 Spring 文档中，”factory bean” 指的是在 Spring 容器中配置并通过实例或静态工厂方法创建对象的 bean。相比之下，FactoryBean (注意大写)引用了一个 spring 特定的 FactoryBean 实现类。</p></blockquote><h4 id="4-4-Determining-a-Bean’s-Runtime-Type"><a href="#4-4-Determining-a-Bean’s-Runtime-Type" class="headerlink" title="4.4 Determining a Bean’s Runtime Type"></a>4.4 Determining a Bean’s Runtime Type</h4><p>确定特定 bean 的运行时类型并不简单。Bean 元数据定义中的指定类仅仅是一个初始类引用，它可能与已声明的工厂方法或 FactoryBean 类结合在一起，后者可能导致 bean 的不同运行时类型，或者在实例级工厂方法(可以通过指定的工厂 bean 名称解析)的情况下根本不设置类。此外，AOP 代理可以使用基于接口的代理来包装 bean 实例，对目标 bean 的实际类型(仅仅是实现的接口)进行有限的公开。</p><p>查找特定 bean 的实际运行时类型的推荐方法是 BeanFactory.getType 调用指定的 bean 名称。这将考虑上述所有情况，并返回 BeanFactory.getBean 调用将返回的对象类型。</p><h3 id="5-Dependencies"><a href="#5-Dependencies" class="headerlink" title="5. Dependencies"></a>5. Dependencies</h3><h4 id="5-1-Constructor-Argument-Resolution"><a href="#5-1-Constructor-Argument-Resolution" class="headerlink" title="5.1 Constructor Argument Resolution"></a>5.1 <strong>Constructor Argument Resolution</strong></h4><p>使用参数的类型进行构造函数参数解析匹配。如果 bean 定义的构造函数参数中没有潜在的歧义，那么在 bean 定义中定义构造函数参数的顺序就是在 bean 被实例化时这些参数被提供给相应的构造函数的顺序。参考下面的类:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ThingOne &#123;</span><br><span class="line"></span><br><span class="line">    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 ThingTwo 和 thingThree类<strong>不通过继承关联</strong>，则不存在潜在的歧义。因此，下面的配置可以很好地工作，不需要在 &lt; constructor-arg/&gt; 元素中显式地指定构造函数参数索引或类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;beanTwo&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;beanThree&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>当引用另一个 bean 时，该类型是已知的，并且可以进行匹配(与前面的示例一样)。当使用简单类型时，如 <code>&lt; value &gt; true &lt;/value&gt;</code> ，Spring 无法确定值的类型，因此在没有帮助的情况下无法按类型进行匹配。参考下面的类:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    // Number of years to calculate the Ultimate Answer</span><br><span class="line">    private final int years;</span><br><span class="line"></span><br><span class="line">    // The Answer to Life, the Universe, and Everything</span><br><span class="line">    private final String ultimateAnswer;</span><br><span class="line"></span><br><span class="line">    public ExampleBean(int years, String ultimateAnswer) &#123;</span><br><span class="line">        this.years = years;</span><br><span class="line">        this.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类型匹配</strong></p><p>在前面的场景中，如果使用 type 属性显式指定构造函数参数的类型，那么容器可以对简单类型使用类型匹配，如下面的示例所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>构造函数参数的顺序</strong></p><p>可以使用 index 属性显式指定构造函数参数的索引，如下面的示例所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>除了解决多个简单值的不确定性，指定索引还可以解决构造函数具有两个相同类型的参数时的不确定性。</p><h3 id="5-2-Constructor-based-or-setter-based-DI"><a href="#5-2-Constructor-based-or-setter-based-DI" class="headerlink" title="5.2 Constructor-based or setter-based DI?"></a>5.2 Constructor-based or setter-based DI?</h3><p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies. Note that use of the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-required-annotation">@Required</a> annotation on a setter method can be used to make the property be a required dependency; however, constructor injection with programmatic validation of arguments is preferable.</p><p><strong>The Spring team generally advocates constructor injection,</strong> as it lets you implement application components as immutable objects and ensures that required dependencies are not <code>null</code>. Furthermore, constructor-injected components are always returned to the client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.</p><p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. <strong>One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later.</strong> Management through <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx">JMX MBeans</a> is therefore a compelling use case for setter injection.</p><p>Use the DI style that makes the most sense for a particular class. Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, then constructor injection may be the only available form of DI.</p><blockquote><p>译：由于可以混合使用基于构造函数和基于 setter 的 DI，因此对于强制依赖项使用构造函数和对于可选依赖项使用 setter 方法或配置方法是一个很好的经验法则。注意，在 setter 方法上使用@Required 注释可以使该属性成为必需的依赖项; 但是，带有参数编程验证的构造函数注入更可取。</p><p><strong>Spring 团队通常提倡构造函数注入，</strong>因为它允许您将应用程序组件实现为不可变对象，并确保所需的依赖项不为空。此外，构造函数注入的组件总是以完全初始化的状态返回给客户机(调用)代码。作为一个旁注，大量的构造函数参数是糟糕的代码，<strong>（本博客作者注：在《代码整洁之道》书中，作者建议一般不超过三个参数，超过的话意味着要对函数进行拆分）</strong>，这意味着类可能有太多的责任，应该重构以更好地解决适当的关注点分离/代码。</p><p>Setter 注入应该主要用于可选的依赖项，这些依赖项可以在类中分配合理的默认值。否则，必须在代码使用依赖项的所有地方执行非空检查。<strong>Setter 注入的一个好处是 setter 方法使该类的对象容易在以后重新配置或重新注入。</strong>因此，通过 JMX MBeans进行管理是 setter 注入的一个引人注目的用例。</p><p>使用对特定类最有意义的DI样式。有时，在处理没有源代码的第三方类时，可以自行选择。例如，如果一个第三方类不公开任何setter方法，那么构造函数注入可能是DI的唯一可用形式。</p></blockquote><blockquote><p><strong>构造注入是必须把一个对象的所有依赖的对象都进行实例化，才能实例化这个对象</strong></p><p><strong>Setter注入是先实例化这个对象，然后找到依赖的对象，对依赖的对象进行实例化。</strong></p><p>setter注入： 一般情况下所有的java bean, 我们都会使用setter方法和getter方法去设置和获取属性的值，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class namebean &#123;</span><br><span class="line">String   name;</span><br><span class="line">public void setName(String a) &#123;</span><br><span class="line">name = a; </span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会创建一个bean的实例然后设置属性的值，spring的配置文件如下：</p><p>我们会创建一个bean的实例然后设置属性的值，spring的配置文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bean1″ &gt;</span><br><span class="line">&lt;property  name=&quot;name&quot; &gt;</span><br><span class="line">&lt;value&gt;tom&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>Spring会调用setName方法来只是name属性为tom<br>构造方法注入：构造方法注入中，我们使用带参数的构造方法如下：</p><p>Spring会调用setName方法来只是name属性为tom<br>构造方法注入：构造方法注入中，我们使用带参数的构造方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class namebean &#123;</span><br><span class="line">String name;</span><br><span class="line">public namebean(String a) &#123;</span><br><span class="line">name = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会在创建bean实例的时候以new namebean(”tom”)的方式来设置name属性, Spring配置文件如下：</p><p>我们会在创建bean实例的时候以new namebean(”tom”)的方式来设置name属性, Spring配置文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bean1″ &gt;</span><br><span class="line">&lt;constructor-arg&gt;</span><br><span class="line">&lt;value&gt;My Bean Value&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>使用constructor-arg标签来设置构造方法的参数。</p><p>使用constructor-arg标签来设置构造方法的参数。</p><p>引用：<a href="https://www.iteye.com/blog/yunqiang-zhang-hotmail-com-1601999">构造注入和Setter注入</a></p></blockquote><h4 id="5-3-Dependency-Resolution-Process（依赖解析的过程）"><a href="#5-3-Dependency-Resolution-Process（依赖解析的过程）" class="headerlink" title="5.3  Dependency Resolution Process（依赖解析的过程）"></a>5.3  Dependency Resolution Process（依赖解析的过程）</h4><p>The container performs bean dependency resolution as follows:</p><ul><li>The <code>ApplicationContext</code> is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified by XML, Java code, or annotations.</li><li>For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method (if you use that instead of a normal constructor). These dependencies are provided to the bean, when the bean is actually created.</li><li>Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.</li><li><strong>Each property or constructor argument that is a value is converted from its specified format to the actual type of that property or constructor argument. By default, Spring can convert a value supplied in string format to all built-in types, such as <code>int</code>, <code>long</code>, <code>String</code>, <code>boolean</code>, and so forth.</strong></li></ul><p>The Spring container validates the configuration of each bean as the container is created. However, the bean properties themselves are not set until the bean is actually created. Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Scopes are defined in <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes">Bean Scopes</a>. Otherwise, the bean is created only when it is requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s dependencies and its dependencies’ dependencies (and so on) are created and assigned. Note that resolution mismatches among those dependencies may show up late — that is, on first creation of the affected bean.</p><blockquote><p>容器执行 bean 依赖项解析如下:</p><p>创建 ApplicationContext 并使用描述所有 bean 的配置元数据进行初始化。可以通过 XML、 Java 代码或注释指定配置元数据。</p><p>对于每个 bean，它的依赖关系以属性、构造函数参数或静态工厂方法的参数的形式表示(如果您使用静态工厂方法而不是普通的构造函数)。在实际创建 bean 时，这些依赖项被提供给 bean。</p><p>每个属性或构造函数参数都是要设置的值的实际定义，或对容器中另一个 bean 的引用。</p><p><strong>作为值的每个属性或构造函数参数都将从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，如 int、 long、 String、 boolean 等。</strong></p><p>Spring 容器在创建容器时验证每个 bean 的配置。但是，在 bean 实际创建之前，不会设置 bean 属性本身。在创建容器时，将创建单一作用域并设置为预实例化(默认情况)的 bean。作用域在 Bean 作用域中定义。否则，只有在请求 bean 时才会创建它。创建 bean 可能会导致创建 bean 图，因为创建和分配 bean 的依赖项及其依赖项的依赖项(等等)。在首次创建受影响的 bean 时,请注意，这些依赖项之间的解析不匹配可能会延迟出现。</p></blockquote><p>You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created. This means that a Spring container that has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies — for example, the bean throws an exception as a result of a missing or invalid property. This potentially delayed visibility of some configuration issues is why <code>ApplicationContext</code> implementations by default pre-instantiate singleton beans. At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the <code>ApplicationContext</code> is created, not later. You can still override this default behavior so that singleton beans initialize lazily, rather than being eagerly pre-instantiated.</p><p>If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean. This means that, if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A. In other words, the bean is instantiated (if it is not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean">configured init method</a> or the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean">InitializingBean callback method</a>) are invoked.</p><blockquote><p>通常可以相信 Spring 会做正确的事情。它在容器加载时检测配置问题，例如对不存在的 bean 和循环依赖项的引用。Spring 在实际创建 bean 时设置属性并尽可能晚地解析依赖项。这意味着，如果创建对象或其某个依赖项时出现问题，那么正确加载的 Spring 容器随后可以在请求对象时生成异常ーー例如，由于缺少或无效属性，bean 抛出异常。一些配置问题的可见性可能会延迟，这就是为什么默认情况下 ApplicationContext 实现会预先实例化单例 bean。在实际需要这些 bean 之前，需要花费一些前期时间和内存来创建它们，因此在创建 ApplicationContext 时(而不是以后)会发现配置问题。您仍然可以覆盖这个默认行为，以便单例 bean 以惰性方式初始化，而不是急切地预先实例化。</p><p>如果不存在循环依赖关系，当一个或多个合作 bean 被注入到依赖 bean 中时，每个合作 bean 在被注入到依赖 bean 之前都会被完全配置。这意味着，如果 bean a 对 bean b 有依赖关系，那么在调用 bean a 上的 setter 方法之前，Spring IoC 容器将完全配置 bean b。换句话说，bean 被实例化(如果它不是预实例化的单例) ，它的依赖关系被设置，相关的生命周期方法(如配置的 init 方法或 InitializingBean 回调方法)被调用。</p></blockquote><h3 id="6-Dependencies-and-Configuration-in-Detail"><a href="#6-Dependencies-and-Configuration-in-Detail" class="headerlink" title="6. Dependencies and Configuration in Detail"></a>6. Dependencies and Configuration in Detail</h3><h4 id="6-1-Straight-Values-Primitives-Strings-and-so-on"><a href="#6-1-Straight-Values-Primitives-Strings-and-so-on" class="headerlink" title="6.1 Straight Values (Primitives, Strings, and so on)"></a>6.1 Straight Values (Primitives, Strings, and so on)</h4><p>元素的 value 属性将属性或构造函数参数指定为人类可读的字符串表示形式。Spring 的转换服务用于将这些值从 String 转换为属性或参数的实际类型。下面的示例显示了正在设置的各种值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">    &lt;!-- results in a setDriverClassName(String) call --&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;misterkaoli&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>下面的示例使用 p 名称空间进行更简洁的 XML 配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span><br><span class="line">        destroy-method=&quot;close&quot;</span><br><span class="line">        p:driverClassName=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">        p:url=&quot;jdbc:mysql://localhost:3306/mydb&quot;</span><br><span class="line">        p:username=&quot;root&quot;</span><br><span class="line">        p:password=&quot;misterkaoli&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>还可以配置 java.util.Properties 实例，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;mappings&quot;</span><br><span class="line">    class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- typed as a java.util.Properties --&gt;</span><br><span class="line">    &lt;property name=&quot;properties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>Spring 容器将 &lt; value/&gt; 元素内的文本转换为 java.util。属性实例，使用 javabean PropertyEditor 机制。这是一个很好的快捷方式，也是 Spring 团队确实喜欢使用嵌套的 &lt; value/&gt; 元素而不是 value 属性样式的少数几个地方之一。</p><h4 id="6-2-The-idref-element"><a href="#6-2-The-idref-element" class="headerlink" title="6.2 The idref element"></a>6.2 <strong>The</strong> <code>idref</code> <strong>element</strong></h4><p><code>Idref</code> 元素只是一种防错的方法，用于将容器中另一个 bean 的 id (字符串值——而不是引用)传递给一个 &lt; constructor-arg/&gt; 或 &lt; property/&gt; 元素。下面的例子展示了如何使用它:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;theClientBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;targetName&quot;&gt;</span><br><span class="line">        &lt;idref bean=&quot;theTargetBean&quot;/&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>前面的 bean 定义片段与下面的片段完全等效(在运行时) :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;client&quot; class=&quot;...&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;targetName&quot; value=&quot;theTargetBean&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>第一种形式比第二种更可取，因为使用 idref 标记可以让容器在部署时验证所引用的命名 bean 是否确实存在。在第二个变体中，不对传递给客户端 bean 的 targetName 属性的值执行验证。只有在实际实例化客户端 bean 时才会发现输入错误(很可能会导致致命的结果)。如果客户端 bean 是一个原型 bean，那么只有在部署容器之后很长时间才能发现这个排版错误和由此产生的异常。</p><blockquote><p>Idref 元素的本地属性在4.0 beans XSD 中不再受支持，因为它不再在常规 bean 引用上提供值。升级到4.0模式时，将现有的 idref 本地引用更改为 idref bean。</p></blockquote><h4 id="6-3-Collections"><a href="#6-3-Collections" class="headerlink" title="6.3 Collections"></a>6.3 Collections</h4><p><code>&lt;list/&gt;</code>、<code>&lt;set/&gt;</code>、<code>&lt;map/&gt;</code>和<code>&lt;props/&gt;</code>元素分别设置Java集合类型list、set、map和properties的属性和参数。下面的例子展示了如何使用它们:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;</span><br><span class="line">    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span><br><span class="line">    &lt;property name=&quot;adminEmails&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeList(java.util.List) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someList&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;a list element followed by a reference&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;myDataSource&quot; /&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someMap&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someSet&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;just some string&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;myDataSource&quot; /&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="6-4-Strongly-typed-collection"><a href="#6-4-Strongly-typed-collection" class="headerlink" title="6.4 Strongly-typed collection"></a>6.4 <strong>Strongly-typed collection</strong></h4><p>随着Java 5中泛型类型的引入，您可以使用强类型集合。也就是说，可以声明一个Collection类型，使其只能包含(例如)String元素。如果您使用Spring将强类型集合的依赖项注入到bean中，那么您可以利用Spring的类型转换支持，以便在将强类型集合实例的元素添加到集合之前将其转换为适当的类型。下面的Java类和bean定义展示了如何做到这一点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SomeClass &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Float&gt; accounts;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(Map&lt;String, Float&gt; accounts) &#123;</span><br><span class="line">        this.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;something&quot; class=&quot;x.y.SomeClass&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accounts&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=&quot;one&quot; value=&quot;9.99&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;two&quot; value=&quot;2.75&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;six&quot; value=&quot;3.99&quot;/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>当 <code>something</code> bean的 <code>accounts</code> 属性准备注入时，关于强类型 <code>Map&lt;String, Float&gt;</code> 的元素类型的泛型信息通过反射可用。因此，Spring的类型转换基础设施将各种值元素识别为<code>Float</code>类型，并将字符串值(<code>9.99</code>、<code>2.75</code>和<code>3.99</code>)转换为实际的<code>Float</code>类型。</p><h4 id="6-5-XML-Shortcut-with-the-p-namespace"><a href="#6-5-XML-Shortcut-with-the-p-namespace" class="headerlink" title="6.5 XML Shortcut with the p-namespace"></a>6.5 XML Shortcut with the p-namespace</h4><p>p名称空间允许使用bean元素的属性(而不是嵌套的<property>元素)来描述协作bean的属性值，或者两者都使用。</property></p><p>Spring支持具有名称空间的可扩展配置格式，名称空间基于XML Schema定义。本章中讨论的bean配置格式是在XML Schema文档中定义的。但是，p名称空间并没有在XSD文件中定义，它只存在于Spring的核心中。</p><p>下面的例子展示了两个XML片段(第一个使用标准XML格式，第二个使用p-命名空间)，它们解析到相同的结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;email&quot; value=&quot;someone@somewhere.com&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;</span><br><span class="line">        p:email=&quot;someone@somewhere.com&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>该示例显示了bean定义中<code>p-namespace</code>中的一个名为<code>email</code>的属性。这告诉Spring包含一个属性声明。如前所述，<code>p-namespace</code>没有模式定义，因此可以将属性的名称设置为属性名称。</p><p>下一个例子包含另外两个bean定义，它们都有对另一个bean的引用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;john-modern&quot;</span><br><span class="line">        class=&quot;com.example.Person&quot;</span><br><span class="line">        p:name=&quot;John Doe&quot;</span><br><span class="line">        p:spouse-ref=&quot;jane&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>这个示例不仅包含使用<code>p-namespace</code>的属性值，而且还使用一种特殊的格式来声明属性引用。第一个bean定义使用<code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code>来创建从<code>bean john</code>到<code>bean jane</code>的引用，而第二个bean定义使用<code>p:spouse-ref=&quot;jane&quot;</code>作为属性来做完全相同的事情。在本例中，<code>spouse</code>是属性名，而<code>-ref</code>部分表明这不是一个直接的值，而是对另一个bean的引用。</p><h4 id="6-6-XML-Shortcut-with-the-c-namespace"><a href="#6-6-XML-Shortcut-with-the-c-namespace" class="headerlink" title="6.6 XML Shortcut with the c-namespace"></a>6.6 XML Shortcut with the c-namespace</h4><p>与带有<code>p-namespace</code>的XML Shortcut类似，<strong>在Spring 3.1中引入的<code>c-namespace</code>允许内联属性来配置构造函数参数，而不是嵌套<code>constructor-arg</code>元素。</strong></p><p>下面的例子使用了<code>c: namespace</code>来做和from基于构造函数的依赖注入一样的事情:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- traditional declaration with optional argument names --&gt;</span><br><span class="line">    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;email&quot; value=&quot;something@somewhere.com&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- c-namespace declaration with argument names --&gt;</span><br><span class="line">    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot;</span><br><span class="line">        c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><code>c:</code>命名空间使用与<code>p: </code>one相同的约定(后面的-ref表示bean引用)，通过它们的名称设置构造函数参数。类似地，它需要在XML文件中声明，即使它没有在XSD模式中定义(它存在于Spring核心中)。</p><p>对于构造函数参数名不可用的罕见情况(通常是在没有调试信息的情况下编译字节码)，你可以使用回退到参数索引，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- c-namespace index declaration --&gt;</span><br><span class="line">&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:_0-ref=&quot;beanTwo&quot; c:_1-ref=&quot;beanThree&quot;</span><br><span class="line">    c:_2=&quot;something@somewhere.com&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>由于XML语法的原因，索引表示法要求前面有_，因为XML属性名称不能以数字开头(尽管有些ide允许)。对于<constructor-arg>元素也可以使用相应的索引表记法，但并不常用，因为这里的声明顺序通常就足够了。</constructor-arg></p></blockquote><h3 id="7-Method-Injection"><a href="#7-Method-Injection" class="headerlink" title="7. Method Injection"></a>7. Method Injection</h3><p>在大多数应用程序场景中，容器中的大多数bean都是单例的。<strong>当一个单例bean需要与另一个单例bean协作，或者一个非单例bean需要与另一个非单例bean协作时，通常通过将一个bean定义为另一个bean的属性来处理依赖关系。</strong>当bean生命周期不同时，问题就出现了。假设单例bean A需要使用非单例(原型)bean B，也许是在对A的每个方法调用中。容器只创建一次单例bean A，因此只得到一次设置属性的机会。容器不能在每次需要bean B的新实例时为bean A提供新实例。</p><p>一种解决方案是放弃某些控制倒置。你可以通过实现ApplicationContextAware接口让bean A知道容器，并且每次bean A需要它时，通过getBean(“B”)调用容器来请求(典型的新)bean B实例。下面的例子展示了这种方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// a class that uses a stateful Command-style class to perform some processing</span><br><span class="line">package fiona.apple;</span><br><span class="line"></span><br><span class="line">// Spring-API imports</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line">public class CommandManager implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    public Object process(Map commandState) &#123;</span><br><span class="line">        // grab a new instance of the appropriate Command</span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        // set the state on the (hopefully brand new) Command instance</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Command createCommand() &#123;</span><br><span class="line">        // notice the Spring API dependency!</span><br><span class="line">        return this.applicationContext.getBean(&quot;command&quot;, Command.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setApplicationContext(</span><br><span class="line">            ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Request-Session-Application-and-WebSocket-Scopes"><a href="#8-Request-Session-Application-and-WebSocket-Scopes" class="headerlink" title="8.  Request, Session, Application, and WebSocket Scopes"></a>8.  Request, Session, Application, and WebSocket Scopes</h3><h4 id="8-1-Request-scope"><a href="#8-1-Request-scope" class="headerlink" title="8.1  Request scope"></a>8.1  Request scope</h4><p>Spring容器通过为每个HTTP请求使用LoginAction bean定义来创建LoginAction bean的新实例。也就是说，loginAction bean的作用域为HTTP请求级别。您可以随心所欲地更改创建的实例的内部状态，因为从相同的loginAction bean定义创建的其他实例不会在状态中看到这些更改。它们是针对个人要求的。当请求完成处理时，将范围限定在请求的bean丢弃。</p><p>在使用注释驱动的组件或Java配置时，可以使用@RequestScope注释将组件分配给请求范围。下面的例子展示了如何做到这一点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestScope</span><br><span class="line">@Component</span><br><span class="line">public class LoginAction &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-Session-Scope"><a href="#8-2-Session-Scope" class="headerlink" title="8.2 Session Scope"></a>8.2 Session Scope</h4><p>Spring容器通过在单个HTTP会话的生命周期中使用<code>UserPreferences </code>bean定义来创建<code>UserPreferences</code> bean的新实例。换句话说，<code>userPreferences</code> bean有效地限定在HTTP <code>Session</code>级别。与请求范围内bean一样,你可以改变内部状态的实例创建尽可能多的你想要的,知道其他HTTP会话实例也使用相同的实例创建<code>userPreferences</code> bean定义看不到这些变化状态,因为他们是特定于一个单独的HTTP会话。当HTTP会话最终被丢弃时，限定在该特定HTTP会话范围内的bean也被丢弃。</p><p>在使用注释驱动的组件或Java配置时，可以使用<code>@SessionScope</code>注释将组件分配给会话作用域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SessionScope</span><br><span class="line">@Component</span><br><span class="line">public class UserPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-Application-Scope"><a href="#8-3-Application-Scope" class="headerlink" title="8.3 Application Scope"></a>8.3 Application Scope</h4><p>Spring容器通过对整个web应用程序使用一次<code>AppPreferences bean</code>定义来创建一个<code>AppPreferences bean</code>的新实例。也就是说，<code>appPreferences bean</code>的作用域在<code>ServletContext</code>级别，并存储为一个常规<code>ServletContext</code>属性。这有点类似于弹簧单例bean,但在两个重要方面不同:它是一个单例每<code>ServletContext</code>不是每<code>Spring ApplicationContext</code>(可能有几个在任何给定的web应用程序),它实际上是暴露,因此可见<code>ServletContext</code>属性。</p><p>在使用注释驱动的组件或Java配置时，可以使用<code>@ApplicationScope</code>注释将组件分配给应用程序范围。下面的例子展示了如何做到这一点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ApplicationScope</span><br><span class="line">@Component</span><br><span class="line">public class AppPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-WebSocket-Scope"><a href="#8-4-WebSocket-Scope" class="headerlink" title="8.4 WebSocket Scope"></a>8.4 WebSocket Scope</h4><p>WebSocket作用域与WebSocket会话的生命周期相关，适用于WebSocket上的STOMP应用程序，更多细节请参阅<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-websocket-scope">WebSocket作用域</a>。</p><h3 id="9-Customizing-the-Nature-of-a-Bean-定制Bean的性质"><a href="#9-Customizing-the-Nature-of-a-Bean-定制Bean的性质" class="headerlink" title="9. Customizing the Nature of a Bean(定制Bean的性质)"></a>9. Customizing the Nature of a Bean(定制Bean的性质)</h3><p>Spring框架提供了许多接口，您可以使用这些接口来定制bean的性质。本节将它们分组如下:</p><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle">Lifecycle Callbacks</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aware-list">Other <code>Aware</code> Interfaces</a></li></ul><h4 id="9-1-Lifecycle-Callbacks"><a href="#9-1-Lifecycle-Callbacks" class="headerlink" title="9.1 Lifecycle Callbacks"></a>9.1 Lifecycle Callbacks</h4><p>要与容器对bean生命周期的管理交互，你可以实现Spring InitializingBean和DisposableBean接口。容器对前者调用afterPropertiesSet()，对后者调用destroy()，让bean在初始化和销毁bean时执行某些操作。</p><blockquote><p>JSR-250 <code>@PostConstruct</code>和<code>@PreDestroy</code>注释通常被认为是现代Spring应用程序中接收生命周期回调的最佳实践。使用这些注释意味着您的bean没有耦合到特定于spring的接口。详细信息请参见使用<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations">Using <code>@PostConstruct</code> and <code>@PreDestroy</code></a>。</p><p>如果你不想使用JSR-250注释，但是你仍然想要移除耦合，考虑 <code>init-method</code> 和 <code>destroy-method</code> bean定义元数据。</p></blockquote><p>在内部，Spring框架使用<code>BeanPostProcessor</code>实现来处理它可以找到并调用适当方法的任何回调接口。如果您需要定制特性或Spring默认不提供的其他生命周期行为，您可以自己实现<code>BeanPostProcessor</code>。有关更多信息，请参见<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension">Container Extension Points</a>。</p><p>除了初始化和销毁回调，spring管理的对象还可以实现<code>Lifecycle</code>接口，这样这些对象就可以参与启动和关闭过程，这是由容器自己的生命周期驱动的。</p><p>本节介绍生命周期回调接口。</p><h5 id="9-1-1-Initialization-Callbacks"><a href="#9-1-1-Initialization-Callbacks" class="headerlink" title="9.1.1 Initialization Callbacks"></a>9.1.1 Initialization Callbacks</h5><p><code>initializingbean</code>接口允许bean在容器设置完bean上所有必要的属性后执行初始化工作。<code>InitializingBean</code>接口指定了一个单一的方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void afterPropertiesSet() throws Exception;</span><br></pre></td></tr></table></figure><p>我们建议您不要使用<code>InitializingBean</code>接口，因为它不必要地将代码耦合到Spring。另外，我们建议使用<code>@PostConstruct</code>注释或指定POJO初始化方法。在基于xml的配置元数据的情况下，可以使用<code>init-method</code>属性指定具有空无参数签名的方法的名称。在Java配置中，您可以使用<code>@Bean</code>的<code>initMethod</code>属性。请参见接收生命周期回调。考虑以下例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        // do some initialization work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子和下面的例子(包含两个清单)效果几乎完全相同:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AnotherExampleBean implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        // do some initialization work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，前面两个示例中的第一个并没有将代码与Spring耦合起来。(后一个继承了<code>InitializingBean</code>)</p><h5 id="9-1-2-Destruction-Callbacks"><a href="#9-1-2-Destruction-Callbacks" class="headerlink" title="9.1.2 Destruction Callbacks"></a>9.1.2 Destruction Callbacks</h5><p>实现这个接口（ <code>org.springframework.beans.factory.DisposableBean</code>）可以让bean在容器销毁时获得回调函数。DisposableBean接口指定了一个单独的方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void destroy() throws Exception;</span><br></pre></td></tr></table></figure><p>我们建议您不要使用DisposableBean回调接口，因为它不必要地将代码与Spring耦合起来。另外，我们建议使用@PreDestroy注释或指定bean定义支持的泛型方法。使用基于xml的配置元数据，可以在<bean>上使用destroy-method属性。在Java配置中，您可以使用@Bean的destroyMethod属性。请参见接收生命周期回调。考虑以下定义:</bean></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    public void cleanup() &#123;</span><br><span class="line">        // do some destruction work (like releasing pooled connections)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的定义与下面的定义具有几乎完全相同的效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AnotherExampleBean implements DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        // do some destruction work (like releasing pooled connections)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，前面两个定义中的第一个并没有将代码与Spring耦合起来。</p><blockquote><p>……此外本节还有一些没有摘录</p></blockquote><h5 id="9-1-3-Combining-Lifecycle-Mechanisms（结合生命周期机制）"><a href="#9-1-3-Combining-Lifecycle-Mechanisms（结合生命周期机制）" class="headerlink" title="9.1.3 Combining Lifecycle Mechanisms（结合生命周期机制）"></a>9.1.3 Combining Lifecycle Mechanisms（结合生命周期机制）</h5><p>在Spring 2.5中，你有三个控制bean生命周期行为的选项:</p><ul><li><code>InitializingBean</code>和<code>DisposableBean</code>回调接口</li><li>自定义<code>init()</code>和<code>destroy()</code>方法</li><li><code>@PostConstruct</code>和<code>@PreDestroy</code>注释。您可以组合这些机制来控制给定的bean。</li></ul><h5 id="9-1-4-Startup-and-Shutdown-Callbacks"><a href="#9-1-4-Startup-and-Shutdown-Callbacks" class="headerlink" title="9.1.4 Startup and Shutdown Callbacks"></a>9.1.4 Startup and Shutdown Callbacks</h5><p><code>Lifecycle</code>接口为任何有自己生命周期需求的对象定义了基本方法(比如启动和停止一些后台进程):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Lifecycle &#123;</span><br><span class="line"></span><br><span class="line">    void start();</span><br><span class="line"></span><br><span class="line">    void stop();</span><br><span class="line"></span><br><span class="line">    boolean isRunning();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何spring管理的对象都可以实现<code>Lifecycle</code>接口。然后，当<code>ApplicationContext</code>本身接收到启动和停止信号时(例如，对于运行时的停止/重启场景)，它将这些调用级联到在该上下文中定义的所有<code>Lifecycle</code>实现。它通过委托给<code>LifecycleProcessor</code>来实现，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface LifecycleProcessor extends Lifecycle &#123;</span><br><span class="line"></span><br><span class="line">    void onRefresh();</span><br><span class="line"></span><br><span class="line">    void onClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="9-1-5-Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications"><a href="#9-1-5-Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications" class="headerlink" title="9.1.5 Shutting Down the Spring IoC Container Gracefully in Non-Web Applications"></a>9.1.5 Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</h5><p>本节讲述了在非 web 应用程序中优雅地关闭 Spring IoC 容器，我个人认为这里暂时用的不多，以后有需要再看。</p><h3 id="10-Container-Extension-Points（扩展容器）"><a href="#10-Container-Extension-Points（扩展容器）" class="headerlink" title="10 . Container Extension Points（扩展容器）"></a>10 . Container Extension Points（扩展容器）</h3><h4 id="10-1-Customizing-Beans-by-Using-a-BeanPostProcessor"><a href="#10-1-Customizing-Beans-by-Using-a-BeanPostProcessor" class="headerlink" title="10.1 Customizing Beans by Using a BeanPostProcessor"></a>10.1 Customizing Beans by Using a <code>BeanPostProcessor</code></h4><p><code>BeanPostProcessor</code>接口定义了回调方法，您可以实现这些方法来提供您自己的(或覆盖容器的默认值)实例化逻辑、依赖关系解析逻辑，等等。如果您想在Spring容器完成实例化、配置和初始化bean之后实现一些自定义逻辑，您可以插入一个或多个自定义<code>BeanPostProcessor</code>实现。</p><p>您可以配置多个BeanPostProcessor实例，并且可以通过设置order属性来控制这些<code>BeanPostProcessor</code>实例运行的顺序。只有当<code>BeanPostProcessor</code>实现了<code>Ordered</code>接口时，才能设置此属性。如果编写自己的<code>BeanPostProcessor</code>，还应该考虑实现<code>Ordered</code>接口。要了解更多细节，请参阅<code>BeanPostProcessor</code>和<code>Ordered</code>接口的javadoc。请参见有关<code>BeanPostProcessor</code>实例的编程式注册的说明。</p><h4 id="10-2-Example-Hello-World-BeanPostProcessor-style"><a href="#10-2-Example-Hello-World-BeanPostProcessor-style" class="headerlink" title="10.2 Example: Hello World, BeanPostProcessor-style"></a>10.2 Example: Hello World, <code>BeanPostProcessor</code>-style</h4><p>下面的例子展示了如何在<code>ApplicationContext</code>中编写、注册和使用<code>BeanPostProcessor</code>实例。</p><p>第一个示例演示了基本用法。这个例子展示了一个自定义的BeanPostProcessor实现，它在容器创建每个bean时调用它的toString()方法，并将结果字符串打印到系统控制台。</p><p>下面的清单显示了自定义的BeanPostProcessor实现类定义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package scripting;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line">public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    // simply return the instantiated bean as-is</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line">        return bean; // we could potentially return any object reference here...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) &#123;</span><br><span class="line">        System.out.println(&quot;Bean &#x27;&quot; + beanName + &quot;&#x27; created : &quot; + bean.toString());</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的bean元素使用了<code>InstantiationTracingBeanPostProcessor</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:lang=&quot;http://www.springframework.org/schema/lang&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/lang</span><br><span class="line">        https://www.springframework.org/schema/lang/spring-lang.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;lang:groovy id=&quot;messenger&quot;</span><br><span class="line">            script-source=&quot;classpath:org/springframework/scripting/groovy/Messenger.groovy&quot;&gt;</span><br><span class="line">        &lt;lang:property name=&quot;message&quot; value=&quot;Fiona Apple Is Just So Dreamy.&quot;/&gt;</span><br><span class="line">    &lt;/lang:groovy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    when the above bean (messenger) is instantiated, this custom</span><br><span class="line">    BeanPostProcessor implementation will output the fact to the system console</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean class=&quot;scripting.InstantiationTracingBeanPostProcessor&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>注意<code>InstantiationTracingBeanPostProcesso</code>r是如何定义的。它甚至没有名称，而且，因为它是一个bean，所以可以像其他任何bean一样进行依赖注入。(前面的配置还定义了一个由Groovy脚本支持的bean。Spring的动态语言支持将在<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/languages.html#dynamic-language">“动态语言支持”</a>一章中详细介绍。)</p><p>以下Java应用程序运行上述代码和配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.springframework.scripting.Messenger;</span><br><span class="line"></span><br><span class="line">public final class Boot &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) throws Exception &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;scripting/beans.xml&quot;);</span><br><span class="line">        Messenger messenger = ctx.getBean(&quot;messenger&quot;, Messenger.class);</span><br><span class="line">        System.out.println(messenger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述应用程序的输出如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bean &#x27;messenger&#x27; created : org.springframework.scripting.groovy.GroovyMessenger@272961</span><br><span class="line">org.springframework.scripting.groovy.GroovyMessenger@272961</span><br></pre></td></tr></table></figure><h4 id="10-3-Example-The-Class-Name-Substitution-PropertySourcesPlaceholderConfigurer"><a href="#10-3-Example-The-Class-Name-Substitution-PropertySourcesPlaceholderConfigurer" class="headerlink" title="10.3 Example: The Class Name Substitution PropertySourcesPlaceholderConfigurer"></a>10.3 Example: The Class Name Substitution <code>PropertySourcesPlaceholderConfigurer</code></h4><p>您可以使用<code>propertysourcesconfigururer</code>来通过使用标准Java Properties格式将bean定义中的属性值外部化到单独的文件中。这样一来，部署应用程序的人员就可以定制特定于环境的属性，如数据库url和密码，而无需修改主XML定义文件或容器文件，从而避免了复杂性或风险。</p><p>参考以下基于xml的配置元数据片段，其中定义了一个具有占位符值的数据源:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;locations&quot; value=&quot;classpath:com/something/jdbc.properties&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;dataSource&quot; destroy-method=&quot;close&quot;</span><br><span class="line">        class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>该示例显示了从外部properties文件配置的属性。在运行时，<code>propertysourcesconfigururer</code>被应用于元数据，用来替换数据源的一些属性。要替换的值被指定为<code>$&#123;property-name&#125;</code>形式的占位符，它遵循Ant、log4j和JSP EL风格。</p><p>实际值来自另一个标准Java <code>Properties</code>格式的文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=org.hsqldb.jdbcDriver</span><br><span class="line">jdbc.url=jdbc:hsqldb:hsql://production:9002</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><h3 id="11-Annotation-based-Container-Configuration"><a href="#11-Annotation-based-Container-Configuration" class="headerlink" title="11.  Annotation-based Container Configuration"></a>11.  Annotation-based Container Configuration</h3><blockquote><p>​                                                                        <strong>注解是否比XML更适合配置Spring?</strong></p><p>基于注释的配置的引入提出了这样一个问题:这种方法是否比XML“更好”。简短的回答是“视情况而定”。长一点的答案是，每种方法都有其优点和缺点，通常，这取决于开发人员决定哪种策略更适合他们。由于注解的定义方式，注解在其声明中提供了大量的上下文，从而使配置更短、更简洁。但是，XML擅长在不修改源代码或重新编译它们的情况下连接组件。一些开发人员更喜欢将连接连接到源代码附近，而另一些开发人员则认为，带注释的类不再是pojo，而且，配置变得分散，更难控制。</p><p>无论选择什么，Spring都可以容纳这两种风格，甚至可以将它们混合在一起。值得指出的是，通过它的JavaConfig选项，Spring允许以一种非侵入性的方式使用注释，而不涉及目标组件源代码。</p></blockquote><p>一如既往，您可以将后处理器注册为单独的 bean 定义，但也可以通过在基于 xml 的 Spring 配置中包含以下标记来隐式注册它们(注意包含上下文名称空间) :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;context:annotation-config/&gt;</code>元素隐式地注册了以下的后处理器:</p><ul><li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/context/annotation/ConfigurationClassPostProcessor.html"><code>ConfigurationClassPostProcessor</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/context/event/EventListenerMethodProcessor.html"><code>EventListenerMethodProcessor</code></a></li></ul><blockquote><p>&lt;仅在定义注解的应用程序上下文中查找bean上的注解。这意味着，如果你把<code>&lt;context:annotation-config/&gt;</code>放在一个<code>DispatcherServlet</code>的<code>WebApplicationContext</code>中，它只检查你的控制器中的<code>@Autowired</code> bean，而不是你的服务。更多信息请参见<code>DispatcherServlet</code>。</p></blockquote><p><strong>注释的相关讲解参考Spring官方文档</strong></p><h4 id="11-1-Resource和-Autowired的区别"><a href="#11-1-Resource和-Autowired的区别" class="headerlink" title="11.1 @Resource和@Autowired的区别"></a>11.1 <code>@Resource</code>和<code>@Autowired</code>的区别</h4><p>参考：<a href="https://blog.csdn.net/weixin_40906484/article/details/113937179">https://blog.csdn.net/weixin_40906484/article/details/113937179</a></p><h4 id="11-2-基于自定义注解的依赖注入"><a href="#11-2-基于自定义注解的依赖注入" class="headerlink" title="11.2 基于自定义注解的依赖注入"></a>11.2 基于自定义注解的依赖注入</h4><p>您可以创建自己的自定义限定符注释。要做到这一点，请定义一个注释，并在定义中提供<code>@Qualifier</code>注释，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface Genre &#123;</span><br><span class="line"></span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以在自动连接的字段和参数上提供自定义限定符，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Genre(&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionCatalog;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog comedyCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setComedyCatalog(@Genre(&quot;Comedy&quot;) MovieCatalog comedyCatalog) &#123;</span><br><span class="line">        this.comedyCatalog = comedyCatalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，您可以为候选bean定义提供信息。您可以将<code>&lt;qualifier/&gt;</code>标记添加为<code>&lt;bean/&gt;</code>标记的子元素，然后指定类型和值，以匹配您的自定义限定符注释。该类型与注释的完全限定类名相匹配。另外，如果不存在名称冲突的风险，为了方便起见，可以使用简短的类名。下面的例子演示了这两种方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;Genre&quot; value=&quot;Action&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;example.Genre&quot; value=&quot;Comedy&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;movieRecommender&quot; class=&quot;example.MovieRecommender&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>还可以定义自定义限定符注释，在简单的value属性之外或之外接受命名属性。<strong>如果在一个要自动连接的字段或参数上指定了多个属性值，那么bean定义必须匹配所有这些属性值，才能被视为自动连接候选属性</strong>。例如，参考以下注释定义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface MovieQualifier &#123;</span><br><span class="line"></span><br><span class="line">    String genre();</span><br><span class="line"></span><br><span class="line">    Format format();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>Format</code>是一个enum，定义如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Format &#123;</span><br><span class="line">    VHS, DVD, BLURAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要自动连接的字段用自定义限定符标注，并包含两个属性的值:<code>genre</code>和<code>format</code>，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.DVD, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionDvdCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.BLURAY, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyBluRayCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，bean定义应该包含匹配的限定符值。这个例子还演示了您可以使用bean的元属性而不是<code>&lt;qualifier/&gt;</code>元素。如果可用，<code>&lt;qualifier/&gt;</code>元素及其属性优先，但如果没有这样的限定符，自动组合机制将返回到<code>&lt;meta/&gt;</code>标记中提供的值，就像下面示例中的最后两个bean定义一样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;</span><br><span class="line">            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;</span><br><span class="line">            &lt;attribute key=&quot;genre&quot; value=&quot;Action&quot;/&gt;</span><br><span class="line">        &lt;/qualifier&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;</span><br><span class="line">            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;</span><br><span class="line">            &lt;attribute key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;</span><br><span class="line">        &lt;/qualifier&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;meta key=&quot;format&quot; value=&quot;DVD&quot;/&gt;</span><br><span class="line">        &lt;meta key=&quot;genre&quot; value=&quot;Action&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;meta key=&quot;format&quot; value=&quot;BLURAY&quot;/&gt;</span><br><span class="line">        &lt;meta key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="12-AOP-Concepts"><a href="#12-AOP-Concepts" class="headerlink" title="12. AOP Concepts"></a>12. AOP Concepts</h3><p>相关术语：</p><h5 id="1-通知（Advice）"><a href="#1-通知（Advice）" class="headerlink" title="1.通知（Advice）"></a>1.通知（Advice）</h5><p>　　就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。</p><h5 id="2-连接点（JoinPoint）"><a href="#2-连接点（JoinPoint）" class="headerlink" title="2.连接点（JoinPoint）"></a>2.连接点（JoinPoint）</h5><p>　　这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。</p><h5 id="3-切入点（Pointcut）"><a href="#3-切入点（Pointcut）" class="headerlink" title="3.切入点（Pointcut）"></a>3.切入点（Pointcut）</h5><p>　　上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。</p><h5 id="4-切面（Aspect）"><a href="#4-切面（Aspect）" class="headerlink" title="4.切面（Aspect）"></a>4.切面（Aspect）</h5><p>　　切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好<strong>理解</strong>切点，搞出来的，明白这个<strong>概念</strong>就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p><h5 id="5-引入（introduction）"><a href="#5-引入（introduction）" class="headerlink" title="5.引入（introduction）"></a>5.引入（introduction）</h5><p>　　允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗</p><h5 id="6-目标（target）"><a href="#6-目标（target）" class="headerlink" title="6.目标（target）"></a>6.目标（target）</h5><p>　　引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。</p><h5 id="7-代理-proxy"><a href="#7-代理-proxy" class="headerlink" title="7.代理(proxy)"></a>7.代理(proxy)</h5><p>　　怎么实现整套aop机制的，都是通过代理，这个一会给细说。</p><h5 id="8-织入-weaving"><a href="#8-织入-weaving" class="headerlink" title="8.织入(weaving)"></a>8.织入(weaving)</h5><p>　　把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。</p><p>　　关键就是：切点定义了哪些连接点会得到通知</p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E9%9A%8F%E7%AC%94/">随笔</category>
      
      
      <category domain="http://hznu.asia/tags/Spring/">Spring</category>
      
      
      <comments>http://hznu.asia/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>阅读SpringBoot文档摘录</title>
      <link>http://hznu.asia/2022/01/23/%E9%98%85%E8%AF%BBSpringBoot%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/</link>
      <guid>http://hznu.asia/2022/01/23/%E9%98%85%E8%AF%BBSpringBoot%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/</guid>
      <pubDate>Sun, 23 Jan 2022 09:26:39 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;这篇博客是我在阅读 SpringBoot 英文文档过程中记录的对SpringBoot的新认知，或者说是之前比较模糊的概念。总而言之，算是我个人的随笔记录，方便以后查看，如果感觉对你帮助不大，可以跳过不看本篇博客。&lt;/p&gt;
&lt;/blockquote&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>这篇博客是我在阅读 SpringBoot 英文文档过程中记录的对SpringBoot的新认知，或者说是之前比较模糊的概念。总而言之，算是我个人的随笔记录，方便以后查看，如果感觉对你帮助不大，可以跳过不看本篇博客。</p></blockquote><h3 id="1-Upgrading-to-a-new-feature-release"><a href="#1-Upgrading-to-a-new-feature-release" class="headerlink" title="1.  Upgrading to a new feature release"></a>1.  Upgrading to a new feature release</h3><p>When upgrading to a new feature release, some properties may have been renamed or removed. Spring Boot provides a way to analyze your application’s environment and print diagnostics at startup, but also temporarily migrate properties at runtime for you. To enable that feature, add the following dependency to your project:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-properties-migrator&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这段代码其实我之前并没有去深究他的含义，这也是我之前学习过程中的一个弊端，很多东西并没有去深究，后面慢慢发现这是一个很不好的习惯。</p><p>这几行代码是因为在SpringBoot版本升级过程中，一些 properties 可能会被改名或者移除，但是如果有这行代码，他会自动分析你的应用环境并在启动时打印出分析结果，也可以运行时临时迁移属性。</p><blockquote><p>注意：一些较晚添加进环境的属性，比如 <code>@PropertySource</code> 这些，此配置不会对其生效。</p><p>另外，在完成迁移后，需要确认从项目依赖中移出这个依赖。</p></blockquote><h3 id="2-Using-the-“default”-Package"><a href="#2-Using-the-“default”-Package" class="headerlink" title="2. Using the “default” Package"></a>2. Using the “default” Package</h3><p>When a class does not include a <code>package</code> declaration, it is considered to be in the “default package”. The use of the “default package” is generally discouraged and should be avoided. It can cause particular problems for Spring Boot applications that use the <code>@ComponentScan</code>, <code>@ConfigurationPropertiesScan</code>, <code>@EntityScan</code>, or <code>@SpringBootApplication</code> annotations, since every class from every jar is read.</p><blockquote><p>We recommend that you follow Java’s recommended package naming conventions and use a reversed domain name (for example, <code>com.example.project</code>).</p></blockquote><h3 id="3-Locating-the-Main-Application-Class"><a href="#3-Locating-the-Main-Application-Class" class="headerlink" title="3. Locating the Main Application Class"></a>3. Locating the Main Application Class</h3><p>We generally recommend that you locate your main application class in a root package above other classes. The <a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#using.using-the-springbootapplication-annotation"><code>@SpringBootApplication</code> annotation</a> is often placed on your main class, and it implicitly defines a base “search package” for certain items. For example, if you are writing a JPA application, the package of the <code>@SpringBootApplication</code> annotated class is used to search for <code>@Entity</code> items. Using a root package also allows component scan to apply only on your project.</p><blockquote><p>If you do not want to use <code>@SpringBootApplication</code>, the <code>@EnableAutoConfiguration</code> and <code>@ComponentScan</code> annotations that it imports defines that behavior so you can also use those instead.</p></blockquote><p>简而言之，上面的意思就是推荐使用 <code>@SpringBootApplication</code> 注解，它可以提供搜索架包的功能。如果不使用的话，也可以使用<code>@EnableAutoConfiguration</code> 和<code>@ComponentScan</code> 注解来代替相同的行为。</p><h3 id="4-Auto-configuration"><a href="#4-Auto-configuration" class="headerlink" title="4. Auto-configuration"></a>4. Auto-configuration</h3><p>Spring Boot auto-configuration尝试根据添加的jar依赖项自动配置Spring应用程序。例如，如果<code>HSQLDB</code>在类路径上，并且您没有手动配置任何数据库连接bean，那么Spring Boot将自动配置内存中的数据库。</p><p>您需要通过在<code>@Configuration</code>类中添加<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>注释来选择自动配置。</p><blockquote><p>您应该只添加一个<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>注释。我们通常建议您只将其中一个添加到主<code>@Configuration</code>类中。</p></blockquote><h3 id="5-Automatic-Restart"><a href="#5-Automatic-Restart" class="headerlink" title="5. Automatic Restart"></a>5. Automatic Restart</h3><h4 id="5-1-Excluding-Resources"><a href="#5-1-Excluding-Resources" class="headerlink" title="5.1 Excluding Resources"></a>5.1 Excluding Resources</h4><p>某些资源在被更改时并不一定需要触发重新启动。例如，可以就地编辑<code>Thymeleaf</code>模板。默认情况下，在<code>/META-INF/maven</code>、<code>/META-INF/resources</code>、<code>/resources</code>、<code>/static</code>、<code>/public</code>或<code>/templates</code>中更改资源不会触发重启，但会触发实时重新加载。如果你想定制这些排除，你可以使用<code>spring.devtools.restart.exclude</code>属性。例如，要只排除<code>/static</code>和<code>/public</code>，你需要设置以下属性:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  devtools:</span><br><span class="line">    restart:</span><br><span class="line">      exclude: &quot;static/**,public/**&quot;</span><br></pre></td></tr></table></figure><blockquote><p>如果你想保留这些默认值并添加额外的排除项，请改用<code>spring.devtools.restart.additional-exclude</code>属性。</p></blockquote><h4 id="5-2-Running-the-Remote-Client-Application"><a href="#5-2-Running-the-Remote-Client-Application" class="headerlink" title="5.2 Running the Remote Client Application"></a>5.2 Running the Remote Client Application</h4><p>远程客户端应用程序被设计为从IDE中运行。您需要使用与您连接的远程项目相同的类路径运行<code>org.springframework.boot.devtools.RemoteSpringApplication</code>。应用程序的唯一必需参数是它所连接到的远程URL。</p><p>例如，如果你正在使用<code>Eclipse</code>或<code>Spring Tools</code>，并且你有一个名为<code>my-app</code>的项目，你已经部署到<code>Cloud Foundry</code>，你会这样做:</p><ul><li>Select <code>Run Configurations…</code> from the <code>Run</code> menu.</li><li>Create a new <code>Java Application</code> “launch configuration”.</li><li>Browse for the <code>my-app</code> project.</li><li>Use <code>org.springframework.boot.devtools.RemoteSpringApplication</code> as the main class.</li><li>Add <code>https://myapp.cfapps.io</code> to the <code>Program arguments</code> (or whatever your remote URL is).</li></ul><h3 id="6-Application-Events-and-Listeners"><a href="#6-Application-Events-and-Listeners" class="headerlink" title="6. Application Events and Listeners"></a>6. Application Events and Listeners</h3><h4 id="6-1-应用程序事件发送顺序"><a href="#6-1-应用程序事件发送顺序" class="headerlink" title="6.1 应用程序事件发送顺序"></a>6.1 应用程序事件发送顺序</h4><p>当你的应用程序运行时，应用程序事件按以下顺序发送:</p><ol><li>An <code>ApplicationStartingEvent</code> is sent at the start of a run but before any processing, except for the registration of listeners and initializers.</li><li>An <code>ApplicationEnvironmentPreparedEvent</code> is sent when the <code>Environment</code> to be used in the context is known but before the context is created.</li><li>An <code>ApplicationContextInitializedEvent</code> is sent when the <code>ApplicationContext</code> is prepared and ApplicationContextInitializers have been called but before any bean definitions are loaded.</li><li>An <code>ApplicationPreparedEvent</code> is sent just before the refresh is started but after bean definitions have been loaded.</li><li>An <code>ApplicationStartedEvent</code> is sent after the context has been refreshed but before any application and command-line runners have been called.</li><li>An <code>AvailabilityChangeEvent</code> is sent right after with <code>LivenessState.CORRECT</code> to indicate that the application is considered as live.</li><li>An <code>ApplicationReadyEvent</code> is sent after any <a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.spring-application.command-line-runner">application and command-line runners</a> have been called.</li><li>An <code>AvailabilityChangeEvent</code> is sent right after with <code>ReadinessState.ACCEPTING_TRAFFIC</code> to indicate that the application is ready to service requests.</li><li>An <code>ApplicationFailedEvent</code> is sent if there is an exception on startup.</li></ol><p>上面的列表只包括与 <code>SpringApplication </code>绑定的<code> SpringApplicationEvents</code>。除此之外，以下事件也会在 <code>applicationprepareddevent </code>和 <code>applicationstarteddevent</code> 之后发布:</p><ul><li>A <code>WebServerInitializedEvent</code> is sent after the <code>WebServer</code> is ready. <code>ServletWebServerInitializedEvent</code> and <code>ReactiveWebServerInitializedEvent</code> are the servlet and reactive variants respectively.</li><li>A <code>ContextRefreshedEvent</code> is sent when an <code>ApplicationContext</code> is refreshed.</li></ul><h3 id="7-Web-Environment"><a href="#7-Web-Environment" class="headerlink" title="7. Web Environment"></a>7. Web Environment</h3><p>用来确定<code>WebApplicationType</code>的算法如下:</p><ul><li>如果存在<code>Spring MVC</code>，则会使用一个<code>AnnotationConfigServletWebServerApplicationContext</code></li><li>如果<code>Spring MVC</code>不存在而<code>Spring WebFlux</code>存在，那么会使用一个<code>AnnotationConfigReactiveWebServerApplicationContext</code></li><li>否则，使用<code>AnnotationConfigApplicationContext</code></li></ul><p>这意味着，如果你在同一个应用程序中使用<code>Spring MVC</code>和来自<code>Spring WebFlux</code>的新<code>WebClient</code>，那么默认情况下会使用<code>Spring MVC</code>。你可以通过调用<code>setWebApplicationType(WebApplicationType)</code>轻松覆盖它。也可以通过调用<code>setApplicationContextClass(…)</code>来完全控制<code>ApplicationContext</code>类型，具体可以参考源码去看。</p><h4 id="7-1-Application-Startup-tracking（可用于Debug学习）"><a href="#7-1-Application-Startup-tracking（可用于Debug学习）" class="headerlink" title="7.1 Application Startup tracking（可用于Debug学习）"></a>7.1 Application Startup tracking（可用于Debug学习）</h4><p>在应用程序启动期间，<code>SpringApplication</code>和<code>ApplicationContext</code>执行许多与应用程序生命周期、bean生命周期甚至处理应用程序事件相关的任务。使用<code>ApplicationStartup</code>, Spring框架允许你使用<code>StartupStep</code>对象跟踪应用程序的启动顺序。收集这些数据可以用于分析目的，或者只是为了更好地理解应用程序的启动过程。</p><p>在设置<code>SpringApplication</code>实例时，您可以选择一个<code>ApplicationStartup</code>实现。例如，要使用<code>BufferingApplicationStartup</code>，你可以这样写:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class MyApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication application = new SpringApplication(MyApplication.class);</span><br><span class="line">        application.setApplicationStartup(new BufferingApplicationStartup(2048));</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个可用的实现<code>FlightRecorderApplicationStartup</code>是由Spring Framework提供的。它将Spring特定的启动事件添加到<code>Java Flight Recorder</code>会话中，用于分析应用程序，并将它们的Spring上下文生命周期与<code>JVM</code>事件(如分配、gc、类加载……)关联起来。配置完成后，你可以通过启用<code>Flight Recorder</code>运行应用程序来记录数据:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:StartFlightRecording:filename=recording.jfr,duration=10s -jar demo.jar</span><br></pre></td></tr></table></figure><p>Spring Boot自带<code>BufferingApplicationStartup</code>变量;这个实现是为了缓冲启动步骤，并将它们放入外部度量系统中。应用程序可以在任何组件中请求<code>BufferingApplicationStartup</code>类型的bean。</p><p>Spring Boot还可以配置为公开一个启动端点，该端点以<code>JSON</code>文档的形式提供该信息。</p><h4 id="7-2-外部化配置"><a href="#7-2-外部化配置" class="headerlink" title="7.2 外部化配置"></a>7.2 外部化配置</h4><p>Spring Boot使用了一个非常特殊的PropertySource顺序，其目的是允许合理地重写值。属性按以下顺序考虑(较低项的值覆盖前面项的值):</p><ol><li>Default properties (specified by setting <code>SpringApplication.setDefaultProperties</code>).</li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a> annotations on your <code>@Configuration</code> classes. Please note that such property sources are not added to the <code>Environment</code> until the application context is being refreshed. This is too late to configure certain properties such as <code>logging.*</code> and <code>spring.main.*</code> which are read before refresh begins.</li><li>Config data (such as <code>application.properties</code> files).</li><li>A <code>RandomValuePropertySource</code> that has properties only in <code>random.*</code>.</li><li>OS environment variables.</li><li>Java System properties (<code>System.getProperties()</code>).</li><li>JNDI attributes from <code>java:comp/env</code>.</li><li><code>ServletContext</code> init parameters.</li><li><code>ServletConfig</code> init parameters.</li><li>Properties from <code>SPRING_APPLICATION_JSON</code> (inline JSON embedded in an environment variable or system property).</li><li>Command line arguments.</li><li><code>properties</code> attribute on your tests. Available on <a href="https://docs.spring.io/spring-boot/docs/2.6.3/api/org/springframework/boot/test/context/SpringBootTest.html"><code>@SpringBootTest</code></a> and the <a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.testing.spring-boot-applications.autoconfigured-tests">test annotations for testing a particular slice of your application</a>.</li><li><a href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/test/context/TestPropertySource.html"><code>@TestPropertySource</code></a> annotations on your tests.</li><li><a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#using.devtools.globalsettings">Devtools global settings properties</a> in the <code>$HOME/.config/spring-boot</code> directory when devtools is active.</li></ol><p>配置数据文件的顺序如下:</p><ol><li><a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.external-config.files">Application properties</a> packaged inside your jar (<code>application.properties</code> and YAML variants).</li><li><a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.external-config.files.profile-specific">Profile-specific application properties</a> packaged inside your jar (<code>application-&#123;profile&#125;.properties</code> and YAML variants).</li><li><a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.external-config.files">Application properties</a> outside of your packaged jar (<code>application.properties</code> and YAML variants).</li><li><a href="https://docs.spring.io/spring-boot/docs/2.6.3/reference/htmlsingle/#features.external-config.files.profile-specific">Profile-specific application properties</a> outside of your packaged jar (<code>application-&#123;profile&#125;.properties</code> and YAML variants).</li></ol><h4 id="7-3-Configuring-Random-Values"><a href="#7-3-Configuring-Random-Values" class="headerlink" title="7.3 Configuring Random Values"></a>7.3 Configuring Random Values</h4><p><code>RandomValuePropertySource</code>用于注入随机值(例如，注入秘密或测试用例)。它可以生成<code>integers</code>, <code>longs</code>, <code>uuids</code>, 或<code>string</code>，如下例所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my:</span><br><span class="line">  secret: &quot;$&#123;random.value&#125;&quot;</span><br><span class="line">  number: &quot;$&#123;random.int&#125;&quot;</span><br><span class="line">  bignumber: &quot;$&#123;random.long&#125;&quot;</span><br><span class="line">  uuid: &quot;$&#123;random.uuid&#125;&quot;</span><br><span class="line">  number-less-than-ten: &quot;$&#123;random.int(10)&#125;&quot;</span><br><span class="line">  number-in-range: &quot;$&#123;random.int[1024,65536]&#125;&quot;</span><br></pre></td></tr></table></figure><h4 id="7-4-Type-safe-Configuration-Properties"><a href="#7-4-Type-safe-Configuration-Properties" class="headerlink" title="7.4 Type-safe Configuration Properties"></a>7.4 Type-safe Configuration Properties</h4><h5 id="7-5-JavaBean-properties-binding"><a href="#7-5-JavaBean-properties-binding" class="headerlink" title="7.5  JavaBean properties binding"></a>7.5  JavaBean properties binding</h5><p>可以绑定声明标准javabean属性的bean，如以下示例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(&quot;my.service&quot;)</span><br><span class="line">public class MyProperties &#123;</span><br><span class="line"></span><br><span class="line">    private boolean enabled;</span><br><span class="line"></span><br><span class="line">    private InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    private final Security security = new Security();</span><br><span class="line"></span><br><span class="line">    // getters / setters...</span><br><span class="line"></span><br><span class="line">    public static class Security &#123;</span><br><span class="line"></span><br><span class="line">        private String username;</span><br><span class="line"></span><br><span class="line">        private String password;</span><br><span class="line"></span><br><span class="line">        private List&lt;String&gt; roles = new ArrayList&lt;&gt;(Collections.singleton(&quot;USER&quot;));</span><br><span class="line"></span><br><span class="line">        // getters / setters...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E9%9A%8F%E7%AC%94/">随笔</category>
      
      
      <category domain="http://hznu.asia/tags/SpringBoot/">SpringBoot</category>
      
      
      <comments>http://hznu.asia/2022/01/23/%E9%98%85%E8%AF%BBSpringBoot%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Effective Java--创建和销毁对象</title>
      <link>http://hznu.asia/2022/01/13/Effective-Java-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</link>
      <guid>http://hznu.asia/2022/01/13/Effective-Java-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</guid>
      <pubDate>Thu, 13 Jan 2022 07:28:10 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;第一条：用静态工厂方法代替构造器&quot;&gt;&lt;a href=&quot;#第一条：用静态工厂方法代替构造器&quot; class=&quot;headerlink&quot; title=&quot;第一条：用静态工厂方法代替构造器&quot;&gt;&lt;/a&gt;第一条：用静态工厂方法代替构造器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;静</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="第一条：用静态工厂方法代替构造器"><a href="#第一条：用静态工厂方法代替构造器" class="headerlink" title="第一条：用静态工厂方法代替构造器"></a>第一条：用静态工厂方法代替构造器</h2><blockquote><p>静态工厂方法和构造器方法各有优势，在选择时应根据实际需求选择，而不是盲目采用构造器或者盲目采用静态工厂方法。</p></blockquote><h3 id="静态工厂方法相比于构造器，优势在于有名称"><a href="#静态工厂方法相比于构造器，优势在于有名称" class="headerlink" title="静态工厂方法相比于构造器，优势在于有名称"></a>静态工厂方法相比于构造器，优势在于有名称</h3><p>这个相对来说比较好理解。假如 <strong>BigInteger（int, int, Random）</strong> 返回素数，这时候它的返回类型只能定义为Int类型，调用者如果使用构造器，代码一般如下：</p><p><code>Int getNumber = new BigInteger(3, 9, ...)</code>  </p><p>这样再创建对象的时候，无法判断返回的是一个什么数。，但是使用静态工厂方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Int <span class="title">probablePrime</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">/.../</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则可以通过根据调用 <strong>BigInteger.probablePrime</strong> 来判断出这是一个素数。</p><h3 id="静态工厂方法相比于构造器，不必每次调用时都创建一个新对象"><a href="#静态工厂方法相比于构造器，不必每次调用时都创建一个新对象" class="headerlink" title="静态工厂方法相比于构造器，不必每次调用时都创建一个新对象"></a>静态工厂方法相比于构造器，不必每次调用时都创建一个新对象</h3><p>这种方法类似于设计模式中的享元模式。比如下方代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 <strong>valueOf</strong> 方法时，每次不必返回新的对象，都是返回已有对象的地址引用。</p><h3 id="静态工厂方法相比于构造器，可以返回原返回类型的任何子类型对象"><a href="#静态工厂方法相比于构造器，可以返回原返回类型的任何子类型对象" class="headerlink" title="静态工厂方法相比于构造器，可以返回原返回类型的任何子类型对象"></a>静态工厂方法相比于构造器，可以返回原返回类型的任何子类型对象</h3><p>这个在理解是可能会出现一些偏差。先看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> People <span class="title">createChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Children childer = <span class="keyword">new</span> Children();</span><br><span class="line">        <span class="keyword">return</span> childer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//People的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果使用构造器来创建对象，那么代码就是<code>People people = new People();</code>,这样返回的类型就只是 <strong>People</strong>类了，但是我们使用静态工厂方法的话，如上面代码所示，在静态工厂方法中可以直接返回Children的实例。</p><p>注：当时我的疑惑点主要在于<strong>People类</strong>中的<strong>createChildren()方法</strong>，当时认为<strong>不使用static</strong>也可以返回<strong>Children的实例</strong>。后面想明白，这使用静态工厂来创建对象，如果不使用static，那么该类的实例化会在<strong>createChildren()方法</strong>之前，那么就无法使用该方法来创建对象了。</p><h3 id="静态工厂方法相比于构造器，所返回对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值"><a href="#静态工厂方法相比于构造器，所返回对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值" class="headerlink" title="静态工厂方法相比于构造器，所返回对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值"></a>静态工厂方法相比于构造器，所返回对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值</h3><p>这个相对好理解一些。在静态工厂方法中，我们可以根据参数进行判断，根据参数不同返回不同的值，而构造方法则不行。其实从上一条也可以推出这条。</p><h3 id="静态工厂方法相比于构造器，方法返回对象所属的类，在编写包含该静态工厂方法的类时可以不存在"><a href="#静态工厂方法相比于构造器，方法返回对象所属的类，在编写包含该静态工厂方法的类时可以不存在" class="headerlink" title="静态工厂方法相比于构造器，方法返回对象所属的类，在编写包含该静态工厂方法的类时可以不存在"></a>静态工厂方法相比于构造器，方法返回对象所属的类，在编写包含该静态工厂方法的类时可以不存在</h3><p>这里引用一些别人的例子加上我自己的一些理解，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//四大组成之一：服务接口</span><br><span class="line">public interface LoginService &#123;//这是一个登录服务</span><br><span class="line">    public void login();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//四大组成之二：服务提供者接口</span><br><span class="line">public interface Provider &#123;//登录服务的提供者。通俗点说就是：通过这个newLoginService()可以获得一个服务。</span><br><span class="line">    public LoginService newLoginService();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 这是一个服务管理器，里面包含了四大组成中的三和四</span><br><span class="line"> * 解释：通过注册将 服务提供者 加入map，然后通过一个静态工厂方法 getService(String name) 返回不同的服务。</span><br><span class="line"> */</span><br><span class="line">public class ServiceManager &#123;</span><br><span class="line">    private static final Map&lt;String, Provider&gt; providers = new HashMap&lt;String, Provider&gt;();//map，保存了注册的服务</span><br><span class="line"> </span><br><span class="line">    private ServiceManager() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //四大组成之三：提供者注册API  (其实很简单，就是注册一下服务提供者)</span><br><span class="line">    public static void registerProvider(String name, Provider provider) &#123;</span><br><span class="line">        providers.put(name, provider);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //四大组成之四：服务访问API   (客户端只需要传递一个name参数，系统会去匹配服务提供者，然后提供服务)  (静态工厂方法)</span><br><span class="line">    public static LoginService getService(String name) &#123;</span><br><span class="line">        Provider provider = providers.get(name);</span><br><span class="line">        if (provider == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;No provider registered with name=&quot; + name);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        return provider.newLoginService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码的 <strong>ServiceManager类</strong> 的 <strong>getService()</strong> 方法返回的是 <strong>LoginService()</strong>, 在编写的时候，<strong>LoginService</strong>方法可以没有被初始化等操作，待运行阶段调用前进行初始化等操作即可。</p><h3 id="静态工厂方法相比于构造器的劣势"><a href="#静态工厂方法相比于构造器的劣势" class="headerlink" title="静态工厂方法相比于构造器的劣势"></a>静态工厂方法相比于构造器的劣势</h3><ol><li>静态工厂方法的主要缺点在于，类如果不含公有的或者受保护的构造器，就不能被子类化。</li><li>静态工厂方法的第二个缺点在于，程序员很难发现他们。</li></ol>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/Java/">Java</category>
      
      
      <category domain="http://hznu.asia/tags/Effective-Java/">Effective Java</category>
      
      
      <comments>http://hznu.asia/2022/01/13/Effective-Java-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于NotSingle项目的一些思考</title>
      <link>http://hznu.asia/2021/12/26/%E5%85%B3%E4%BA%8ENotSingle%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</link>
      <guid>http://hznu.asia/2021/12/26/%E5%85%B3%E4%BA%8ENotSingle%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</guid>
      <pubDate>Sun, 26 Dec 2021 02:53:20 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;消息队列的选择&quot;&gt;&lt;a href=&quot;#消息队列的选择&quot; class=&quot;headerlink&quot; title=&quot;消息队列的选择&quot;&gt;&lt;/a&gt;消息队列的选择&lt;/h2&gt;&lt;p&gt;如今用的相对较多的消息队列有ActiveMQ、RabbitMQ、RocketMQ和Kafka这几种，</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="消息队列的选择"><a href="#消息队列的选择" class="headerlink" title="消息队列的选择"></a>消息队列的选择</h2><p>如今用的相对较多的消息队列有ActiveMQ、RabbitMQ、RocketMQ和Kafka这几种，因此该项目消息队列的选择也将从这几种来挑选。</p><p><img src="http://img.hznu.asia/image-20211226110632594.png" alt="http://img.hznu.asia/image-20211226110632594.png"></p><p>对于ActiveMQ，由于其生态并不是很好，没经过大规模吞吐量场景的验证，社区也不是很活跃，因此<strong>不考虑采用</strong>；</p><p>对于RocketMQ，由于目前该产品主要针对的是在校学生，万人左右，虽然是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq">Apache</a>，但 GitHub 上的活跃度其实不算高），基础架构研发实力较强，用 RocketMQ 是很好的选择。但是目前而言，我并没有足够的技术去研究并应用他的底层，而且目前来看也并不需要这么大的吞吐量支持，<strong>不考虑采用</strong>；</p><p>对于KafKa，在大数据领域的实时计算、日志采集等场景使用较多，社区活跃，但是本系统并不涉及这些场景，目前来看也不需要这么大的吞吐量，<strong>不考虑采用</strong>；</p><p>对于RabbitMQ，是一款开源产品，拥有比较稳定的支持，活跃度也高，最主要是之前略有涉及，因此我<strong>选择RabbitMQ</strong>作为该项目消息队列。</p><blockquote><p><strong>本系统中，暂时不使用消息队列</strong>。后期考虑应用在动态发布方面</p></blockquote><h2 id="分布式还是单机"><a href="#分布式还是单机" class="headerlink" title="分布式还是单机"></a>分布式还是单机</h2><p>对于使用分布式还是单机系统，其实我也考虑了很久。</p><p><strong>单机系统</strong>的优点自然不必多少，简单快速开发，而且之前也一直是采用单机系统研发，因此可以快速开始项目的编写。</p><p>在考虑是否采用分布式微服务架构前，当然需要先了解为什么要采用微服务以及传统的单机系统的弊端了。</p><h4 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h4><p>在以往传统的企业系统架构中,我们针对一个复杂的业务需求通常使用对象或业务类型来构建一个单体项目。在项目中我们通常将需求分为三个主要部分:数据库、服务端处理、前端展现。</p><p>在业务发展初期,由于所有的业务逻辑在一个应用中,开发、测试、部署都还比较容易且方便。</p><p>但是,随着企业的发展,系统为了应对不同的业务需求会不断为该单体项目增加不同的业务模块;同时随着移动端设备的进步,前端展现模块已经不仅仅局限于Web的形式,这对于系统后端向前端的支持需要更多的接口模块。</p><p>单体应用由于面对的业务需求更为宽泛,不断扩大的需求会使得单体应用变得越来越臃肿。</p><p>单体应用的问题就逐渐凸显出来,由于单体系统部署在一个进程内,往往我们修改了一个很小的功能,为了部署上线会影响其他功能的运行。</p><p>并且,单体应用中的这些功能模块的使用场景、并发量、消耗的资源类型都各有不同,对于资源的利用又互相影响,这样使得我们对各个业务模块的系统容量很难给出较为准确的评估。</p><p>所以,单体系统在初期虽然可以非常方便地进行开发和使用,但是随着系统的发展,维护成本会变得越来越大,且难以控制。为了解决单体系统变得庞大臃肿之后产生的难以维护的问题,微服务架构诞生了并被大家所关注。</p><p>我们将系统中的不同功能模块拆分成多个不同的服务,这些服务都能够独立部署和扩展。由于每个服务都运行在自己的进程内,在部署上有稳固的边界,这样每个服务的更新都不会影响其他服务的运行。</p><p>同时,由于是独立部署的,我们可以更准确地为每个服务评估性能容量,通过配合服务间的协作流程也可以更容易地发现系统的瓶颈位置,以及给出较为准确的系统级性能容量评估。</p><blockquote><p><strong>但是，由于目前项目并不算太大，因此我将准备先做一版单机的，再在后期学习微服务架构，优化做一版微服务的。</strong></p></blockquote><blockquote><p>总体来说，目前我对该项目的思路如下：</p><ol><li>先构建用户端前端界面</li><li>采用单机系统构建后台，通信使用WebSocket，再搭配一些Redis场景，并逐步优化单机系统</li><li>构建管理后台前端界面，完善后端。初步做出一个可用的系统</li><li>采用分布式微服务框架构建后端，加入消息队列、netty等相关技术</li></ol><p>当然，在开发的过程中也可能适时调整，并不一定完全按照这个过程走。</p></blockquote><p><strong>参考引用：</strong></p><p>【1】 《Spring Cloud 微服务实战》翟永超</p><p>【2】 <a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/why-mq.md">https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/why-mq.md</a></p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/NotSingle/">NotSingle</category>
      
      
      <category domain="http://hznu.asia/tags/NotSingle/">NotSingle</category>
      
      
      <comments>http://hznu.asia/2021/12/26/%E5%85%B3%E4%BA%8ENotSingle%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>前后端分离模式下动态权限管理分析---以JeecgBoot为例</title>
      <link>http://hznu.asia/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/</link>
      <guid>http://hznu.asia/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/</guid>
      <pubDate>Fri, 10 Dec 2021 11:43:47 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;之前也写过关于前后端分离模式下动态权限管理相关的博客，但是由于之前对前后端知识了解尚且匮乏，因此在讲解时难免有讲的不够详细的地方，因此现在再以JeecgBoot项目（后面用 “本项目” 代替该词）中动态权限管理实现方式为例，重新详细讲解一遍。&lt;/p&gt;
&lt;blockquote</description>
        
      
      
      
      <content:encoded><![CDATA[<p>之前也写过关于前后端分离模式下动态权限管理相关的博客，但是由于之前对前后端知识了解尚且匮乏，因此在讲解时难免有讲的不够详细的地方，因此现在再以JeecgBoot项目（后面用 “本项目” 代替该词）中动态权限管理实现方式为例，重新详细讲解一遍。</p><blockquote><p>本例基于Vue2 + SpringBoot来讲解，对于我认为比较基础的知识不再赘述，只讲解实现的大致脉络，并且大部分讲解在代码注释部分，请仔细阅读。</p></blockquote><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p>本项目最重要的方法位于<strong>src</strong>目录下的<strong>permission.js</strong>(注意与/store/modules下的区分)，精简代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line"> (...省略部分与该主题无关内容)</span><br><span class="line">      if (store.getters.permissionList.length === 0) &#123; // 判断vuex的store是否存储有权限列表，以此判断是否获取到（可能缓存了）</span><br><span class="line">        store.dispatch(&#x27;GetPermissionList&#x27;).then(res =&gt; &#123; </span><br><span class="line">              const menuData = res.result.menu;</span><br><span class="line">              if (menuData === null || menuData === &quot;&quot; || menuData === undefined) &#123;</span><br><span class="line">                return;</span><br><span class="line">              &#125;</span><br><span class="line">              let constRoutes = [];</span><br><span class="line">              constRoutes = generateIndexRouter(menuData); // 代码如下文所示</span><br><span class="line">              // 添加主界面路由</span><br><span class="line">              store.dispatch(&#x27;UpdateAppRouter&#x27;,  &#123; constRoutes &#125;).then(() =&gt; &#123; // 代码如下文所示</span><br><span class="line">                // 根据roles权限生成可访问的路由表</span><br><span class="line">                // 动态添加可访问路由表</span><br><span class="line">                router.addRoutes(store.getters.addRouters)</span><br><span class="line">                const redirect = decodeURIComponent(from.query.redirect || to.path)</span><br><span class="line">                if (to.path === redirect) &#123;</span><br><span class="line">                  // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record</span><br><span class="line">                  next(&#123; ...to, replace: true &#125;)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                  // 跳转到目的路由</span><br><span class="line">                  next(&#123; path: redirect &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          .catch(() =&gt; &#123;</span><br><span class="line">           /* notification.error(&#123;</span><br><span class="line">              message: &#x27;系统提示&#x27;,</span><br><span class="line">              description: &#x27;请求用户信息失败，请重试！&#x27;</span><br><span class="line">            &#125;)*/</span><br><span class="line">            store.dispatch(&#x27;Logout&#x27;).then(() =&gt; &#123;</span><br><span class="line">              next(&#123; path: &#x27;/user/login&#x27;, query: &#123; redirect: to.fullPath &#125; &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我认为优秀的代码就是最好的注释，你能根据命名猜测出这段代码的大致意思，所以对于如上代码，我只写了大致的注释。但是有一段代码需要提醒大家。对于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&#x27;GetPermissionList&#x27;).then(...)</span><br></pre></td></tr></table></figure><p>有必要仔细阅读<a href="https://vuex.vuejs.org/zh/guide/actions.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%88%86%E5%8F%91-action">vuex参考文档</a></p><p>此外，对于上述中如下代码，需要进一步解释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&#x27;GetPermissionList&#x27;).then(...)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constRoutes = generateIndexRouter(menuData);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&#x27;UpdateAppRouter&#x27;,  &#123; constRoutes &#125;).then(...)</span><br></pre></td></tr></table></figure><blockquote><p> <strong>store.dispatch(‘GetPermissionList’).then(…)</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GetPermissionList(&#123; commit &#125;) &#123;</span><br><span class="line">      return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        queryPermissionsByUser().then(response =&gt; &#123; // 后台查询用户权限信息</span><br><span class="line">          const menuData = response.result.menu; </span><br><span class="line">          const authData = response.result.auth;</span><br><span class="line">          const allAuthData = response.result.allAuth;</span><br><span class="line">          sessionStorage.setItem(USER_AUTH,JSON.stringify(authData));</span><br><span class="line">          sessionStorage.setItem(SYS_BUTTON_AUTH,JSON.stringify(allAuthData));</span><br><span class="line">          if (menuData &amp;&amp; menuData.length &gt; 0) &#123;</span><br><span class="line">            commit(&#x27;SET_PERMISSIONLIST&#x27;, menuData)</span><br><span class="line">            // 设置系统安全模式</span><br><span class="line">            commit(&#x27;SET_SYS_SAFE_MODE&#x27;, response.result.sysSafeMode)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            reject(&#x27;getPermissionList: permissions must be a non-null array !&#x27;)</span><br><span class="line">          &#125;</span><br><span class="line">          resolve(response)</span><br><span class="line">        &#125;).catch(error =&gt; &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中，上述返回的<strong>response结构</strong>如下所示（节选部分内容）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;success&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;allAuth&quot;</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;online:goGenerateCode&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;代码生成按钮&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:add&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;添加按钮&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:edit&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;用户编辑&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:sex&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;表单性别可见&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:form:birthday&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;禁用生日字段&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;2&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;demo:add&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;demo添加功能&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:form:phone&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;手机号禁用&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;2&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;status&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;auth&quot;</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;demo:add&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;demo添加功能&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;online:goGenerateCode&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;代码生成按钮&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;action&quot;</span>:<span class="string">&quot;user:add&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;describe&quot;</span>:<span class="string">&quot;添加按钮&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;menu&quot;</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;redirect&quot;</span>:<span class="literal">null</span>,</span><br><span class="line">                <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/dashboard/analysis&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;dashboard/Analysis&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                    <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;icon&quot;</span>:<span class="string">&quot;home&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;Analysis&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;首页&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;dashboard-analysis&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;9502685863ab87f0ad1134142788a385&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;redirect&quot;</span>:<span class="literal">null</span>,</span><br><span class="line">                <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/report&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;layouts/RouteView&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;children&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/report/ArchivesStatisticst&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;jeecg/report/ArchivesStatisticst&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;ArchivesStatisticst&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;布局统计报表&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;report-ArchivesStatisticst&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;2aeddae571695cd6380f6d6d334d6e7d&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/report/ViserChartDemo&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;jeecg/report/ViserChartDemo&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;ViserChartDemo&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;ViserChartDemo&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;report-ViserChartDemo&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;020b06793e4de2eee0007f603000c769&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/online/cgreport/6c7f59741c814347905a938f06ee003c&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;modules/online/cgreport/auto/OnlCgreportAutoList&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;0&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;OnlCgreportAutoList&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;Online报表示例&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;online-cgreport-6c7f59741c814347905a938f06ee003c&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;1232123780958064642&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;a93c0c3609dece99e85f4aa1caaac981&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;layouts/IframePageView&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;IframePageView&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;Redis监控&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;&#123;&#123; window._CONFIG[&#x27;domianURL&#x27;] &#125;&#125;/jmreport/view/1352160857479581696?token=$&#123;token&#125;&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;&#123;&#123; window._CONFIG[&#x27;domianURL&#x27;] &#125;&#125;-jmreport-view-1352160857479581696?token=$&#123;token&#125;&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;1352200630711652354&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                    <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;icon&quot;</span>:<span class="string">&quot;bar-chart&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;RouteView&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;统计报表&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;report&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;f0675b52d89100ee88472b6800754a08&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;redirect&quot;</span>:<span class="literal">null</span>,</span><br><span class="line">                <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/form&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;layouts/PageView&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;children&quot;</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/form/step-form&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;examples/form/stepForm/StepForm&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;StepForm&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;分步表单&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;form-step-form&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;6531cf3421b1265aeeeabaab5e176e6d&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;path&quot;</span>:<span class="string">&quot;/form/advanced-form&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;component&quot;</span>:<span class="string">&quot;examples/form/advancedForm/AdvancedForm&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;route&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                            <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;AdvancedForm&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;高级表单&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;form-advanced-form&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;e5973686ed495c379d829ea8b2881fc6&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;meta&quot;</span>:&#123;</span><br><span class="line">                    <span class="attr">&quot;keepAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;internalOrExternal&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">&quot;icon&quot;</span>:<span class="string">&quot;form&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;componentName&quot;</span>:<span class="string">&quot;PageView&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;表单页&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;form&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;e3c13679c73a4f829bcff2aba8fd68b1&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;sysSafeMode&quot;</span>:<span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>:<span class="number">1639477587569</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述数据结构相关说明</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">`&#123; Route &#125;` 对象</span><br><span class="line"></span><br><span class="line">| 参数     | 说明                                        | 类型    | 默认值 |</span><br><span class="line">| -------- | ----------------------------------------- -- ------- | ------ |</span><br><span class="line">| hidden   | 控制路由是否显示在 sidebar                    | boolean | falase |</span><br><span class="line">| redirect | 重定向地址, 访问这个路由时,自定进行重定向         | string  | -      |</span><br><span class="line">| name     | 路由名称, 建议设置,且不能重名                   | string  | -      |</span><br><span class="line">| meta     | 路由元信息（路由附带扩展信息）                   | object  | &#123;&#125;     |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`&#123; Meta &#125;` 路由元信息对象</span><br><span class="line"> </span><br><span class="line">| 参数                | 说明                                                                     | 类型    | 默认值 |</span><br><span class="line">| ------------------- |------------------------------------------------------------------------  ------- ------ |</span><br><span class="line">| title               | 路由标题, 用于显示面包屑, 页面标题 *推荐设置                                   | string  | -      |</span><br><span class="line">| icon                | 路由在 menu 上显示的图标                                                   | string  | -      |</span><br><span class="line">| keepAlive           | 缓存该路由                                                                | boolean | false  |</span><br><span class="line">| hiddenHeaderContent | *特殊 隐藏 [PageHeader]( 组件中的页面带的 面包屑和页面标题栏 )        | boolean | false  |</span><br><span class="line">| permission          | 与项目提供的权限拦截匹配的权限，如果不匹配，则会被禁止访问该路由页面                 | array   | []     |</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>generateIndexRouter(menuData)：</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 生成首页路由</span><br><span class="line">export function generateIndexRouter(data) &#123; // 此处data参数即 menuData</span><br><span class="line">let indexRouter = [&#123;</span><br><span class="line">          path: &#x27;/&#x27;,</span><br><span class="line">          name: &#x27;dashboard&#x27;,</span><br><span class="line">          component: resolve =&gt; require([&#x27;@/components/layouts/TabLayout&#x27;], resolve),</span><br><span class="line">          meta: &#123; title: &#x27;首页&#x27; &#125;,</span><br><span class="line">          redirect: &#x27;/dashboard/analysis&#x27;,</span><br><span class="line">          children: [</span><br><span class="line">            ...generateChildRouters(data) // 代码如下文所示</span><br><span class="line">          ]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          &quot;path&quot;: &quot;*&quot;, &quot;redirect&quot;: &quot;/404&quot;, &quot;hidden&quot;: true</span><br><span class="line">        &#125;]</span><br><span class="line">  return indexRouter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 而上述对应的**generateChildRouters(data)**方法如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">// 生成嵌套路由（子路由）</span><br><span class="line">function generateChildRouters (data) &#123;</span><br><span class="line">  const routers = [];</span><br><span class="line">  for (let item of data) &#123;</span><br><span class="line">    let component = &quot;&quot;;</span><br><span class="line">    if(item.component.indexOf(&quot;layouts&quot;)&gt;=0)&#123; // 其实这里代码就做了一件事，将权限菜单的component进行拼接，得到文件夹的正确路径，不过为啥不一开始在路由表就存好正确的路径暂时没想通，项目较大，应该是迭代或者有其他我没注意到的地方的考虑</span><br><span class="line">       component = &quot;components/&quot;+item.component;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">       component = &quot;views/&quot;+item.component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // eslint-disable-next-line</span><br><span class="line">    let URL = (item.meta.url|| &#x27;&#x27;).replace(/&#123;&#123;([^&#125;&#125;]+)?&#125;&#125;/g, (s1, s2) =&gt; eval(s2)) // URL支持&#123;&#123; window.xxx &#125;&#125;占位符变量</span><br><span class="line">    if (isURL(URL)) &#123;</span><br><span class="line">      item.meta.url = URL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let componentPath</span><br><span class="line">    if(item.component==&quot;modules/online/cgform/OnlCgformHeadList&quot;)&#123;</span><br><span class="line">      componentPath = onlineCommons.OnlCgformHeadList</span><br><span class="line">    &#125;else if(item.component==&quot;modules/online/cgform/OnlCgformCopyList&quot;)&#123;</span><br><span class="line">      componentPath = onlineCommons.OnlCgformCopyList</span><br><span class="line">    &#125;  //(...省略部分与该主题无关的else if，上面的else if其实也无关，主要是最后else中的 `component` )</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      componentPath = resolve =&gt; require([&#x27;@/&#x27; + component+&#x27;.vue&#x27;], resolve)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let menu =  &#123;</span><br><span class="line">      path: item.path,</span><br><span class="line">      name: item.name,</span><br><span class="line">      redirect:item.redirect,</span><br><span class="line">      component: componentPath,</span><br><span class="line">      hidden:item.hidden,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        title:item.meta.title ,</span><br><span class="line">        icon: item.meta.icon,</span><br><span class="line">        url:item.meta.url ,</span><br><span class="line">        permissionList:item.meta.permissionList,</span><br><span class="line">        keepAlive:item.meta.keepAlive,</span><br><span class="line">        internalOrExternal:item.meta.internalOrExternal,</span><br><span class="line">        componentName:item.meta.componentName</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(item.alwaysShow)&#123;</span><br><span class="line">      menu.alwaysShow = true;</span><br><span class="line">      menu.redirect = menu.path;</span><br><span class="line">    &#125;</span><br><span class="line">    if (item.children &amp;&amp; item.children.length &gt; 0) &#123;</span><br><span class="line">      menu.children = [...generateChildRouters( item.children)];</span><br><span class="line">    &#125;</span><br><span class="line">    //根据后台菜单配置，判断是否路由菜单字段，动态选择是否生成路由（为了支持参数URL菜单）</span><br><span class="line">    //判断是否生成路由</span><br><span class="line">    if(item.route &amp;&amp; item.route === &#x27;0&#x27;)&#123;</span><br><span class="line">      //console.log(&#x27; 不生成路由 item.route：  &#x27;+item.route);</span><br><span class="line">      //console.log(&#x27; 不生成路由 item.path：  &#x27;+item.path);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      routers.push(menu);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return routers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>store.dispatch(‘UpdateAppRouter’,  { constRoutes }).then()</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 动态添加主界面路由，需要缓存</span><br><span class="line">    UpdateAppRouter(&#123; commit &#125;, routes) &#123; // 传入的routes为  generateIndexRouter(menuData) 的返回值，见上述该方法的代码</span><br><span class="line">      return new Promise(resolve =&gt; &#123;</span><br><span class="line">        let routelist = routes.constRoutes;</span><br><span class="line">        commit(&#x27;SET_ROUTERS&#x27;, routelist)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h2><blockquote><p>后端部分我个人认为最重要的地方是数据库表的设计，而相关的业务代码其实没什么好讲的，但是还是贴一下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户拥有的菜单权限和按钮权限</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/getUserPermissionByToken&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;?&gt; getUserPermissionByToken() &#123;</span><br><span class="line">Result&lt;JSONObject&gt; result = <span class="keyword">new</span> Result&lt;JSONObject&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//直接获取当前用户不适用前端token</span></span><br><span class="line">LoginUser loginUser = (LoginUser) SecurityUtils.getSubject().getPrincipal();</span><br><span class="line"><span class="keyword">if</span> (oConvertUtils.isEmpty(loginUser)) &#123;</span><br><span class="line"><span class="keyword">return</span> Result.error(<span class="string">&quot;请登录系统！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;SysPermission&gt; metaList = sysPermissionService.queryByUser(loginUser.getUsername());</span><br><span class="line"><span class="comment">//添加首页路由</span></span><br><span class="line"><span class="comment">//需要根据后台的路由配置来实现是否缓存</span></span><br><span class="line"><span class="keyword">if</span>(!PermissionDataUtil.hasIndexPage(metaList))&#123;</span><br><span class="line">SysPermission indexMenu = sysPermissionService.list(<span class="keyword">new</span> LambdaQueryWrapper&lt;SysPermission&gt;().eq(SysPermission::getName,<span class="string">&quot;首页&quot;</span>)).get(<span class="number">0</span>);</span><br><span class="line">metaList.add(<span class="number">0</span>,indexMenu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; roles = sysUserService.getRole(loginUser.getUsername());</span><br><span class="line">            String compUrl = RoleIndexConfigEnum.getIndexByRoles(roles);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotBlank(compUrl))&#123;</span><br><span class="line">List&lt;SysPermission&gt; menus = metaList.stream().filter(sysPermission -&gt; <span class="string">&quot;首页&quot;</span>.equals(sysPermission.getName())).collect(Collectors.toList());</span><br><span class="line">menus.get(<span class="number">0</span>).setComponent(compUrl);</span><br><span class="line">&#125;</span><br><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">JSONArray menujsonArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line"><span class="keyword">this</span>.getPermissionJsonArray(menujsonArray, metaList, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//一级菜单下的子菜单全部是隐藏路由，则一级菜单不显示</span></span><br><span class="line"><span class="keyword">this</span>.handleFirstLevelMenuHidden(menujsonArray);</span><br><span class="line"></span><br><span class="line">JSONArray authjsonArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line"><span class="keyword">this</span>.getAuthJsonArray(authjsonArray, metaList);</span><br><span class="line"><span class="comment">//查询所有的权限</span></span><br><span class="line">LambdaQueryWrapper&lt;SysPermission&gt; query = <span class="keyword">new</span> LambdaQueryWrapper&lt;SysPermission&gt;();</span><br><span class="line">query.eq(SysPermission::getDelFlag, CommonConstant.DEL_FLAG_0);</span><br><span class="line">query.eq(SysPermission::getMenuType, CommonConstant.MENU_TYPE_2);</span><br><span class="line"><span class="comment">//query.eq(SysPermission::getStatus, &quot;1&quot;);</span></span><br><span class="line">List&lt;SysPermission&gt; allAuthList = sysPermissionService.list(query);</span><br><span class="line">JSONArray allauthjsonArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line"><span class="keyword">this</span>.getAllAuthJsonArray(allauthjsonArray, allAuthList);</span><br><span class="line"><span class="comment">//路由菜单</span></span><br><span class="line">json.put(<span class="string">&quot;menu&quot;</span>, menujsonArray);</span><br><span class="line"><span class="comment">//按钮权限（用户拥有的权限集合）</span></span><br><span class="line">json.put(<span class="string">&quot;auth&quot;</span>, authjsonArray);</span><br><span class="line"><span class="comment">//全部权限配置集合（按钮权限，访问权限）</span></span><br><span class="line">json.put(<span class="string">&quot;allAuth&quot;</span>, allauthjsonArray);</span><br><span class="line">json.put(<span class="string">&quot;sysSafeMode&quot;</span>, jeeccgBaseConfig.getSafeMode());</span><br><span class="line">result.setResult(json);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">result.error500(<span class="string">&quot;查询失败:&quot;</span> + e.getMessage());  </span><br><span class="line">log.error(e.getMessage(), e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取几个业务相关（其实就是数据库查询）相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SysPermission&gt; metaList = sysPermissionService.queryByUser(loginUser.getUsername());</span><br><span class="line"></span><br><span class="line">SysPermission indexMenu = sysPermissionService.list(<span class="keyword">new</span> LambdaQueryWrapper&lt;SysPermission&gt;().eq(SysPermission::getName,<span class="string">&quot;首页&quot;</span>)).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; roles = sysUserService.getRole(loginUser.getUsername());</span><br></pre></td></tr></table></figure><h4 id="相关数据库表设计如下"><a href="#相关数据库表设计如下" class="headerlink" title="相关数据库表设计如下"></a>相关数据库表设计如下</h4><blockquote><p>角色和权限相关，那么有权限表必然也有对应的角色表，因此我们关注的重点方向在于权限表、角色表 以及 权限角色关联表。</p></blockquote><blockquote><p><strong>sys_role表</strong></p></blockquote><p><img src="/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/image-20211214212015880.png"></p><blockquote><p><strong>sys_role_permission表（节选）</strong></p></blockquote><p><img src="/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/image-20211214212110982.png" alt="image-20211214212110982"></p><blockquote><p><strong>sys_permission表</strong>(如需看更多数据自行下载代码查看)</p></blockquote><p><img src="/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/image-20211214212252390.png" alt="image-20211214212252390"></p><p><img src="/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/image-20211214213445059.png" alt="image-20211214213445059"></p><blockquote><p>后端sql如下,总之，查询出来的数据就是上面介绍的json数据</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 获取登录用户拥有的权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Object&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;SysPermission&quot;</span>&gt;</span></span><br><span class="line">   SELECT * FROM (</span><br><span class="line">   SELECT p.*</span><br><span class="line">   FROM  sys_permission p</span><br><span class="line">   WHERE (exists(</span><br><span class="line">select a.id from sys_role_permission a</span><br><span class="line">join sys_role b on a.role_id = b.id</span><br><span class="line">join sys_user_role c on c.role_id = b.id</span><br><span class="line">join sys_user d on d.id = c.user_id</span><br><span class="line">where p.id = a.permission_id AND d.username = #&#123;username,jdbcType=VARCHAR&#125;</span><br><span class="line">)</span><br><span class="line">or (p.url like &#x27;%:code&#x27; and p.url like &#x27;/online%&#x27; and p.hidden = 1)</span><br><span class="line">or p.url = &#x27;/online&#x27;)</span><br><span class="line">   and p.del_flag = 0</span><br><span class="line"><span class="comment">&lt;!--update begin Author:lvdandan  Date:20200213 for：加入部门权限 --&gt;</span></span><br><span class="line">   UNION</span><br><span class="line">   SELECT p.*</span><br><span class="line">   FROM  sys_permission p</span><br><span class="line">   WHERE exists(</span><br><span class="line">select a.id from sys_depart_role_permission a</span><br><span class="line">join sys_depart_role b on a.role_id = b.id</span><br><span class="line">join sys_depart_role_user c on c.drole_id = b.id</span><br><span class="line">join sys_user d on d.id = c.user_id</span><br><span class="line">where p.id = a.permission_id AND d.username = #&#123;username,jdbcType=VARCHAR&#125;</span><br><span class="line">   )</span><br><span class="line">   and p.del_flag = 0</span><br><span class="line"><span class="comment">&lt;!--update end Author:lvdandan  Date:20200213 for：加入部门权限 --&gt;</span></span><br><span class="line">   ) h order by h.sort_no ASC</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本思路为：数据库存储菜单结构、页面权限控制信息等，前端根据数据库中的菜单结构和权限信息来渲染一个菜单出来并只显示其有权限的菜单，并在路由守卫中进行权限控制防止手动输入path越权打开页面</p><p>1、前端路由（vue-router）中需要正常创建页面及路由。</p><p>2、数据库存储菜单结构和页面权限信息，需要时从数据库中查询出来</p><ul><li>所有角色都有的界面（比如dashboard）写死在前端</li><li>由权限控制得到的视图路径存在数据库中</li><li>菜单和页面组成上下级关系，一级可以是菜单也可以是内容页，内容页也可以放在菜单下，不可见的内容页也可以放在一个普通内容页下，这样理论（需要页面菜单样式支持）可以组成无限级菜单</li><li>菜单和页面的基本属性见上文 json数据 下面的说明</li><li>不需要控制权限且不需要显示到左侧菜单的路由这里可以不进行管理，比如404页面等</li></ul><p>3、前端打开后获取数据库的所有菜单、页面及结构，根据是否登录、是否需要验证权限等进行控制，或无权限跳转至登录页</p><p>4、用户登录成功后，再获取用户对应的的页面权限列表，使用上一步获得的所有页面、结构和用户拥有权限的列表渲染出一个菜单，只包含此用户拥有权限的相应视图</p><p>5、路由守卫中根据上一步获得的权限列表判断每个跳转，无权限可返回404或无权限页面，防止用户手动输入path越权访问</p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/">前后端分离</category>
      
      
      <category domain="http://hznu.asia/tags/SpringBoot/">SpringBoot</category>
      
      <category domain="http://hznu.asia/tags/Vue/">Vue</category>
      
      
      <comments>http://hznu.asia/2021/12/10/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%A5JeecgBoot%E4%B8%BA%E4%BE%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我的第一篇Blog</title>
      <link>http://hznu.asia/2021/12/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Blog/</link>
      <guid>http://hznu.asia/2021/12/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Blog/</guid>
      <pubDate>Tue, 07 Dec 2021 08:26:08 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;刚刚从剧社排练完已经22：10了，由于今天下午刚刚把博客搭起来，还是回实验室写下了自己的第一篇博客。&lt;/p&gt;
&lt;p&gt;写写删删，也不知道从哪开始写起了。说起来最近还是挺忙的，准确说应该是自己给自己制造的忙碌吧。&lt;/p&gt;
&lt;p&gt;简单来说，搭建这篇博客的目的，简单来说，就是希望记</description>
        
      
      
      
      <content:encoded><![CDATA[<p>刚刚从剧社排练完已经22：10了，由于今天下午刚刚把博客搭起来，还是回实验室写下了自己的第一篇博客。</p><p>写写删删，也不知道从哪开始写起了。说起来最近还是挺忙的，准确说应该是自己给自己制造的忙碌吧。</p><p>简单来说，搭建这篇博客的目的，简单来说，就是希望记录自己的学习过程吧。</p><p>其实在之前也经常在CSDN写过一些博客了，好吧，最近一年基本没写了，原因也是多种多样的。但是最近看了一些书还是深深感受到拥有一个个人博客并且坚持写下去的重要性，<strong>所以也在这里立下一个小小的flag，每周至少坚持总结输出一篇blog！</strong></p><p>之前在CSDN写的文章可能和这个网站本身上面很多的文章一样，东抄一点，西抄一点，质量堪忧，并且并没有很大的价值。</p><p>现在回头来看，从前自己在上面写博客，是为了写而写，并不是真正遇到问题，并且做过详细的了解，而自发的想去总结并且记录它。</p><p>可能有人也会想，我立下的flag不也是一周输出一篇，同样是为了写去写啊。但是我觉得，在研究生期间自己还是有许多时间去学习很多东西，在这个过程中，必然会遇到许许多多的问题，所以一周至少一篇记录总结还是非常合理的！</p><p>在我写博客的过程中，也许会存在许多问题，比如写的不够清楚，或者是我本身技术方面存在不足而导致讲错的地方，这些都是很正常的，我也会坦然接受，毕竟，我现在真的很菜。<strong>但是，也希望你能友善探讨。</strong></p><p>总而言之，尽管我写作的过程中会存在许多不足，我还是会坚持把能做到最好的样子呈现在大家面前。</p><p><strong>“如果我认为我写的博客不比目前我能发现的大多数文章要好，那我就没有必要去写它！”</strong></p><p>这会成为我写作的原则。至于为什么不说是能像很多作者口中的 “比其他所有文章要好”，那是因为我深知自己的水平远远达不到，也正是因为这样，我才决定开始搭建自己的私人博客了，否则，我就直接去出书啦！</p><p><strong>希望我的博客，能对你有所帮助！</strong></p>]]></content:encoded>
      
      
      <category domain="http://hznu.asia/categories/%E9%9A%8F%E7%AC%94/">随笔</category>
      
      
      
      <comments>http://hznu.asia/2021/12/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Blog/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
