<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo32px.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo16px.png">
  <link rel="mask-icon" href="/images/logosvg.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hznu.asia","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇博客是我在阅读 Spring 英文文档过程中记录的对 Spring 的新认知，或者说是之前比较模糊的概念。总而言之，算是我个人的随笔记录，方便以后查看，如果感觉对你帮助不大，可以跳过不看本篇博客。  1. Container OverviewThe org.springframework.context.ApplicationContext interface represents the">
<meta property="og:type" content="article">
<meta property="og:title" content="阅读Spring文档摘录">
<meta property="og:url" content="http://hznu.asia/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/index.html">
<meta property="og:site_name" content="realhuang">
<meta property="og:description" content="这篇博客是我在阅读 Spring 英文文档过程中记录的对 Spring 的新认知，或者说是之前比较模糊的概念。总而言之，算是我个人的随笔记录，方便以后查看，如果感觉对你帮助不大，可以跳过不看本篇博客。  1. Container OverviewThe org.springframework.context.ApplicationContext interface represents the">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hznu.asia/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/development/myblog/source_posts/阅读Spring文档摘录/202004161021529.png">
<meta property="article:published_time" content="2022-01-26T03:33:32.000Z">
<meta property="article:modified_time" content="2022-03-22T08:21:44.137Z">
<meta property="article:author" content="Huang Rui">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hznu.asia/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/development/myblog/source_posts/阅读Spring文档摘录/202004161021529.png">

<link rel="canonical" href="http://hznu.asia/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>阅读Spring文档摘录 | realhuang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="realhuang" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">realhuang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-sitemap fa-fw"></i>留言</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hznu.asia/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="Huang Rui">
      <meta itemprop="description" content="国家地板级演员 GitHub顶级粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="realhuang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          阅读Spring文档摘录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-26 11:33:32" itemprop="dateCreated datePublished" datetime="2022-01-26T11:33:32+08:00">2022-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-22 16:21:44" itemprop="dateModified" datetime="2022-03-22T16:21:44+08:00">2022-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>46k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>42 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>这篇博客是我在阅读 Spring 英文文档过程中记录的对 Spring 的新认知，或者说是之前比较模糊的概念。总而言之，算是我个人的随笔记录，方便以后查看，如果感觉对你帮助不大，可以跳过不看本篇博客。</p>
</blockquote>
<h3 id="1-Container-Overview"><a href="#1-Container-Overview" class="headerlink" title="1. Container Overview"></a>1. Container Overview</h3><p>The <code>org.springframework.context.ApplicationContext</code> interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects.</p>
<p>applicationcontext接口表示Spring IoC容器，并负责实例化、配置和组装bean。容器通过读取配置元数据来获取关于实例化、配置和组装哪些对象的指令。配置元数据以XML、Java注释或Java代码表示。它允许您表达组成应用程序的对象以及这些对象之间的丰富的相互依赖关系。</p>
<h3 id="2-Configuration-Metadata"><a href="#2-Configuration-Metadata" class="headerlink" title="2. Configuration Metadata"></a>2. Configuration Metadata</h3><p>For information about using other forms of metadata with the Spring container, see:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config">Annotation-based configuration</a>: Spring 2.5 introduced support for annotation-based configuration metadata.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java">Java-based configuration</a>: Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus, you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a>, <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a>, <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html"><code>@Import</code></a>, and <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html"><code>@DependsOn</code></a> annotations.</li>
</ul>
<p>Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata configures these beans as <code>&lt;bean/&gt;</code> elements inside a top-level <code>&lt;beans/&gt;</code> element. Java configuration typically uses <code>@Bean</code>-annotated methods within a <code>@Configuration</code> class.</p>
<p>这段我认为需要理解好最后一句话：Java 配置通常在@Configuration 类中使用@Bean 注释的方法。</p>
<blockquote>
<p> Spring3.0开始，@Configuration用于定义配置类，定义的配置类可以替换xml文件，一般和@Bean注解联合使用。@Configuration注解主要标注在某个类上，相当于xml配置文件中的<beans>@Bean注解主要标注在某个方法上，相当于xml配置文件中的<bean></bean></beans></p>
</blockquote>
<p><img src="/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/development\myblog\source_posts\阅读Spring文档摘录\202004161021529.png" alt="D:\development\myblog\source\_posts\阅读Spring文档摘录\202004161021529.png"></p>
<h4 id="2-1-the-basic-structure-of-XML-based-configuration-metadata"><a href="#2-1-the-basic-structure-of-XML-based-configuration-metadata" class="headerlink" title="2.1 the basic structure of XML-based configuration metadata"></a>2.1 the basic structure of XML-based configuration metadata</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;  </span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>The <code>id</code> attribute is a string that identifies the individual bean definition.</li>
<li>The <code>class</code> attribute defines the type of the bean and uses the fully qualified classname.</li>
</ul>
<h3 id="3-Composing-XML-based-Configuration-Metadata"><a href="#3-Composing-XML-based-Configuration-Metadata" class="headerlink" title="3. Composing XML-based Configuration Metadata"></a>3. Composing XML-based Configuration Metadata</h3><p>It can be useful to have bean definitions span multiple XML files. Often, each individual XML configuration file represents a logical layer or module in your architecture.</p>
<p>You can use the application context constructor to load bean definitions from all these XML fragments. This constructor takes multiple <code>Resource</code> locations, as was shown in the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-instantiation">previous section</a>. Alternatively, use one or more occurrences of the <code>&lt;import/&gt;</code> element to load bean definitions from another file or files. The following example shows how to do so:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;import resource=&quot;services.xml&quot;/&gt;</span><br><span class="line">    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;</span><br><span class="line">    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>In the preceding example, external bean definitions are loaded from three files: <code>services.xml</code>, <code>messageSource.xml</code>, and <code>themeSource.xml</code>. <strong>All location paths are relative to the definition file doing the importing, so <code>services.xml</code> must be in the same directory or classpath location as the file doing the importing, while <code>messageSource.xml</code> and <code>themeSource.xml</code> must be in a <code>resources</code> location below the location of the importing file.</strong> As you can see, a leading slash is ignored. However, given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level <code>&lt;beans/&gt;</code> element, must be valid XML bean definitions, according to the Spring Schema.</p>
<p>上述内容主要就是描述了XML如何定义，其中黑体字标出的相对重要些：<strong>所有的位置路径都是相对于执行导入的定义文件的，因此services.xml必须与执行导入的文件位于相同的目录或类路径位置，而messageSource.xml和themeSource.xml必须位于导入文件位置下方的资源位置。</strong></p>
<blockquote>
<p>It is possible, but not recommended, to reference files in parent directories using a relative “../“ path. Doing so creates a dependency on a file that is outside the current application. In particular, this reference is not recommended for <code>classpath:</code> URLs (for example, <code>classpath:../services.xml</code>), where the runtime resolution process chooses the “nearest” classpath root and then looks into its parent directory. Classpath configuration changes may lead to the choice of a different, incorrect directory.</p>
<p>You can always use fully qualified resource locations instead of relative paths: for example, <code>file:C:/config/services.xml</code> or <code>classpath:/config/services.xml</code>. However, be aware that you are coupling your application’s configuration to specific absolute locations. It is generally preferable to keep an indirection for such absolute locations — for example, through “${…}” placeholders that are resolved against JVM system properties at runtime.</p>
</blockquote>
<blockquote>
<p>上述大概意思就是不推荐使用 “../” 这种形式的路径配置，这样做会在当前应用程序之外的文件上创建一个依赖项。特别是不建议<code>classpath:</code> URLs (比如 <code>classpath:../services.xml</code>) 这种形式的引用，运行时解析进程选择“最近的”类路径根，然后查看其父目录。</p>
<p>可以使用完全限定的资源位置而不是绝对位置: 比如  <code>file:C:/config/services.xml</code> 或者<code>classpath:/config/services.xml</code>。但是，请注意，您正在将应用程序的配置耦合到特定的绝对位置。对于这种绝对位置，通常更可取的做法是保持间接性ーー例如，通过在运行时根据 JVM 系统属性解析的“ ${ … }”占位符。</p>
</blockquote>
<h3 id="4-Naming-Beans"><a href="#4-Naming-Beans" class="headerlink" title="4. Naming Beans"></a>4. Naming Beans</h3><p>Every bean has one or more identifiers. These identifiers must be unique within the container that hosts the bean. A bean usually has only one identifier. However, if it requires more than one, the extra ones can be considered aliases.</p>
<p>In XML-based configuration metadata, you use the <code>id</code> attribute, the <code>name</code> attribute, or both to specify the bean identifiers. The <code>id</code> attribute lets you specify exactly one id. </p>
<p>The convention is to use the standard Java convention for instance field names when naming beans. That is, bean names start with a lowercase letter and are camel-cased from there. Examples of such names include <code>accountManager</code>, <code>accountService</code>, <code>userDao</code>, <code>loginController</code>, and so forth.</p>
<p>Naming beans consistently makes your configuration easier to read and understand. <strong>Also, if you use Spring AOP, it helps a lot when applying advice to a set of beans related by name.</strong></p>
<p>With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules described earlier: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved. These are the same rules as defined by <code>java.beans.Introspector.decapitalize</code> (which Spring uses here).</p>
<p>上述前两段主要就是描述每个 bean 都有一个或多个标识符。这些标识符在承载 bean 的容器中必须是唯一的。一个 bean 通常只有一个标识符。但是，如果它需要多于一个，那么额外的那些可以被认为是别名。Bean的命名方式通常有 <code>id</code> 和 <code>name</code> 命名，</p>
<p>中间两段主要介绍了并推荐使用驼峰命名。<strong>但是这部分最后一句加粗的文字目前我并不理解，暂且搁置。</strong></p>
<p>最后一段描述通过在类路径中进行组件扫描，Spring 为未命名的组件生成 bean 名称，遵循前面描述的规则: 本质上，使用简单的类名并将其初始字符转换为小写。<strong>但是，在(不寻常的)特殊情况下，当有多个字符且第一个和第二个字符都是大写字母时，原始大小写将得到保留。这些规则与 java.beans 定义的规则相同。</strong>这部分加粗文字和Java内省机制相关类 <code>Introspector</code> 有关，其中该类相关源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static String decapitalize(String name) &#123;</span><br><span class="line">        if (name == null || name.length() == 0) &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        if (name.length() &gt; 1 &amp;&amp; Character.isUpperCase(name.charAt(1)) &amp;&amp;</span><br><span class="line">                        Character.isUpperCase(name.charAt(0)))&#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        char chars[] = name.toCharArray();</span><br><span class="line">        chars[0] = Character.toLowerCase(chars[0]);</span><br><span class="line">        return new String(chars);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般情况下，把字符串第一个字母变为小写，如把“FooBah”变为“fooBah”。但在特殊情况下，即字符串前两个字母都是大写的时候，什么也不做，如，遇到“URL”，原样返回。</p>
<p>decapitalize()的bug是：如果一个字符串，前两个字母大写，但后面还有小写字母，它仍然返回原字符串！</p>
<p>Hibernate的开发者注意到decapitalize()的特点，所以才在判断语句中使用一个或运算(不然只需要判断方法名截掉“get”，再改第一个字母为小写后的字符串与属性名是否相等即可，这也是按照JavaBean Specification定义的标准做法)。但是，Hibernate没有解决这个bug，可能是他们没有碰到我遇到的情况。</p>
<p>类似sAddress(一般性地说，第一个字母小写，第二个字母大写)属性命名就是bug的诱因。</p>
<p>那么，解决方法有三种：</p>
<p>把属性名改成SAddress，这样就满足上面匹配判断的第二个条件(方法名截掉“get”后，与属性名匹配)。但是，这样做不符合Java命名规范；</p>
<p>把getSAddress()改成getsAddress()，这样也满足上面匹配判断的第二个条件(方法名截掉“get”后，与属性名匹配)。但是，这样做不符合JavaBean命名规范；</p>
<p>把属性名改成strAddress，并形成一种约定：命名属性时，第二个字符只能是小写字母。这个方法不需要做更多地修改，符合所有规范，最为稳妥。</p>
</blockquote>
<h4 id="4-1-Aliasing-a-Bean-outside-the-Bean-Definition"><a href="#4-1-Aliasing-a-Bean-outside-the-Bean-Definition" class="headerlink" title="4.1 Aliasing a Bean outside the Bean Definition"></a>4.1 Aliasing a Bean outside the Bean Definition</h4><p>子系统 a 的配置元数据可以通过 subsystemA-DataSource 的名称引用 DataSource。子系统 b 的配置元数据可以通过 subsystemB-DataSource 的名称来引用 DataSource。当组合使用这两个子系统的主应用程序时，主应用程序通过 myapp-DataSource 的名称引用 DataSource。要让所有三个名称都指向同一个对象，可以向配置元数据添加以下别名定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt;</span><br><span class="line">&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>现在，每个组件和主应用程序都可以通过一个惟一的名称引用 dataSource，并保证不会与任何其他定义发生冲突(有效地创建名称空间) ，但它们引用的是同一个 bean。</p>
<blockquote>
<p>If you use Javaconfiguration, the <code>@Bean</code> annotation can be used to provide aliases. See <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-bean-annotation">Using the <code>@Bean</code> Annotation</a> for details.</p>
</blockquote>
<h4 id="4-2-Instantiation-with-a-Static-Factory-Method（用静态工厂方法实例化）"><a href="#4-2-Instantiation-with-a-Static-Factory-Method（用静态工厂方法实例化）" class="headerlink" title="4.2 Instantiation with a Static Factory Method（用静态工厂方法实例化）"></a>4.2 Instantiation with a Static Factory Method（用静态工厂方法实例化）</h4><p>调用这个方法(带有可选参数，如后面所述)并返回一个活动对象，随后该对象将被视为通过构造函数创建的。这种 bean 定义的一个用途是在遗留代码中调用静态工厂。</p>
<p>下面的 bean 定义指定通过调用 factory 方法创建 bean。该定义不指定返回对象的类型(类) ，只指定包含工厂方法的类。在本例中，createInstance ()方法必须是静态方法。下面的示例演示如何指定工厂方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    class=&quot;examples.ClientService&quot;</span><br><span class="line">    factory-method=&quot;createInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>下面的示例展示了一个与前面的 bean 定义一起工作的类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ClientService &#123;</span><br><span class="line">    private static ClientService clientService = new ClientService();</span><br><span class="line">    private ClientService() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static ClientService createInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>遗留代码: Legacy Code</p>
<p>遗留代码是指不再受支持的应用程序系统源代码类型。遗留代码也可以指不支持的操作系统、硬件和格式。在大多数情况下，遗留代码被转换为现代软件语言和平台。然而，为了保留熟悉的用户功能，遗留代码有时会被带入新的环境中。</p>
</blockquote>
<blockquote>
<p>这里可以参考我的另一篇博客来理解静态工厂方法创建对象：<a href="https://hznu.asia/2022/01/13/Effective-Java-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/">Effective Java–创建和销毁对象</a></p>
</blockquote>
<h4 id="4-3-Instantiation-by-Using-an-Instance-Factory-Method-（使用实例工厂方法实例化）"><a href="#4-3-Instantiation-by-Using-an-Instance-Factory-Method-（使用实例工厂方法实例化）" class="headerlink" title="4.3 Instantiation by Using an Instance Factory Method （使用实例工厂方法实例化）"></a>4.3 Instantiation by Using an Instance Factory Method （使用实例工厂方法实例化）</h4><p>与通过静态工厂方法进行的实例化类似，使用实例工厂方法进行的实例化，从容器中调用现有 bean 的非静态方法来创建新 bean。要使用这种机制，保留 class 属性为空，并在 factory-bean 属性中，在当前(或父或祖先)容器中指定 bean 的名称，该容器包含要调用来创建对象的实例方法。使用 factory-method 属性设置 factory 方法本身的名称。下面的例子展示了如何配置这样一个 bean:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span><br><span class="line">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;</span><br><span class="line">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- the bean to be created via the factory bean --&gt;</span><br><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createClientServiceInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>下面的示例展示了相应的类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultServiceLocator &#123;</span><br><span class="line"></span><br><span class="line">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    public ClientService createClientServiceInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个工厂类也可以容纳多个工厂方法，如下面的示例所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;</span><br><span class="line">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;clientService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createClientServiceInstance&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;accountService&quot;</span><br><span class="line">    factory-bean=&quot;serviceLocator&quot;</span><br><span class="line">    factory-method=&quot;createAccountServiceInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>下面的示例展示了相应的类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultServiceLocator &#123;</span><br><span class="line"></span><br><span class="line">    private static ClientService clientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    private static AccountService accountService = new AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    public ClientService createClientServiceInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AccountService createAccountServiceInstance() &#123;</span><br><span class="line">        return accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法表明，工厂 bean 本身可以通过依赖注入管理器(DI)来管理和配置。详见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-properties-detailed">依赖关系和配置</a>。</p>
<blockquote>
<p>在 Spring 文档中，”factory bean” 指的是在 Spring 容器中配置并通过实例或静态工厂方法创建对象的 bean。相比之下，FactoryBean (注意大写)引用了一个 spring 特定的 FactoryBean 实现类。</p>
</blockquote>
<h4 id="4-4-Determining-a-Bean’s-Runtime-Type"><a href="#4-4-Determining-a-Bean’s-Runtime-Type" class="headerlink" title="4.4 Determining a Bean’s Runtime Type"></a>4.4 Determining a Bean’s Runtime Type</h4><p>确定特定 bean 的运行时类型并不简单。Bean 元数据定义中的指定类仅仅是一个初始类引用，它可能与已声明的工厂方法或 FactoryBean 类结合在一起，后者可能导致 bean 的不同运行时类型，或者在实例级工厂方法(可以通过指定的工厂 bean 名称解析)的情况下根本不设置类。此外，AOP 代理可以使用基于接口的代理来包装 bean 实例，对目标 bean 的实际类型(仅仅是实现的接口)进行有限的公开。</p>
<p>查找特定 bean 的实际运行时类型的推荐方法是 BeanFactory.getType 调用指定的 bean 名称。这将考虑上述所有情况，并返回 BeanFactory.getBean 调用将返回的对象类型。</p>
<h3 id="5-Dependencies"><a href="#5-Dependencies" class="headerlink" title="5. Dependencies"></a>5. Dependencies</h3><h4 id="5-1-Constructor-Argument-Resolution"><a href="#5-1-Constructor-Argument-Resolution" class="headerlink" title="5.1 Constructor Argument Resolution"></a>5.1 <strong>Constructor Argument Resolution</strong></h4><p>使用参数的类型进行构造函数参数解析匹配。如果 bean 定义的构造函数参数中没有潜在的歧义，那么在 bean 定义中定义构造函数参数的顺序就是在 bean 被实例化时这些参数被提供给相应的构造函数的顺序。参考下面的类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ThingOne &#123;</span><br><span class="line"></span><br><span class="line">    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 ThingTwo 和 thingThree类<strong>不通过继承关联</strong>，则不存在潜在的歧义。因此，下面的配置可以很好地工作，不需要在 &lt; constructor-arg/&gt; 元素中显式地指定构造函数参数索引或类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;beanTwo&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;beanThree&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>当引用另一个 bean 时，该类型是已知的，并且可以进行匹配(与前面的示例一样)。当使用简单类型时，如 <code>&lt; value &gt; true &lt;/value&gt;</code> ，Spring 无法确定值的类型，因此在没有帮助的情况下无法按类型进行匹配。参考下面的类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    // Number of years to calculate the Ultimate Answer</span><br><span class="line">    private final int years;</span><br><span class="line"></span><br><span class="line">    // The Answer to Life, the Universe, and Everything</span><br><span class="line">    private final String ultimateAnswer;</span><br><span class="line"></span><br><span class="line">    public ExampleBean(int years, String ultimateAnswer) &#123;</span><br><span class="line">        this.years = years;</span><br><span class="line">        this.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型匹配</strong></p>
<p>在前面的场景中，如果使用 type 属性显式指定构造函数参数的类型，那么容器可以对简单类型使用类型匹配，如下面的示例所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p><strong>构造函数参数的顺序</strong></p>
<p>可以使用 index 属性显式指定构造函数参数的索引，如下面的示例所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>除了解决多个简单值的不确定性，指定索引还可以解决构造函数具有两个相同类型的参数时的不确定性。</p>
<h3 id="5-2-Constructor-based-or-setter-based-DI"><a href="#5-2-Constructor-based-or-setter-based-DI" class="headerlink" title="5.2 Constructor-based or setter-based DI?"></a>5.2 Constructor-based or setter-based DI?</h3><p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies. Note that use of the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-required-annotation">@Required</a> annotation on a setter method can be used to make the property be a required dependency; however, constructor injection with programmatic validation of arguments is preferable.</p>
<p><strong>The Spring team generally advocates constructor injection,</strong> as it lets you implement application components as immutable objects and ensures that required dependencies are not <code>null</code>. Furthermore, constructor-injected components are always returned to the client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.</p>
<p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. <strong>One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later.</strong> Management through <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx">JMX MBeans</a> is therefore a compelling use case for setter injection.</p>
<p>Use the DI style that makes the most sense for a particular class. Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, then constructor injection may be the only available form of DI.</p>
<blockquote>
<p>译：由于可以混合使用基于构造函数和基于 setter 的 DI，因此对于强制依赖项使用构造函数和对于可选依赖项使用 setter 方法或配置方法是一个很好的经验法则。注意，在 setter 方法上使用@Required 注释可以使该属性成为必需的依赖项; 但是，带有参数编程验证的构造函数注入更可取。</p>
<p><strong>Spring 团队通常提倡构造函数注入，</strong>因为它允许您将应用程序组件实现为不可变对象，并确保所需的依赖项不为空。此外，构造函数注入的组件总是以完全初始化的状态返回给客户机(调用)代码。作为一个旁注，大量的构造函数参数是糟糕的代码，<strong>（本博客作者注：在《代码整洁之道》书中，作者建议一般不超过三个参数，超过的话意味着要对函数进行拆分）</strong>，这意味着类可能有太多的责任，应该重构以更好地解决适当的关注点分离/代码。</p>
<p>Setter 注入应该主要用于可选的依赖项，这些依赖项可以在类中分配合理的默认值。否则，必须在代码使用依赖项的所有地方执行非空检查。<strong>Setter 注入的一个好处是 setter 方法使该类的对象容易在以后重新配置或重新注入。</strong>因此，通过 JMX MBeans进行管理是 setter 注入的一个引人注目的用例。</p>
<p>使用对特定类最有意义的DI样式。有时，在处理没有源代码的第三方类时，可以自行选择。例如，如果一个第三方类不公开任何setter方法，那么构造函数注入可能是DI的唯一可用形式。</p>
</blockquote>
<blockquote>
<p><strong>构造注入是必须把一个对象的所有依赖的对象都进行实例化，才能实例化这个对象</strong></p>
<p><strong>Setter注入是先实例化这个对象，然后找到依赖的对象，对依赖的对象进行实例化。</strong></p>
<p>setter注入： 一般情况下所有的java bean, 我们都会使用setter方法和getter方法去设置和获取属性的值，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class namebean &#123;</span><br><span class="line">	String   name;</span><br><span class="line">	public void setName(String a) &#123;</span><br><span class="line">		name = a; </span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会创建一个bean的实例然后设置属性的值，spring的配置文件如下：</p>
<p>我们会创建一个bean的实例然后设置属性的值，spring的配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bean1″ &gt;</span><br><span class="line">	&lt;property  name=&quot;name&quot; &gt;</span><br><span class="line">		&lt;value&gt;tom&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>Spring会调用setName方法来只是name属性为tom<br>构造方法注入：构造方法注入中，我们使用带参数的构造方法如下：</p>
<p>Spring会调用setName方法来只是name属性为tom<br>构造方法注入：构造方法注入中，我们使用带参数的构造方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class namebean &#123;</span><br><span class="line">	String name;</span><br><span class="line">	public namebean(String a) &#123;</span><br><span class="line">		name = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会在创建bean实例的时候以new namebean(”tom”)的方式来设置name属性, Spring配置文件如下：</p>
<p>我们会在创建bean实例的时候以new namebean(”tom”)的方式来设置name属性, Spring配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bean1″ &gt;</span><br><span class="line">	&lt;constructor-arg&gt;</span><br><span class="line">		&lt;value&gt;My Bean Value&lt;/value&gt;</span><br><span class="line">	&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>使用constructor-arg标签来设置构造方法的参数。</p>
<p>使用constructor-arg标签来设置构造方法的参数。</p>
<p>引用：<a target="_blank" rel="noopener" href="https://www.iteye.com/blog/yunqiang-zhang-hotmail-com-1601999">构造注入和Setter注入</a></p>
</blockquote>
<h4 id="5-3-Dependency-Resolution-Process（依赖解析的过程）"><a href="#5-3-Dependency-Resolution-Process（依赖解析的过程）" class="headerlink" title="5.3  Dependency Resolution Process（依赖解析的过程）"></a>5.3  Dependency Resolution Process（依赖解析的过程）</h4><p>The container performs bean dependency resolution as follows:</p>
<ul>
<li>The <code>ApplicationContext</code> is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified by XML, Java code, or annotations.</li>
<li>For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method (if you use that instead of a normal constructor). These dependencies are provided to the bean, when the bean is actually created.</li>
<li>Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.</li>
<li><strong>Each property or constructor argument that is a value is converted from its specified format to the actual type of that property or constructor argument. By default, Spring can convert a value supplied in string format to all built-in types, such as <code>int</code>, <code>long</code>, <code>String</code>, <code>boolean</code>, and so forth.</strong></li>
</ul>
<p>The Spring container validates the configuration of each bean as the container is created. However, the bean properties themselves are not set until the bean is actually created. Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Scopes are defined in <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes">Bean Scopes</a>. Otherwise, the bean is created only when it is requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s dependencies and its dependencies’ dependencies (and so on) are created and assigned. Note that resolution mismatches among those dependencies may show up late — that is, on first creation of the affected bean.</p>
<blockquote>
<p>容器执行 bean 依赖项解析如下:</p>
<p>创建 ApplicationContext 并使用描述所有 bean 的配置元数据进行初始化。可以通过 XML、 Java 代码或注释指定配置元数据。</p>
<p>对于每个 bean，它的依赖关系以属性、构造函数参数或静态工厂方法的参数的形式表示(如果您使用静态工厂方法而不是普通的构造函数)。在实际创建 bean 时，这些依赖项被提供给 bean。</p>
<p>每个属性或构造函数参数都是要设置的值的实际定义，或对容器中另一个 bean 的引用。</p>
<p><strong>作为值的每个属性或构造函数参数都将从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，如 int、 long、 String、 boolean 等。</strong></p>
<p>Spring 容器在创建容器时验证每个 bean 的配置。但是，在 bean 实际创建之前，不会设置 bean 属性本身。在创建容器时，将创建单一作用域并设置为预实例化(默认情况)的 bean。作用域在 Bean 作用域中定义。否则，只有在请求 bean 时才会创建它。创建 bean 可能会导致创建 bean 图，因为创建和分配 bean 的依赖项及其依赖项的依赖项(等等)。在首次创建受影响的 bean 时,请注意，这些依赖项之间的解析不匹配可能会延迟出现。</p>
</blockquote>
<p>You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created. This means that a Spring container that has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies — for example, the bean throws an exception as a result of a missing or invalid property. This potentially delayed visibility of some configuration issues is why <code>ApplicationContext</code> implementations by default pre-instantiate singleton beans. At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the <code>ApplicationContext</code> is created, not later. You can still override this default behavior so that singleton beans initialize lazily, rather than being eagerly pre-instantiated.</p>
<p>If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean. This means that, if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A. In other words, the bean is instantiated (if it is not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean">configured init method</a> or the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean">InitializingBean callback method</a>) are invoked.</p>
<blockquote>
<p>通常可以相信 Spring 会做正确的事情。它在容器加载时检测配置问题，例如对不存在的 bean 和循环依赖项的引用。Spring 在实际创建 bean 时设置属性并尽可能晚地解析依赖项。这意味着，如果创建对象或其某个依赖项时出现问题，那么正确加载的 Spring 容器随后可以在请求对象时生成异常ーー例如，由于缺少或无效属性，bean 抛出异常。一些配置问题的可见性可能会延迟，这就是为什么默认情况下 ApplicationContext 实现会预先实例化单例 bean。在实际需要这些 bean 之前，需要花费一些前期时间和内存来创建它们，因此在创建 ApplicationContext 时(而不是以后)会发现配置问题。您仍然可以覆盖这个默认行为，以便单例 bean 以惰性方式初始化，而不是急切地预先实例化。</p>
<p>如果不存在循环依赖关系，当一个或多个合作 bean 被注入到依赖 bean 中时，每个合作 bean 在被注入到依赖 bean 之前都会被完全配置。这意味着，如果 bean a 对 bean b 有依赖关系，那么在调用 bean a 上的 setter 方法之前，Spring IoC 容器将完全配置 bean b。换句话说，bean 被实例化(如果它不是预实例化的单例) ，它的依赖关系被设置，相关的生命周期方法(如配置的 init 方法或 InitializingBean 回调方法)被调用。</p>
</blockquote>
<h3 id="6-Dependencies-and-Configuration-in-Detail"><a href="#6-Dependencies-and-Configuration-in-Detail" class="headerlink" title="6. Dependencies and Configuration in Detail"></a>6. Dependencies and Configuration in Detail</h3><h4 id="6-1-Straight-Values-Primitives-Strings-and-so-on"><a href="#6-1-Straight-Values-Primitives-Strings-and-so-on" class="headerlink" title="6.1 Straight Values (Primitives, Strings, and so on)"></a>6.1 Straight Values (Primitives, Strings, and so on)</h4><p>元素的 value 属性将属性或构造函数参数指定为人类可读的字符串表示形式。Spring 的转换服务用于将这些值从 String 转换为属性或参数的实际类型。下面的示例显示了正在设置的各种值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">    &lt;!-- results in a setDriverClassName(String) call --&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;misterkaoli&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>下面的示例使用 p 名称空间进行更简洁的 XML 配置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span><br><span class="line">        destroy-method=&quot;close&quot;</span><br><span class="line">        p:driverClassName=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">        p:url=&quot;jdbc:mysql://localhost:3306/mydb&quot;</span><br><span class="line">        p:username=&quot;root&quot;</span><br><span class="line">        p:password=&quot;misterkaoli&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>还可以配置 java.util.Properties 实例，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;mappings&quot;</span><br><span class="line">    class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- typed as a java.util.Properties --&gt;</span><br><span class="line">    &lt;property name=&quot;properties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>Spring 容器将 &lt; value/&gt; 元素内的文本转换为 java.util。属性实例，使用 javabean PropertyEditor 机制。这是一个很好的快捷方式，也是 Spring 团队确实喜欢使用嵌套的 &lt; value/&gt; 元素而不是 value 属性样式的少数几个地方之一。</p>
<h4 id="6-2-The-idref-element"><a href="#6-2-The-idref-element" class="headerlink" title="6.2 The idref element"></a>6.2 <strong>The</strong> <code>idref</code> <strong>element</strong></h4><p><code>Idref</code> 元素只是一种防错的方法，用于将容器中另一个 bean 的 id (字符串值——而不是引用)传递给一个 &lt; constructor-arg/&gt; 或 &lt; property/&gt; 元素。下面的例子展示了如何使用它:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;theClientBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;targetName&quot;&gt;</span><br><span class="line">        &lt;idref bean=&quot;theTargetBean&quot;/&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>前面的 bean 定义片段与下面的片段完全等效(在运行时) :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;client&quot; class=&quot;...&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;targetName&quot; value=&quot;theTargetBean&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>第一种形式比第二种更可取，因为使用 idref 标记可以让容器在部署时验证所引用的命名 bean 是否确实存在。在第二个变体中，不对传递给客户端 bean 的 targetName 属性的值执行验证。只有在实际实例化客户端 bean 时才会发现输入错误(很可能会导致致命的结果)。如果客户端 bean 是一个原型 bean，那么只有在部署容器之后很长时间才能发现这个排版错误和由此产生的异常。</p>
<blockquote>
<p>Idref 元素的本地属性在4.0 beans XSD 中不再受支持，因为它不再在常规 bean 引用上提供值。升级到4.0模式时，将现有的 idref 本地引用更改为 idref bean。</p>
</blockquote>
<h4 id="6-3-Collections"><a href="#6-3-Collections" class="headerlink" title="6.3 Collections"></a>6.3 Collections</h4><p><code>&lt;list/&gt;</code>、<code>&lt;set/&gt;</code>、<code>&lt;map/&gt;</code>和<code>&lt;props/&gt;</code>元素分别设置Java集合类型list、set、map和properties的属性和参数。下面的例子展示了如何使用它们:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;</span><br><span class="line">    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span><br><span class="line">    &lt;property name=&quot;adminEmails&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeList(java.util.List) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someList&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;a list element followed by a reference&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;myDataSource&quot; /&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someMap&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someSet&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;just some string&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;myDataSource&quot; /&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-Strongly-typed-collection"><a href="#6-4-Strongly-typed-collection" class="headerlink" title="6.4 Strongly-typed collection"></a>6.4 <strong>Strongly-typed collection</strong></h4><p>随着Java 5中泛型类型的引入，您可以使用强类型集合。也就是说，可以声明一个Collection类型，使其只能包含(例如)String元素。如果您使用Spring将强类型集合的依赖项注入到bean中，那么您可以利用Spring的类型转换支持，以便在将强类型集合实例的元素添加到集合之前将其转换为适当的类型。下面的Java类和bean定义展示了如何做到这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SomeClass &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Float&gt; accounts;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(Map&lt;String, Float&gt; accounts) &#123;</span><br><span class="line">        this.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;something&quot; class=&quot;x.y.SomeClass&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;accounts&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=&quot;one&quot; value=&quot;9.99&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;two&quot; value=&quot;2.75&quot;/&gt;</span><br><span class="line">                &lt;entry key=&quot;six&quot; value=&quot;3.99&quot;/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>当 <code>something</code> bean的 <code>accounts</code> 属性准备注入时，关于强类型 <code>Map&lt;String, Float&gt;</code> 的元素类型的泛型信息通过反射可用。因此，Spring的类型转换基础设施将各种值元素识别为<code>Float</code>类型，并将字符串值(<code>9.99</code>、<code>2.75</code>和<code>3.99</code>)转换为实际的<code>Float</code>类型。</p>
<h4 id="6-5-XML-Shortcut-with-the-p-namespace"><a href="#6-5-XML-Shortcut-with-the-p-namespace" class="headerlink" title="6.5 XML Shortcut with the p-namespace"></a>6.5 XML Shortcut with the p-namespace</h4><p>p名称空间允许使用bean元素的属性(而不是嵌套的<property>元素)来描述协作bean的属性值，或者两者都使用。</property></p>
<p>Spring支持具有名称空间的可扩展配置格式，名称空间基于XML Schema定义。本章中讨论的bean配置格式是在XML Schema文档中定义的。但是，p名称空间并没有在XSD文件中定义，它只存在于Spring的核心中。</p>
<p>下面的例子展示了两个XML片段(第一个使用标准XML格式，第二个使用p-命名空间)，它们解析到相同的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;email&quot; value=&quot;someone@somewhere.com&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;</span><br><span class="line">        p:email=&quot;someone@somewhere.com&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>该示例显示了bean定义中<code>p-namespace</code>中的一个名为<code>email</code>的属性。这告诉Spring包含一个属性声明。如前所述，<code>p-namespace</code>没有模式定义，因此可以将属性的名称设置为属性名称。</p>
<p>下一个例子包含另外两个bean定义，它们都有对另一个bean的引用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;john-modern&quot;</span><br><span class="line">        class=&quot;com.example.Person&quot;</span><br><span class="line">        p:name=&quot;John Doe&quot;</span><br><span class="line">        p:spouse-ref=&quot;jane&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>这个示例不仅包含使用<code>p-namespace</code>的属性值，而且还使用一种特殊的格式来声明属性引用。第一个bean定义使用<code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code>来创建从<code>bean john</code>到<code>bean jane</code>的引用，而第二个bean定义使用<code>p:spouse-ref=&quot;jane&quot;</code>作为属性来做完全相同的事情。在本例中，<code>spouse</code>是属性名，而<code>-ref</code>部分表明这不是一个直接的值，而是对另一个bean的引用。</p>
<h4 id="6-6-XML-Shortcut-with-the-c-namespace"><a href="#6-6-XML-Shortcut-with-the-c-namespace" class="headerlink" title="6.6 XML Shortcut with the c-namespace"></a>6.6 XML Shortcut with the c-namespace</h4><p>与带有<code>p-namespace</code>的XML Shortcut类似，<strong>在Spring 3.1中引入的<code>c-namespace</code>允许内联属性来配置构造函数参数，而不是嵌套<code>constructor-arg</code>元素。</strong></p>
<p>下面的例子使用了<code>c: namespace</code>来做和from基于构造函数的依赖注入一样的事情:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- traditional declaration with optional argument names --&gt;</span><br><span class="line">    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;email&quot; value=&quot;something@somewhere.com&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- c-namespace declaration with argument names --&gt;</span><br><span class="line">    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot;</span><br><span class="line">        c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p><code>c:</code>命名空间使用与<code>p: </code>one相同的约定(后面的-ref表示bean引用)，通过它们的名称设置构造函数参数。类似地，它需要在XML文件中声明，即使它没有在XSD模式中定义(它存在于Spring核心中)。</p>
<p>对于构造函数参数名不可用的罕见情况(通常是在没有调试信息的情况下编译字节码)，你可以使用回退到参数索引，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- c-namespace index declaration --&gt;</span><br><span class="line">&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:_0-ref=&quot;beanTwo&quot; c:_1-ref=&quot;beanThree&quot;</span><br><span class="line">    c:_2=&quot;something@somewhere.com&quot;/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于XML语法的原因，索引表示法要求前面有_，因为XML属性名称不能以数字开头(尽管有些ide允许)。对于<constructor-arg>元素也可以使用相应的索引表记法，但并不常用，因为这里的声明顺序通常就足够了。</constructor-arg></p>
</blockquote>
<h3 id="7-Method-Injection"><a href="#7-Method-Injection" class="headerlink" title="7. Method Injection"></a>7. Method Injection</h3><p>在大多数应用程序场景中，容器中的大多数bean都是单例的。<strong>当一个单例bean需要与另一个单例bean协作，或者一个非单例bean需要与另一个非单例bean协作时，通常通过将一个bean定义为另一个bean的属性来处理依赖关系。</strong>当bean生命周期不同时，问题就出现了。假设单例bean A需要使用非单例(原型)bean B，也许是在对A的每个方法调用中。容器只创建一次单例bean A，因此只得到一次设置属性的机会。容器不能在每次需要bean B的新实例时为bean A提供新实例。</p>
<p>一种解决方案是放弃某些控制倒置。你可以通过实现ApplicationContextAware接口让bean A知道容器，并且每次bean A需要它时，通过getBean(“B”)调用容器来请求(典型的新)bean B实例。下面的例子展示了这种方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// a class that uses a stateful Command-style class to perform some processing</span><br><span class="line">package fiona.apple;</span><br><span class="line"></span><br><span class="line">// Spring-API imports</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line">public class CommandManager implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    public Object process(Map commandState) &#123;</span><br><span class="line">        // grab a new instance of the appropriate Command</span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        // set the state on the (hopefully brand new) Command instance</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Command createCommand() &#123;</span><br><span class="line">        // notice the Spring API dependency!</span><br><span class="line">        return this.applicationContext.getBean(&quot;command&quot;, Command.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setApplicationContext(</span><br><span class="line">            ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-Request-Session-Application-and-WebSocket-Scopes"><a href="#8-Request-Session-Application-and-WebSocket-Scopes" class="headerlink" title="8.  Request, Session, Application, and WebSocket Scopes"></a>8.  Request, Session, Application, and WebSocket Scopes</h3><h4 id="8-1-Request-scope"><a href="#8-1-Request-scope" class="headerlink" title="8.1  Request scope"></a>8.1  Request scope</h4><p>Spring容器通过为每个HTTP请求使用LoginAction bean定义来创建LoginAction bean的新实例。也就是说，loginAction bean的作用域为HTTP请求级别。您可以随心所欲地更改创建的实例的内部状态，因为从相同的loginAction bean定义创建的其他实例不会在状态中看到这些更改。它们是针对个人要求的。当请求完成处理时，将范围限定在请求的bean丢弃。</p>
<p>在使用注释驱动的组件或Java配置时，可以使用@RequestScope注释将组件分配给请求范围。下面的例子展示了如何做到这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestScope</span><br><span class="line">@Component</span><br><span class="line">public class LoginAction &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-2-Session-Scope"><a href="#8-2-Session-Scope" class="headerlink" title="8.2 Session Scope"></a>8.2 Session Scope</h4><p>Spring容器通过在单个HTTP会话的生命周期中使用<code>UserPreferences </code>bean定义来创建<code>UserPreferences</code> bean的新实例。换句话说，<code>userPreferences</code> bean有效地限定在HTTP <code>Session</code>级别。与请求范围内bean一样,你可以改变内部状态的实例创建尽可能多的你想要的,知道其他HTTP会话实例也使用相同的实例创建<code>userPreferences</code> bean定义看不到这些变化状态,因为他们是特定于一个单独的HTTP会话。当HTTP会话最终被丢弃时，限定在该特定HTTP会话范围内的bean也被丢弃。</p>
<p>在使用注释驱动的组件或Java配置时，可以使用<code>@SessionScope</code>注释将组件分配给会话作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SessionScope</span><br><span class="line">@Component</span><br><span class="line">public class UserPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-3-Application-Scope"><a href="#8-3-Application-Scope" class="headerlink" title="8.3 Application Scope"></a>8.3 Application Scope</h4><p>Spring容器通过对整个web应用程序使用一次<code>AppPreferences bean</code>定义来创建一个<code>AppPreferences bean</code>的新实例。也就是说，<code>appPreferences bean</code>的作用域在<code>ServletContext</code>级别，并存储为一个常规<code>ServletContext</code>属性。这有点类似于弹簧单例bean,但在两个重要方面不同:它是一个单例每<code>ServletContext</code>不是每<code>Spring ApplicationContext</code>(可能有几个在任何给定的web应用程序),它实际上是暴露,因此可见<code>ServletContext</code>属性。</p>
<p>在使用注释驱动的组件或Java配置时，可以使用<code>@ApplicationScope</code>注释将组件分配给应用程序范围。下面的例子展示了如何做到这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ApplicationScope</span><br><span class="line">@Component</span><br><span class="line">public class AppPreferences &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-4-WebSocket-Scope"><a href="#8-4-WebSocket-Scope" class="headerlink" title="8.4 WebSocket Scope"></a>8.4 WebSocket Scope</h4><p>WebSocket作用域与WebSocket会话的生命周期相关，适用于WebSocket上的STOMP应用程序，更多细节请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-websocket-scope">WebSocket作用域</a>。</p>
<h3 id="9-Customizing-the-Nature-of-a-Bean-定制Bean的性质"><a href="#9-Customizing-the-Nature-of-a-Bean-定制Bean的性质" class="headerlink" title="9. Customizing the Nature of a Bean(定制Bean的性质)"></a>9. Customizing the Nature of a Bean(定制Bean的性质)</h3><p>Spring框架提供了许多接口，您可以使用这些接口来定制bean的性质。本节将它们分组如下:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle">Lifecycle Callbacks</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aware-list">Other <code>Aware</code> Interfaces</a></li>
</ul>
<h4 id="9-1-Lifecycle-Callbacks"><a href="#9-1-Lifecycle-Callbacks" class="headerlink" title="9.1 Lifecycle Callbacks"></a>9.1 Lifecycle Callbacks</h4><p>要与容器对bean生命周期的管理交互，你可以实现Spring InitializingBean和DisposableBean接口。容器对前者调用afterPropertiesSet()，对后者调用destroy()，让bean在初始化和销毁bean时执行某些操作。</p>
<blockquote>
<p>JSR-250 <code>@PostConstruct</code>和<code>@PreDestroy</code>注释通常被认为是现代Spring应用程序中接收生命周期回调的最佳实践。使用这些注释意味着您的bean没有耦合到特定于spring的接口。详细信息请参见使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations">Using <code>@PostConstruct</code> and <code>@PreDestroy</code></a>。</p>
<p>如果你不想使用JSR-250注释，但是你仍然想要移除耦合，考虑 <code>init-method</code> 和 <code>destroy-method</code> bean定义元数据。</p>
</blockquote>
<p>在内部，Spring框架使用<code>BeanPostProcessor</code>实现来处理它可以找到并调用适当方法的任何回调接口。如果您需要定制特性或Spring默认不提供的其他生命周期行为，您可以自己实现<code>BeanPostProcessor</code>。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension">Container Extension Points</a>。</p>
<p>除了初始化和销毁回调，spring管理的对象还可以实现<code>Lifecycle</code>接口，这样这些对象就可以参与启动和关闭过程，这是由容器自己的生命周期驱动的。</p>
<p>本节介绍生命周期回调接口。</p>
<h5 id="9-1-1-Initialization-Callbacks"><a href="#9-1-1-Initialization-Callbacks" class="headerlink" title="9.1.1 Initialization Callbacks"></a>9.1.1 Initialization Callbacks</h5><p><code>initializingbean</code>接口允许bean在容器设置完bean上所有必要的属性后执行初始化工作。<code>InitializingBean</code>接口指定了一个单一的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void afterPropertiesSet() throws Exception;</span><br></pre></td></tr></table></figure>

<p>我们建议您不要使用<code>InitializingBean</code>接口，因为它不必要地将代码耦合到Spring。另外，我们建议使用<code>@PostConstruct</code>注释或指定POJO初始化方法。在基于xml的配置元数据的情况下，可以使用<code>init-method</code>属性指定具有空无参数签名的方法的名称。在Java配置中，您可以使用<code>@Bean</code>的<code>initMethod</code>属性。请参见接收生命周期回调。考虑以下例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        // do some initialization work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子和下面的例子(包含两个清单)效果几乎完全相同:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AnotherExampleBean implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        // do some initialization work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，前面两个示例中的第一个并没有将代码与Spring耦合起来。(后一个继承了<code>InitializingBean</code>)</p>
<h5 id="9-1-2-Destruction-Callbacks"><a href="#9-1-2-Destruction-Callbacks" class="headerlink" title="9.1.2 Destruction Callbacks"></a>9.1.2 Destruction Callbacks</h5><p>实现这个接口（ <code>org.springframework.beans.factory.DisposableBean</code>）可以让bean在容器销毁时获得回调函数。DisposableBean接口指定了一个单独的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void destroy() throws Exception;</span><br></pre></td></tr></table></figure>

<p>我们建议您不要使用DisposableBean回调接口，因为它不必要地将代码与Spring耦合起来。另外，我们建议使用@PreDestroy注释或指定bean定义支持的泛型方法。使用基于xml的配置元数据，可以在<bean>上使用destroy-method属性。在Java配置中，您可以使用@Bean的destroyMethod属性。请参见接收生命周期回调。考虑以下定义:</bean></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    public void cleanup() &#123;</span><br><span class="line">        // do some destruction work (like releasing pooled connections)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的定义与下面的定义具有几乎完全相同的效果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AnotherExampleBean implements DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        // do some destruction work (like releasing pooled connections)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，前面两个定义中的第一个并没有将代码与Spring耦合起来。</p>
<blockquote>
<p>……此外本节还有一些没有摘录</p>
</blockquote>
<h5 id="9-1-3-Combining-Lifecycle-Mechanisms（结合生命周期机制）"><a href="#9-1-3-Combining-Lifecycle-Mechanisms（结合生命周期机制）" class="headerlink" title="9.1.3 Combining Lifecycle Mechanisms（结合生命周期机制）"></a>9.1.3 Combining Lifecycle Mechanisms（结合生命周期机制）</h5><p>在Spring 2.5中，你有三个控制bean生命周期行为的选项:</p>
<ul>
<li><code>InitializingBean</code>和<code>DisposableBean</code>回调接口</li>
<li>自定义<code>init()</code>和<code>destroy()</code>方法</li>
<li><code>@PostConstruct</code>和<code>@PreDestroy</code>注释。您可以组合这些机制来控制给定的bean。</li>
</ul>
<h5 id="9-1-4-Startup-and-Shutdown-Callbacks"><a href="#9-1-4-Startup-and-Shutdown-Callbacks" class="headerlink" title="9.1.4 Startup and Shutdown Callbacks"></a>9.1.4 Startup and Shutdown Callbacks</h5><p><code>Lifecycle</code>接口为任何有自己生命周期需求的对象定义了基本方法(比如启动和停止一些后台进程):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Lifecycle &#123;</span><br><span class="line"></span><br><span class="line">    void start();</span><br><span class="line"></span><br><span class="line">    void stop();</span><br><span class="line"></span><br><span class="line">    boolean isRunning();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何spring管理的对象都可以实现<code>Lifecycle</code>接口。然后，当<code>ApplicationContext</code>本身接收到启动和停止信号时(例如，对于运行时的停止/重启场景)，它将这些调用级联到在该上下文中定义的所有<code>Lifecycle</code>实现。它通过委托给<code>LifecycleProcessor</code>来实现，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface LifecycleProcessor extends Lifecycle &#123;</span><br><span class="line"></span><br><span class="line">    void onRefresh();</span><br><span class="line"></span><br><span class="line">    void onClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="9-1-5-Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications"><a href="#9-1-5-Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications" class="headerlink" title="9.1.5 Shutting Down the Spring IoC Container Gracefully in Non-Web Applications"></a>9.1.5 Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</h5><p>本节讲述了在非 web 应用程序中优雅地关闭 Spring IoC 容器，我个人认为这里暂时用的不多，以后有需要再看。</p>
<h3 id="10-Container-Extension-Points（扩展容器）"><a href="#10-Container-Extension-Points（扩展容器）" class="headerlink" title="10 . Container Extension Points（扩展容器）"></a>10 . Container Extension Points（扩展容器）</h3><h4 id="10-1-Customizing-Beans-by-Using-a-BeanPostProcessor"><a href="#10-1-Customizing-Beans-by-Using-a-BeanPostProcessor" class="headerlink" title="10.1 Customizing Beans by Using a BeanPostProcessor"></a>10.1 Customizing Beans by Using a <code>BeanPostProcessor</code></h4><p><code>BeanPostProcessor</code>接口定义了回调方法，您可以实现这些方法来提供您自己的(或覆盖容器的默认值)实例化逻辑、依赖关系解析逻辑，等等。如果您想在Spring容器完成实例化、配置和初始化bean之后实现一些自定义逻辑，您可以插入一个或多个自定义<code>BeanPostProcessor</code>实现。</p>
<p>您可以配置多个BeanPostProcessor实例，并且可以通过设置order属性来控制这些<code>BeanPostProcessor</code>实例运行的顺序。只有当<code>BeanPostProcessor</code>实现了<code>Ordered</code>接口时，才能设置此属性。如果编写自己的<code>BeanPostProcessor</code>，还应该考虑实现<code>Ordered</code>接口。要了解更多细节，请参阅<code>BeanPostProcessor</code>和<code>Ordered</code>接口的javadoc。请参见有关<code>BeanPostProcessor</code>实例的编程式注册的说明。</p>
<h4 id="10-2-Example-Hello-World-BeanPostProcessor-style"><a href="#10-2-Example-Hello-World-BeanPostProcessor-style" class="headerlink" title="10.2 Example: Hello World, BeanPostProcessor-style"></a>10.2 Example: Hello World, <code>BeanPostProcessor</code>-style</h4><p>下面的例子展示了如何在<code>ApplicationContext</code>中编写、注册和使用<code>BeanPostProcessor</code>实例。</p>
<p>第一个示例演示了基本用法。这个例子展示了一个自定义的BeanPostProcessor实现，它在容器创建每个bean时调用它的toString()方法，并将结果字符串打印到系统控制台。</p>
<p>下面的清单显示了自定义的BeanPostProcessor实现类定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package scripting;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line">public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    // simply return the instantiated bean as-is</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line">        return bean; // we could potentially return any object reference here...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) &#123;</span><br><span class="line">        System.out.println(&quot;Bean &#x27;&quot; + beanName + &quot;&#x27; created : &quot; + bean.toString());</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的bean元素使用了<code>InstantiationTracingBeanPostProcessor</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:lang=&quot;http://www.springframework.org/schema/lang&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/lang</span><br><span class="line">        https://www.springframework.org/schema/lang/spring-lang.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;lang:groovy id=&quot;messenger&quot;</span><br><span class="line">            script-source=&quot;classpath:org/springframework/scripting/groovy/Messenger.groovy&quot;&gt;</span><br><span class="line">        &lt;lang:property name=&quot;message&quot; value=&quot;Fiona Apple Is Just So Dreamy.&quot;/&gt;</span><br><span class="line">    &lt;/lang:groovy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    when the above bean (messenger) is instantiated, this custom</span><br><span class="line">    BeanPostProcessor implementation will output the fact to the system console</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean class=&quot;scripting.InstantiationTracingBeanPostProcessor&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>注意<code>InstantiationTracingBeanPostProcesso</code>r是如何定义的。它甚至没有名称，而且，因为它是一个bean，所以可以像其他任何bean一样进行依赖注入。(前面的配置还定义了一个由Groovy脚本支持的bean。Spring的动态语言支持将在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/languages.html#dynamic-language">“动态语言支持”</a>一章中详细介绍。)</p>
<p>以下Java应用程序运行上述代码和配置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.springframework.scripting.Messenger;</span><br><span class="line"></span><br><span class="line">public final class Boot &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) throws Exception &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;scripting/beans.xml&quot;);</span><br><span class="line">        Messenger messenger = ctx.getBean(&quot;messenger&quot;, Messenger.class);</span><br><span class="line">        System.out.println(messenger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述应用程序的输出如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bean &#x27;messenger&#x27; created : org.springframework.scripting.groovy.GroovyMessenger@272961</span><br><span class="line">org.springframework.scripting.groovy.GroovyMessenger@272961</span><br></pre></td></tr></table></figure>



<h4 id="10-3-Example-The-Class-Name-Substitution-PropertySourcesPlaceholderConfigurer"><a href="#10-3-Example-The-Class-Name-Substitution-PropertySourcesPlaceholderConfigurer" class="headerlink" title="10.3 Example: The Class Name Substitution PropertySourcesPlaceholderConfigurer"></a>10.3 Example: The Class Name Substitution <code>PropertySourcesPlaceholderConfigurer</code></h4><p>您可以使用<code>propertysourcesconfigururer</code>来通过使用标准Java Properties格式将bean定义中的属性值外部化到单独的文件中。这样一来，部署应用程序的人员就可以定制特定于环境的属性，如数据库url和密码，而无需修改主XML定义文件或容器文件，从而避免了复杂性或风险。</p>
<p>参考以下基于xml的配置元数据片段，其中定义了一个具有占位符值的数据源:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;locations&quot; value=&quot;classpath:com/something/jdbc.properties&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;dataSource&quot; destroy-method=&quot;close&quot;</span><br><span class="line">        class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>该示例显示了从外部properties文件配置的属性。在运行时，<code>propertysourcesconfigururer</code>被应用于元数据，用来替换数据源的一些属性。要替换的值被指定为<code>$&#123;property-name&#125;</code>形式的占位符，它遵循Ant、log4j和JSP EL风格。</p>
<p>实际值来自另一个标准Java <code>Properties</code>格式的文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=org.hsqldb.jdbcDriver</span><br><span class="line">jdbc.url=jdbc:hsqldb:hsql://production:9002</span><br><span class="line">jdbc.username=sa</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>



<h3 id="11-Annotation-based-Container-Configuration"><a href="#11-Annotation-based-Container-Configuration" class="headerlink" title="11.  Annotation-based Container Configuration"></a>11.  Annotation-based Container Configuration</h3><blockquote>
<p>​                                                                        <strong>注解是否比XML更适合配置Spring?</strong></p>
<p>基于注释的配置的引入提出了这样一个问题:这种方法是否比XML“更好”。简短的回答是“视情况而定”。长一点的答案是，每种方法都有其优点和缺点，通常，这取决于开发人员决定哪种策略更适合他们。由于注解的定义方式，注解在其声明中提供了大量的上下文，从而使配置更短、更简洁。但是，XML擅长在不修改源代码或重新编译它们的情况下连接组件。一些开发人员更喜欢将连接连接到源代码附近，而另一些开发人员则认为，带注释的类不再是pojo，而且，配置变得分散，更难控制。</p>
<p>无论选择什么，Spring都可以容纳这两种风格，甚至可以将它们混合在一起。值得指出的是，通过它的JavaConfig选项，Spring允许以一种非侵入性的方式使用注释，而不涉及目标组件源代码。</p>
</blockquote>
<p>一如既往，您可以将后处理器注册为单独的 bean 定义，但也可以通过在基于 xml 的 Spring 配置中包含以下标记来隐式注册它们(注意包含上下文名称空间) :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;context:annotation-config/&gt;</code>元素隐式地注册了以下的后处理器:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/context/annotation/ConfigurationClassPostProcessor.html"><code>ConfigurationClassPostProcessor</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.15/javadoc-api/org/springframework/context/event/EventListenerMethodProcessor.html"><code>EventListenerMethodProcessor</code></a></li>
</ul>
<blockquote>
<p>&lt;仅在定义注解的应用程序上下文中查找bean上的注解。这意味着，如果你把<code>&lt;context:annotation-config/&gt;</code>放在一个<code>DispatcherServlet</code>的<code>WebApplicationContext</code>中，它只检查你的控制器中的<code>@Autowired</code> bean，而不是你的服务。更多信息请参见<code>DispatcherServlet</code>。</p>
</blockquote>
<p><strong>注释的相关讲解参考Spring官方文档</strong></p>
<h4 id="11-1-Resource和-Autowired的区别"><a href="#11-1-Resource和-Autowired的区别" class="headerlink" title="11.1 @Resource和@Autowired的区别"></a>11.1 <code>@Resource</code>和<code>@Autowired</code>的区别</h4><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40906484/article/details/113937179">https://blog.csdn.net/weixin_40906484/article/details/113937179</a></p>
<h4 id="11-2-基于自定义注解的依赖注入"><a href="#11-2-基于自定义注解的依赖注入" class="headerlink" title="11.2 基于自定义注解的依赖注入"></a>11.2 基于自定义注解的依赖注入</h4><p>您可以创建自己的自定义限定符注释。要做到这一点，请定义一个注释，并在定义中提供<code>@Qualifier</code>注释，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface Genre &#123;</span><br><span class="line"></span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以在自动连接的字段和参数上提供自定义限定符，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Genre(&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionCatalog;</span><br><span class="line"></span><br><span class="line">    private MovieCatalog comedyCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setComedyCatalog(@Genre(&quot;Comedy&quot;) MovieCatalog comedyCatalog) &#123;</span><br><span class="line">        this.comedyCatalog = comedyCatalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，您可以为候选bean定义提供信息。您可以将<code>&lt;qualifier/&gt;</code>标记添加为<code>&lt;bean/&gt;</code>标记的子元素，然后指定类型和值，以匹配您的自定义限定符注释。该类型与注释的完全限定类名相匹配。另外，如果不存在名称冲突的风险，为了方便起见，可以使用简短的类名。下面的例子演示了这两种方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;Genre&quot; value=&quot;Action&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;example.Genre&quot; value=&quot;Comedy&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;movieRecommender&quot; class=&quot;example.MovieRecommender&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>还可以定义自定义限定符注释，在简单的value属性之外或之外接受命名属性。<strong>如果在一个要自动连接的字段或参数上指定了多个属性值，那么bean定义必须匹配所有这些属性值，才能被视为自动连接候选属性</strong>。例如，参考以下注释定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Qualifier</span><br><span class="line">public @interface MovieQualifier &#123;</span><br><span class="line"></span><br><span class="line">    String genre();</span><br><span class="line"></span><br><span class="line">    Format format();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>Format</code>是一个enum，定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Format &#123;</span><br><span class="line">    VHS, DVD, BLURAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要自动连接的字段用自定义限定符标注，并包含两个属性的值:<code>genre</code>和<code>format</code>，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MovieRecommender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.VHS, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyVhsCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.DVD, genre=&quot;Action&quot;)</span><br><span class="line">    private MovieCatalog actionDvdCatalog;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @MovieQualifier(format=Format.BLURAY, genre=&quot;Comedy&quot;)</span><br><span class="line">    private MovieCatalog comedyBluRayCatalog;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，bean定义应该包含匹配的限定符值。这个例子还演示了您可以使用bean的元属性而不是<code>&lt;qualifier/&gt;</code>元素。如果可用，<code>&lt;qualifier/&gt;</code>元素及其属性优先，但如果没有这样的限定符，自动组合机制将返回到<code>&lt;meta/&gt;</code>标记中提供的值，就像下面示例中的最后两个bean定义一样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;</span><br><span class="line">            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;</span><br><span class="line">            &lt;attribute key=&quot;genre&quot; value=&quot;Action&quot;/&gt;</span><br><span class="line">        &lt;/qualifier&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;</span><br><span class="line">            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;</span><br><span class="line">            &lt;attribute key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;</span><br><span class="line">        &lt;/qualifier&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;meta key=&quot;format&quot; value=&quot;DVD&quot;/&gt;</span><br><span class="line">        &lt;meta key=&quot;genre&quot; value=&quot;Action&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;</span><br><span class="line">        &lt;meta key=&quot;format&quot; value=&quot;BLURAY&quot;/&gt;</span><br><span class="line">        &lt;meta key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;</span><br><span class="line">        &lt;!-- inject any dependencies required by this bean --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<h3 id="12-AOP-Concepts"><a href="#12-AOP-Concepts" class="headerlink" title="12. AOP Concepts"></a>12. AOP Concepts</h3><p>相关术语：</p>
<h5 id="1-通知（Advice）"><a href="#1-通知（Advice）" class="headerlink" title="1.通知（Advice）"></a>1.通知（Advice）</h5><p>　　就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。</p>
<h5 id="2-连接点（JoinPoint）"><a href="#2-连接点（JoinPoint）" class="headerlink" title="2.连接点（JoinPoint）"></a>2.连接点（JoinPoint）</h5><p>　　这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。</p>
<h5 id="3-切入点（Pointcut）"><a href="#3-切入点（Pointcut）" class="headerlink" title="3.切入点（Pointcut）"></a>3.切入点（Pointcut）</h5><p>　　上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。</p>
<h5 id="4-切面（Aspect）"><a href="#4-切面（Aspect）" class="headerlink" title="4.切面（Aspect）"></a>4.切面（Aspect）</h5><p>　　切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好<strong>理解</strong>切点，搞出来的，明白这个<strong>概念</strong>就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p>
<h5 id="5-引入（introduction）"><a href="#5-引入（introduction）" class="headerlink" title="5.引入（introduction）"></a>5.引入（introduction）</h5><p>　　允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗</p>
<h5 id="6-目标（target）"><a href="#6-目标（target）" class="headerlink" title="6.目标（target）"></a>6.目标（target）</h5><p>　　引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。</p>
<h5 id="7-代理-proxy"><a href="#7-代理-proxy" class="headerlink" title="7.代理(proxy)"></a>7.代理(proxy)</h5><p>　　怎么实现整套aop机制的，都是通过代理，这个一会给细说。</p>
<h5 id="8-织入-weaving"><a href="#8-织入-weaving" class="headerlink" title="8.织入(weaving)"></a>8.织入(weaving)</h5><p>　　把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。</p>
<p>　　关键就是：切点定义了哪些连接点会得到通知</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Huang Rui
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://hznu.asia/2022/01/26/%E9%98%85%E8%AF%BBSpring%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/" title="阅读Spring文档摘录">http://hznu.asia/2022/01/26/阅读Spring文档摘录/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"># Spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/23/%E9%98%85%E8%AF%BBSpringBoot%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/" rel="prev" title="阅读SpringBoot文档摘录">
      <i class="fa fa-chevron-left"></i> 阅读SpringBoot文档摘录
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/22/%E7%B2%BE%E9%80%9AJPA%E4%B8%8EHibernate-%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3-%E6%91%98%E5%BD%95%E4%B8%8E%E7%90%86%E8%A7%A3/" rel="next" title="精通JPA与Hibernate:对象持久化技术详解--摘录与理解">
      精通JPA与Hibernate:对象持久化技术详解--摘录与理解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Container-Overview"><span class="nav-number">1.</span> <span class="nav-text">1. Container Overview</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Configuration-Metadata"><span class="nav-number">2.</span> <span class="nav-text">2. Configuration Metadata</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-the-basic-structure-of-XML-based-configuration-metadata"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 the basic structure of XML-based configuration metadata</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Composing-XML-based-Configuration-Metadata"><span class="nav-number">3.</span> <span class="nav-text">3. Composing XML-based Configuration Metadata</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Naming-Beans"><span class="nav-number">4.</span> <span class="nav-text">4. Naming Beans</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-Aliasing-a-Bean-outside-the-Bean-Definition"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 Aliasing a Bean outside the Bean Definition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-Instantiation-with-a-Static-Factory-Method%EF%BC%88%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 Instantiation with a Static Factory Method（用静态工厂方法实例化）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-Instantiation-by-Using-an-Instance-Factory-Method-%EF%BC%88%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 Instantiation by Using an Instance Factory Method （使用实例工厂方法实例化）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-Determining-a-Bean%E2%80%99s-Runtime-Type"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 Determining a Bean’s Runtime Type</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Dependencies"><span class="nav-number">5.</span> <span class="nav-text">5. Dependencies</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-Constructor-Argument-Resolution"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 Constructor Argument Resolution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Constructor-based-or-setter-based-DI"><span class="nav-number">6.</span> <span class="nav-text">5.2 Constructor-based or setter-based DI?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-Dependency-Resolution-Process%EF%BC%88%E4%BE%9D%E8%B5%96%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="nav-number">6.1.</span> <span class="nav-text">5.3  Dependency Resolution Process（依赖解析的过程）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Dependencies-and-Configuration-in-Detail"><span class="nav-number">7.</span> <span class="nav-text">6. Dependencies and Configuration in Detail</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-Straight-Values-Primitives-Strings-and-so-on"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 Straight Values (Primitives, Strings, and so on)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-The-idref-element"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 The idref element</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-Collections"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 Collections</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-Strongly-typed-collection"><span class="nav-number">7.4.</span> <span class="nav-text">6.4 Strongly-typed collection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-XML-Shortcut-with-the-p-namespace"><span class="nav-number">7.5.</span> <span class="nav-text">6.5 XML Shortcut with the p-namespace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-XML-Shortcut-with-the-c-namespace"><span class="nav-number">7.6.</span> <span class="nav-text">6.6 XML Shortcut with the c-namespace</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Method-Injection"><span class="nav-number">8.</span> <span class="nav-text">7. Method Injection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Request-Session-Application-and-WebSocket-Scopes"><span class="nav-number">9.</span> <span class="nav-text">8.  Request, Session, Application, and WebSocket Scopes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-Request-scope"><span class="nav-number">9.1.</span> <span class="nav-text">8.1  Request scope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-Session-Scope"><span class="nav-number">9.2.</span> <span class="nav-text">8.2 Session Scope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-Application-Scope"><span class="nav-number">9.3.</span> <span class="nav-text">8.3 Application Scope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-WebSocket-Scope"><span class="nav-number">9.4.</span> <span class="nav-text">8.4 WebSocket Scope</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Customizing-the-Nature-of-a-Bean-%E5%AE%9A%E5%88%B6Bean%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">10.</span> <span class="nav-text">9. Customizing the Nature of a Bean(定制Bean的性质)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-Lifecycle-Callbacks"><span class="nav-number">10.1.</span> <span class="nav-text">9.1 Lifecycle Callbacks</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-1-Initialization-Callbacks"><span class="nav-number">10.1.1.</span> <span class="nav-text">9.1.1 Initialization Callbacks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-2-Destruction-Callbacks"><span class="nav-number">10.1.2.</span> <span class="nav-text">9.1.2 Destruction Callbacks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-3-Combining-Lifecycle-Mechanisms%EF%BC%88%E7%BB%93%E5%90%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="nav-number">10.1.3.</span> <span class="nav-text">9.1.3 Combining Lifecycle Mechanisms（结合生命周期机制）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-4-Startup-and-Shutdown-Callbacks"><span class="nav-number">10.1.4.</span> <span class="nav-text">9.1.4 Startup and Shutdown Callbacks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-5-Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications"><span class="nav-number">10.1.5.</span> <span class="nav-text">9.1.5 Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Container-Extension-Points%EF%BC%88%E6%89%A9%E5%B1%95%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">10 . Container Extension Points（扩展容器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-Customizing-Beans-by-Using-a-BeanPostProcessor"><span class="nav-number">11.1.</span> <span class="nav-text">10.1 Customizing Beans by Using a BeanPostProcessor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-Example-Hello-World-BeanPostProcessor-style"><span class="nav-number">11.2.</span> <span class="nav-text">10.2 Example: Hello World, BeanPostProcessor-style</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-Example-The-Class-Name-Substitution-PropertySourcesPlaceholderConfigurer"><span class="nav-number">11.3.</span> <span class="nav-text">10.3 Example: The Class Name Substitution PropertySourcesPlaceholderConfigurer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Annotation-based-Container-Configuration"><span class="nav-number">12.</span> <span class="nav-text">11.  Annotation-based Container Configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-Resource%E5%92%8C-Autowired%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.1.</span> <span class="nav-text">11.1 @Resource和@Autowired的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">12.2.</span> <span class="nav-text">11.2 基于自定义注解的依赖注入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-AOP-Concepts"><span class="nav-number">13.</span> <span class="nav-text">12. AOP Concepts</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%80%9A%E7%9F%A5%EF%BC%88Advice%EF%BC%89"><span class="nav-number">13.0.1.</span> <span class="nav-text">1.通知（Advice）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%BF%9E%E6%8E%A5%E7%82%B9%EF%BC%88JoinPoint%EF%BC%89"><span class="nav-number">13.0.2.</span> <span class="nav-text">2.连接点（JoinPoint）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%88Pointcut%EF%BC%89"><span class="nav-number">13.0.3.</span> <span class="nav-text">3.切入点（Pointcut）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%88%87%E9%9D%A2%EF%BC%88Aspect%EF%BC%89"><span class="nav-number">13.0.4.</span> <span class="nav-text">4.切面（Aspect）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%BC%95%E5%85%A5%EF%BC%88introduction%EF%BC%89"><span class="nav-number">13.0.5.</span> <span class="nav-text">5.引入（introduction）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E7%9B%AE%E6%A0%87%EF%BC%88target%EF%BC%89"><span class="nav-number">13.0.6.</span> <span class="nav-text">6.目标（target）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E4%BB%A3%E7%90%86-proxy"><span class="nav-number">13.0.7.</span> <span class="nav-text">7.代理(proxy)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E7%BB%87%E5%85%A5-weaving"><span class="nav-number">13.0.8.</span> <span class="nav-text">8.织入(weaving)</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Huang Rui"
      src="/images/me.jpg">
  <p class="site-author-name" itemprop="name">Huang Rui</p>
  <div class="site-description" itemprop="description">国家地板级演员 GitHub顶级粉丝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/18770171448" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;18770171448" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huang Rui</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">282k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:16</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'ug4QbCcxhey1T327h47wyvvV-gzGzoHsz',
      appKey     : 'lWaydRUD874OBFVlx1cw26gj',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
